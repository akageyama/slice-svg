module contour_path_m
  use ut_m
  implicit none
  !!>
        P: positive edge: eastward for edgex and
                          northward for edgey
        M: negative edge: westward for edgex and
                          southward for edgey 
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
  !!<

  type contour_path_t
    integer :: num ! total number of vertex points of the path
    integer :: num_max ! possible max num of vertex points.
    integer :: irange_min, irange_max
    integer :: jrange_min, jrange_max
    integer, dimension(:), allocatable :: list_i, list_j
    integer :: start_position_i, start_position_j
  contains
    procedure :: initialize => contour_path__initialize
    procedure :: register => contour_path__register
    procedure :: reset => contour_path__reset
    procedure :: explore => contour_path__explore
  end type contour_path_t


contains

 
  subroutine turn_left( switch, path,  &
                        edgex_ternary, edgey_ternary,  &
                        direct_now, i_now, j_now, ans  )
    char(len=*) <in> :: switch  ! 'just_check' or 'do_it'
    type(path_vert_t) <io> :: path
    integer, dimension(:,:) <in> :: edgex_ternary, edgey_ternary
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <optout> :: ans

    if ( switch == 'just_check' ) then 
      call ut__assert( present(ans),  &
                      'You forgot to pass check result variable.' )
      ans = .false.  ! default value.
    end if

    call ut__assert( size(edgex_ternary,dim=1) == path.irange_max-1 &
                                              .and.                 &
                     size(edgex_termary,dim=2) == path.jrange_max   &
                                              .and.                 &
                     size(edgey_ternary,dim=1) == path.irange_max   &
                                              .and.                 &
                     size(edgey_termary,dim=2) == path.jrange_max-1 )


    
    select case (direct_now)
      case ('E')
        !!>
               ^        
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn left (northward) or not.
        !!<
        call assert( j <= path.jrange_max-1,  &
                    'Impossible! You are going easthward on j=jmax?!' )
        if ( edgey_ternary(i_now,j_now) == +1 ) then
          if ( switch == 'just_check' ) then
            ans = .true.
          else
            j_now += 1
            direct_now = 'N'
          end if
        end if
      case ('N')
        !!>
              | 
          <-- + --
              ^
              | 
              N
        !!<
        call assert( i >= 2,  &
                    'Impossible!? You are going northward on i=1?!' )
        if ( edgex_ternary(i_now-1,j_now) == -1 ) then
          if ( switch == 'just_check' ) then
            ans = .true.
          else 
            i_now -= 1
            direct_now = 'W'
          end if
        end if
      case ('W')
        !!>
              | 
           -- + <---W
              |  
              v
        !!<
        call assert( j >= 2,  &
                    'Impossible!? You are going westward on j=1?!' )
        if ( edgey_ternary(i_now,j_now-1) == -1 ) then
          if ( switch == 'just_check' ) then
            ans = .true.
          else 
            j_now -= 1
            direct_now = 'S'
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
           -- + -->
              |
        !!<
        call assert( i <= path.irange_max-1,  &
                    'Impossible!? You are going southward on i=imax?!' )
        if ( edgex_ternary(i_now,j_now) == +1 ) then
          if ( switch == 'just_check' ) then
            ans = .true.
          else
            i_now += 1
            direct_now = 'E'
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine turn_left_check

 
  subroutine turn_right( switch, path,  &
                         edgex_ternary, edgey_ternary,  &
                         direct_now, i_now, j_now, ans )
    char(len=*) <in> :: switch  ! 'just_check' or 'do_it'
    type(path_vert_t) <in> :: path
    integer, dimension(:,:) <in> :: edgex_ternary, edgey_ternary
    char(len=1) <in> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <in> :: i_now, j_now
    logical <optout> :: ans

    if ( switch == 'just_check' ) then 
      call ut__assert( present(ans),  &
                      'You forgot to pass check result variable.' )
      ans = .false.  ! default value.
    end if

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn right (southward) or not.
               v
        !!<
        call assert( j >= 2,  &
                    'Impossible! You are going easthward on j=1?!' )
        if ( edgey_ternary(i_now,j_now-1) == -1 ) then
          if ( switch == 'just_check' ) then
          ans = .true.
        else
          j_now -= 1
          direct_now = 'S'
        end if
      case ('N')
        !!>
              | 
           -- + -->
              ^
              | 
              N
        !!<
        call assert( i <= path.irange_max-1,  &
                    'Impossible!? You are going northward on i=imax?!' )
        if ( edgex_ternary(i_now,j_now) == +1 ) then
          if ( switch == 'just_check' ) then 
            ans = .true.
          else
            i_now += 1
            direct_now = 'E'
          end if
        end if
      case ('W')
        !!>
              ^
              | 
           -- + <---W
              |  
        !!<
        call assert( j <= path.jrange_max-1,  &
                    'Impossible!? You are going westward on j=jmax?!' )
        if ( edgey_ternary(i_now,j_now) == +1 ) then
          if ( switch == 'just_check' ) then 
            ans = .true.
          else 
            j_now += 1
            direct_now = 'S'
        end if
      case ('S')
        !!>
              S
              | 
              v
          <-- + -- 
              |
        !!<
        call assert( i >= 2 ,  &
                    'Impossible!? You going southward on i=1?!' )
        if ( edgex_ternary(i_now-1,j_now) == -1 ) then
          if ( switch == 'just_check' ) then 
            ans = .true.
          else
            i_now -= 1
            direct_now = 'W'
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine turn_right  

 
  subroutine go_forward( switch, path,  &
                         edgex_ternary, edgey_ternary,  &
                         direct_now, i_now, j_now, ans )
    char(len=*) <in> :: switch  ! 'just_check' or 'do_it'
    type(path_vert_t) <in> :: path
    integer, dimension(:,:) <in> :: edgex_ternary, edgey_ternary
    char(len=1) <in> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <in> :: i_now, j_now
    logical <optout> :: ans

    if ( switch == 'just_check' ) then 
      call ut__assert( present(ans),  &
                      'You forgot to pass check result variable.' )
      ans = .false.  ! default value.
    end if

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + -->  at '+' point, and moving eastward.
               |      Checking if you can go straight or not.

        !!<
        if ( i_now == irange_max ) return  ! You cannot go forward.
        if ( edgex_ternary(i_now,j_now) == +1 ) then 
          if ( switch == 'just_check' ) then 
            ans = .true.
          else
            i_now += 1
          end if
        end if
      case ('N')
        !!>
               ^
               | 
            -- + --
               ^
               | 
               N
        !!<
        if ( j_now == jrange_max ) return  ! You cannot go forward.
        if ( edgey_ternary(i_now,j_now) == +1 ) then
          if ( switch == 'just_check' ) then 
            ans = .true.
          else
            j_now += 1
          end if
        end if
      case ('W')
        !!>
                | 
            <-- + <---W
                |  
        !!<
        if ( i_now == 1 ) return  ! You cannot go forward.
        if ( edgex_ternary(i_now-1,j_now) == -1 ) then
          if ( switch == 'just_check' ) then
            ans = .true.
          else
            i_now -= 1
          end if
        end if
      case ('S')
        !!>
                S
                | 
                v
             -- + -- 
                |
                v
        !!<
        if ( j_now == 1 ) return  ! You cannot go forward.
        if ( edgey_ternary(i_now,j_now-1) == -1 ) then
          if ( switch == 'just_check' ) then
            ans = .true.
          else
            j_now -= 1
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine go_forward


  subroutine contour_path__reset( this )
    class(contour_path_t) <io> :: this
    this.num = 0
    this.list_i(:) = 0
    this.list_j(:) = 0
    start_position_i = 0
    start_position_j = 0
  end subroutine contour_path__reset


  subroutine contour_path__initialize( this, num_max, imax, jmax )
    class(contour_path_t) <out> :: this
    integer <in> :: num_max, imax, jmax

    allocate(this.list_i(num_max),this.list_j(num_max))
    this.num_max = num_max
    this.irange_min = 1
    this.irange_max = imax
    this.jrange_min = 1
    this.jrange_max = jmax
    call contour_path__reset( this )
  end subroutine contour_path__initialize


  subroutine countour_path__set_start_position( this, i, j )
    class(contour_path_t) <io> :: this
    integer <in> :: i, j

    call ut__assert( this.num == 0,   &
                    'You forgot to reset vert num.' )
    call contour_path__register( this, i, j )
    this.start_position_i = i
    this.start_position_j = j
  end subroutine countour_path__set_start_position


  subroutine contour_path__register( this, i, j )
    class(contour_path_t) <io> :: this
    integer <in> :: i, j

    integer :: n
    n = this.num + 1
    call assert( n <= size(this.list_i,dim=1),  &
                'Increase array size of path_vert.' )
    this.lis_i(n) = i
    this.lis_j(n) = j
    this.num = n
  end subroutine contour_path__register



  subroutine contour_path__explore( this )
    class(contour_path_t) <io> :: this

    integer :: head_i, head_j
    integer :: step_forward_i, step_forward_j
    integer :: step_turn_left_i, step_turn_left_j
    integer :: step_turn_right_i, step_turn_right_j

    !!>
        edge direction from foot-vert to head-vert
                            .
           f-->h   (1,0)    .     f
       ......................     |  (0,-1)
                            .     h   
             h              ...................  
             |     (0,1)    .   
             f              .  h<--f (-1,0)
    !!<

    head_i = this.i(this.num)
    head_j = this.j(this.num)
    foot_i = this.i(this.num-1)
    foot_j = this.j(this.num-1)
    step_forward_i = head_i - foot_i
    step_forward_j = head_j - foot_j
    step_turn_left_i =  -step_forward_j ! Vector
    step_turn_left_j =  +step_forward_i !  outer
    step_turn_right_i = +step_forward_j !   product
    step_turn_right_j = -step_forward_i !    with unit-z.

    if ( step_forward_i==1 ) then
      direct = 'E'
    else if ( step_foward_j==1 ) then
      direct = 'N'
    else if ( step_foward_i==-1) then
      direct = 'W'
    else if ( step_foward_j=-1 )
      direct = 'S'
    else 
      call ut__fatal( 'Something is strange.' )
    end if

    select case (direct)
      case ('E')
        !!>
                             i=hi
                     -o-------o-------o j=hj-1
                      |       |       |
                      |       |<--edgey(hi,hj-1)
                      |       |       |
                     -f======>h-------o j=hj
                              |       |
                              |<--edgey(hi,hj)

        !!<
         
        if ( this.edgey_ternary(head_i,head_j-1) == +1 ) then
          ! turn left


        
  end subroutine contour_path__explore


  ! recursive subroutine trace_edge( edgex, edgey, direct, vi, vj, vert_path )
  !   char(len=2) <io> :: direct
  !   integer <io> :: vi, vj

  !   integer :: ei, ej

  !   ei_left_turn = vi
  !   ej_left_turn = vj
  !   ei_right_turn = vi
  !   ej_right_turn = vj-1
  !   ei_straight_move = vi
  !   ej_straight_move = vj

  !   select case (direct)
  !     case '+x'
  !       !!>
  !                           edgex(ei=3,ej=8)
  !         vert(vi=3,vj=8)   .    vert(vi=4,vj=8)
  !                      \    .   / 
  !                       o------o  
  !         edgey(3,7)....|      |....edgey(ei=4,ej=7)
  !                       |      |
  !                       o=====>V
  !                      /|  .   | \ vert(vi=4,vj=7)
  !        vert(vi=3,vj=7)|  .   |..............edgey(ei=4,ej=6)   
  !                          .   o 
  !           edgex(ei=3,ej=7)    \
  !                                vert(vi=4,vj=6)
  !       !!<
  !       if ( edgey(ei_left_turn,ej_left_turn) == +1 ) then
  !         ! turn to "up"
  !         call path_vert.register( vi, vj )
  !         direct = '+y'
  !         call trace_edge( edgex, edgey, direct, vi, vj, vert_path )
  !       else if ( edgey(ei_right_turn,ej_right_turn) == -1 ) then
  !         ! turn to "down"
  !         call path_vert.register( ei_straight_move,  &
  !                                  ej_straight_move )
  !         vtip_direct = '+x'
  !         return
  !       else 
  !         call ut__assert( edgex(ei+1,ej) == +1,  &
  !                         'Something is strange.' )
  !         direct = '+x'  
  !         call trace_edge( edgex, edgey, direct, vi, vj, vert_path )              
  !       end if



end module contour_path_m