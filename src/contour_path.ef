module contour_path_m
  use ut_m
  use slice_mesh_m
  implicit none
  private

  !!>


  !!<

  integer <const> :: PATH_NORTHWARD = 0    !       0        0 (NORTH)
  integer <const> :: PATH_WESTWARD  = 1    !       |        1 (WEST)
  integer <const> :: PATH_SOUTHWARD = 2    !  1 -- + -- 3   2 (SOUTH)
  integer <const> :: PATH_EASTWARD  = 3    !       |        3 (EAST)
                                           !       2

  type, public :: contour_path__element_t
    char(len=1) :: which_edge ! 'u' or 'v'
    char(len=2) :: lane ! 'in' (bulk) or 'on' (border)
    integer :: i, j  ! edge id (for in-lane), or 
                     ! vertex id (for on-lane).
    integer :: direct
  end type contour_path__element_t

  type, public :: contour_path_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    type(contour_path__element_t) :: start
    type(contour_path__element_t) :: head
    real, dimension(:), allocatable :: list_u, list_v
  contains
    procedure :: initialize => contour_path__initialize
    procedure :: reset => contour_path__reset
    procedure :: trace_and_erase  &
                       => contour_path__trace_and_erase
    procedure :: set_starting_edge &
                       => contour_path__set_starting_edge
    procedure :: is_closed => contour_path__is_closed
  end type contour_path_t


contains


  subroutine register( contour_path, u, v )
    type(contour_path_t) <io> :: contour_path
    real <in> :: u, v

    integer :: n

    n = contour_path.num + 1
    call ut__assert( n <= size(contour_path.list_u,dim=1),  &
                    '__MODFUNC__: Increase array size of path_vert.' )

    contour_path.list_u(n) = u
    contour_path.list_v(n) = v
    contour_path.num = n
  end subroutine register


  subroutine jump_to_u_edge_pm_if_possible( path, edge, jumped, ei0, ej0 )
    type(contour_path_t) <io> :: path
    type(slice_mesh__edge_t) <in> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.u_quarter(ei0,ej0) == SLICE_MESH__EDGE_LEVEL_QUARTER_PM ) then
      jumped = .true.
      u = edge.u_cross_coord(ei0,ej0)
      v = vert.pos_v(ej0)
      call register( path, u, v )
      if ( ej0 == edge.u_nv ) then
        path.head = contour_path_element_t( 'u', 'in', ei0, ej0, SLICE_MESH__BORDER_WESTWARD )
      else
        path.head = contour_path_element_t( 'u', 'in', ei0, ej0, SLICE_MESH__NORTHWARD )
      end if    
    end if
  end subroutine jump_to_u_edge_pm_if_possible


  subroutine jump_to_u_edge_mp_if_possible( path, edge, jumped, ei0, ej0 )
    type(contour_path_t) <io> :: path
    type(slice_mesh__edge_t) <in> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.u_quarter(ei0,ej0) == SLICE_MESH__EDGE_LEVEL_QUARTER_MP ) then
      jumped = .true.
      u = edge.u_cross_coord(ei0,ej0)
      v = vert.pos_v(ej0)
      call register( path, u, v )
      if ( ej0 == 1 ) then
        path.head = contour_path_element_t( 'u', 'in', ei0, ej0, SLICE_MESH__BORDER_EASTWARD )
      else
        path.head = contour_path_element_t( 'u', 'in', ei0, ej0, SLICE_MESH__SOUTHWARD )
      end if    
    end if
  end subroutine jump_to_u_edge_mp_if_possible  


  subroutine jump_to_v_edge_pm_if_possible( path, edge, jumped, ei0, ej0 )
    type(contour_path_t) <io> :: path
    type(slice_mesh__edge_t) <in> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.v_quarter(ei0,ej0) == SLICE_MESH__EDGE_LEVEL_QUARTER_PM ) then
      jumped = .true.
      u = vert.pos_u(ei0)
      v = edge.v_cross_coord(ei0,ej0)
      call register( path, u, v )
      if ( ei0 == 1 ) then
        path.head = contour_path_element_t( 'v', 'in', ei0, ej0, SLICE_MESH__BORDER_SOUTHWARD )
      else
        path.head = contour_path_element_t( 'v', 'in', ei0, ej0, SLICE_MESH__WESTWARD )
      end if
    end if
  end subroutine jump_to_v_edge_pm_if_possible   


  subroutine jump_to_v_edge_mp_if_possible( path, edge, jumped, ei0, ej0 )
    type(contour_path_t) <io> :: path
    type(slice_mesh__edge_t) <in> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.v_quarter(ei0,ej0) == SLICE_MESH__EDGE_LEVEL_QUARTER_MP ) then
      jumped = .true.
      u = vert.pos_u(ei0)
      v = edge.v_cross_coord(ei0,ej0)
      call register( path, u, v )
      if ( ei0 == edge.u_nu ) then
        path.head = contour_path_element_t( 'v', 'in', ei0, ej0, SLICE_MESH__BORDER_NORTHWARD )
      else
        path.head = contour_path_element_t( 'v', 'in', ei0, ej0, SLICE_MESH__EASTWARD )
      end if
    end if
  end subroutine jump_to_v_edge_mp_if_possible    


  subroutine go_along_boundary_on_v_edge_north( path,   &
                                                vert    &
                                                edge )
    type(contour_path_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j

    call ut__assert( path.head.lane == 'on',  &
                     "__MODFUNC__: The path should be on border." )

    call ut__assert( path.head.direct == PATH_NORTHWARD,  &
                     "__MODFUNC__: Wrong call." )

    vi = path.head.i
    vj = path.head.j

    select case ( edge.v_quarter(vi,vj) )
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_PP) 
        !!>
              .       |            
            - + - - - p            
              .       .            
              .       .            
              .       .            
            - + - - - p <== current head of vertex-type (vi,vj)
              .       *            
              .       * <== you came
              .       *     along this edge.
        !!<
        jumped = .true.
        u = vert.pos_u(vi)
        v = vert.pos_v(vj+1)
        call register( path, u, v )
        call mesh_edge.erase( 'v', vi, vj )
        if ( vj+1 == edge.v_nv ) then ! you have reached the north-east corner.
          !!>
                        __ you will go this way.
                       /    
                - + - <=**p <== new head of vertex-type (vi,vj+1)
                  .       *
                  .       *
                  .       *
                - + - - - p
                  .       *
                                          
          !!<
          path.head = contour_path_element_t( 'u', 'on', vi, vj+1, PATH_WESTWARD )
        else
          !!>
                   .       * <== you will go this way.
                   .       *
                 - + - - - p <= new head of vertex type (vi,vj+1)
                   .       *
                   .       *
                   .       *
                 - + - - - p
                   .       *
                   .       *
          !!<
          path.head = contour_path_element_t( 'v', 'on', vi, vj+1, PATH_NORTHWARD )
        end if
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_PM )
        !!>
                   .       |
                 - + - - - m
                   .       .
                   .       * <== new head of edge-type (vi,vj)
                   .       *
                 - + - - - p
                   .       *
                   .       *
        !!<
        jumped = .true.
        u = vert.pos_u(vi)
        v = edge.v_cross_coord(vi,vj)
        call register( path, u, v )
        call mesh_edge.erase( 'v', vi, vj )
        path.head = contour_path_element_t( 'v', 'in', vi, vj, PATH_WESTWARD )
      case default
        call fatal( '__MODFUNC__: Strange. Could not find path.' )
    end select

  end subroutine go_along_boundary_on_v_edge_north


  subroutine go_along_boundary_on_v_edge_south( path,  &
                                                vert,  &
                                                edge )
    type(contour_path_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j

    call ut__assert( path.head.lane == 'on',  &
                     "__MODFUNC__: The path should be on border." )

    call ut__assert( path.head.direct == PATH_NORTHWARD,  &
                     "__MODFUNC__: Wrong call." )

    vi = path.head.i
    vj = path.head.j

    select case ( edge.v_quarter(vi,vj-1) )
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_PP) 
        jumped = .true.
        u = vert.pos_u(vi)
        v = vert.pos_v(vj-1)
        call register( path, u, v )
        call mesh_edge.erase( 'v', vi, vj-1 )
        if ( vj-1 == 1 ) then ! you have reached the south-west corner.
          path.head = contour_path_element_t( 'u', 'on', vi, vj+1, PATH_EASTWARD )
        else
          path.head = contour_path_element_t( 'v', 'on', vi, vj-1, PATH_SOUTHWARD )
        end if
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_MP )
        !!>
                   *       |
                   *       |
                   p - - - + -
                   *       .
                   *       .
                   .       .
                   m - - - + -
                   |       .
                   |       .
        !!<
        jumped = .true.
        u = vert.pos_u(vi)
        v = edge.v_cross_coord(vi,vj)
        call register( path, u, v )
        call mesh_edge.erase( 'v', vi, vj-1 )
        path.head = contour_path_element_t( 'v', 'in', vi, vj, PATH_EASTWARD )
      case default
        call fatal( '__MODFUNC__: Strange. Could not find path.' )
    end select

  end subroutine go_along_boundary_on_v_edge_south


  subroutine go_along_boundary_on_u_edge_west( path,  &
                                               vert,  &
                                               edge )
    type(contour_path_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j

    call ut__assert( path.head.lane == 'on',  &
                     "__MODFUNC__: The path should be on border." )

    call ut__assert( path.head.direct == PATH_WESTWARD,  &
                     "__MODFUNC__: Wrong call." )

    vi = path.head.i
    vj = path.head.j

    select case ( edge.u_quarter(vi-1,vj) )
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_PP) 
        !!>
                        __ You will go this way.
                       /
                      /      You came along this edge.
                     /       /        
            - - p - - - p * * *             
                .\      .\           
                . \     . \__ Current head of vertex-type (vi,vj)
                .  \    .
                + - - - +
                .    \  . 
                .     New head of vertex-type
        !!<
        jumped = .true.
        u = vert.pos_u(vi-1)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call mesh_edge.erase( 'u', vi-1, vj )
        if ( vi-1 == 1 ) then ! you have reached the north-west corner.
          !!>                
                              __ new head of vertex-type (vi-1,vj)
                             / 
                            p * * * p * * 
            you will        *       .
             go this way => *       .
                            .       .
                            + - - - + - -
                            .       .
          !!<
          path.head = contour_path_element_t( 'v', 'on', vi-1, vj, PATH_SOUTHWARD )
        else
          !!>
                         __ new head of vertex type (vi-1,vj)
                        /
                       /  ___ you will go this way
                      /  /
                     /  /      
                  - p * * * p * * You came along this border.
                    .       .     
                    .       .     
                    .       .     
                  - + - - - + - - 
                    .       .     
          !!<
          path.head = contour_path_element_t( 'u', 'on', vi-1, vj, PATH_WESTWARD )
        end if
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_MP )
        !!>
                           __ new head of edge type (vi-1,vj)
                          /
                         /      
                  - m - * * p * * You came along this border.
                    .  *    .     
                    . *<== You will go this way.
                    .       .     
                  - + - - - + - - 
                    .       .     
        !!<
        jumped = .true.
        u = edge.u_cross_coord(vi-1,vj)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call mesh_edge.erase( 'u', vi-1, vj )
        path.head = contour_path_element_t( 'u', 'in', vi-1, vj, PATH_SOUTHWARD )
      case default
        call fatal( '__MODFUNC__: Strange. Could not find path.' )
    end select

  end subroutine go_along_boundary_on_u_edge_west


  subroutine go_along_boundary_on_u_edge_east( path,  &
                                               vert,  &
                                               edge )
    type(contour_path_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j

    call ut__assert( path.head.lane == 'on',  &
                     "__MODFUNC__: The path should be on border." )

    call ut__assert( path.head.direct == PATH_EASTWARD,  &
                     "__MODFUNC__: Wrong call." )

    vi = path.head.i
    vj = path.head.j

    select case ( edge.u_quarter(vi,vj) )
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_PP) 
        jumped = .true.
        u = vert.pos_u(vi)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call mesh_edge.erase( 'u', vi, vj )
        if ( vi+1 == edge.u_nu ) then ! you have reached the south-east corner.
          path.head = contour_path_element_t( 'v', 'on', vi+1, vj, PATH_NORTHWARD )
        else
          path.head = contour_path_element_t( 'u', 'on', vi+1, vj, PATH_EASTWARD )
        end if
      case (SLICE_MESH__EDGE_LEVEL_QUARTER_PM )
        jumped = .true.
        u = edge.u_cross_coord(vi,vj)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call mesh_edge.erase( 'u', vi, vj )
        path.head = contour_path_element_t( 'u', 'in', vi, vj, PATH_NORTHWARD )
      case default
        call fatal( '__MODFUNC__: Strange. Could not find path.' )
    end select

  end subroutine go_along_boundary_on_u_edge_east


  subroutine go_along_boundary( path, edge )
    type(contour_path_t) <io> :: path
    type(slice_mesh__edge_t) <in> :: edge

    call ut__assert( path.head.lane == 'on',  &
                     "__MODFUNC__: The path should be on border." )

    select case (path.head.direct)
      case (PATH_NORTHWARD)
        call go_along_boundary_on_v_edge_north( path, edge )
      case (PATH_SOUTHWARD)
        call go_along_boundary_on_v_edge_south( path, edge )
      case (PATH_WESTWARD)
        call go_along_boundary_on_u_edge_west( path, edge )
      case (PATH_EASTWARD)
        call go_along_boundary_on_u_edge_east( path, edge )
      case default
        call ut__assert( "__MODFUNC__: case error." )
    end select
  end subroutine go_along_boundary


  subroutine jump_to_other_edge( path,  &
                                 vert,  &
                                 edge )
    char(len=*) <in> :: which_way
    type(contour_path_t) <in> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    logical :: jumped

    call ut__assert( path.head.lane == 'in',  &
                     "__MODFUNC__: The path should be in the region." )

    jumped = .false.  ! Default.

    ei = path.head.i
    ej = path.head.j

    select case (path.head.direct)
      !!>
                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)
      !!<
      case (PATH_NORTHWARD)
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODFUNC__: Must be edge-u here." )
        call jump_to_v_edge_mp_if_possible( path, edge, jumped, 
                                            ei+1, ej)
                         !!>
                              p - - p
                              |    *|To
                              |   * |
                              p -*- m
                                From 
                         !!<
        call jump_to_u_edge_pm_if_possible( path, edge, jumped, 
                                            ei, ej+1 )
                         !!>
                                To
                              p -*- m
                              |  *  |
                              |  *  |
                              p -*- m
                                From 
                         !!<
        call jump_to_v_edge_pm_if_possible( path, edge, jumped, 
                                            ei, ej )
                         !!>
                              m - - m
                            To*     |
                              | *   |
                              p - * m
                                From 
                         !!<
        if ( jumped ) call mesh_edge.erase( 'u', ei, ej )
      case (PATH_WESTWARD)
        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODFUNC__: Must be edge-v here." )
        call jump_to_u_edge_pm_if_possible( path, edge, jumped, 
                                            ei-1, ej+1 )
                         !!>
                                To
                              p -*- m
                              |   * |
                              |    *|From
                              p - - p
                         !!<
        call jump_to_v_edge_pm_if_possible( path, edge, jumped, 
                                            ei-1, ej )
                         !!>
                              m - - m
                              |     |
                            To|* * *|From
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, edge, jumped, 
                                            ei-1, ej )
                         !!>
                              m - - m
                              |    *|
                              |   * |From
                              m -*- p
                                To
                         !!<
        if ( jumped ) call mesh_edge.erase( 'v', ei, ej )
      case (PATH_SOUTHWARD)
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODFUNC__: Must be edge-u here." )
        call jump_to_v_edge_pm_if_possible( path, edge, jumped, 
                                            ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              | *   |
                           To |*    |
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, edge, jumped, 
                                            ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              |  *  |
                              |  *  |
                              m -*- p
                                 To
                         !!<
        call jump_to_v_edge_mp_if_possible( path, edge, jumped, 
                                            ei+1, ej-1 )
                         !!>
                                From
                              m -*- p
                              |   * |
                              |    *|To
                              m - - m
                         !!<
        if ( jumped ) call mesh_edge.erase( 'u', ei, ej )
      case (PATH_EASTWARD)
        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODFUNC__: Must be edge-v here." )
        call jump_to_u_edge_mp_if_possible( path, edge, jumped, 
                                            ei, ej )
                         !!>
                              p - - p
                         From *     |
                              |*    |
                              m * - p
                                To
                         !!<
        call jump_to_v_edge_mp_if_possible ( path, edge, jumped, 
                                             ei+1, ej )
                         !!>
                              p - - p
                         From * * * * To
                              |     |
                              m - - m
                         !!<
        call jump_to_u_edge_pm_if_possible( path, edge, jumped, 
                                            ei, ej+1 )
                         !!>
                                To
                              p * - m
                              |*    |
                         From *     |
                              m - - m
                         !!<
        if ( jumped ) call mesh_edge.erase( 'v', ei, ej )
      case default
        call ut__fatal( '__MODFUNC__: case error.' )
    end select

    call ut__assert( jumped,  &
                     "__MODFUNC__: Failed to find next path." )
  end subroutine jump_to_other_edge


  function contour_path__is_closed( this ) result(ans)
    class(contour_path_t) <in> :: this

    logical :: con1, con2, con3

    con1 = ( this.head.which_edge == this.start.which_edge )
    con2 = ( this.head.i == this.start.i )
    con3 = ( this.head.j == this.start.j )
    ans = ( con1 .and. con2 .and. con3 )
  end function contour_path__is_closed  


  subroutine contour_path__reset( this )
    class(contour_path_t) <io> :: this
    this.num = 0
    this.list_u(:) = 0.0
    this.list_v(:) = 0.0
  end subroutine contour_path__reset


  subroutine contour_path__initialize( this, vert_nu, vert_nv )
    class(contour_path_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv

    allocate(this.list_u(max_path_element_num))
    allocate(this.list_v(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call contour_path__reset( this )
  end subroutine contour_path__initialize


  subroutine set_starting_edge_on_boundaries( path,         &
                                              mesh_vert,    &
                                              mesh_edge,    &
                                              status )
    type(contour_path_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'

    ! To shorten.
    integer <const> :: MM = SLICE_MESH__EDGE_LEVEL_QUARTER_MM
    integer <const> :: PP = SLICE_MESH__EDGE_LEVEL_QUARTER_PP
    integer <const> :: MP = SLICE_MESH__EDGE_LEVEL_QUARTER_MP
    integer <const> :: PM = SLICE_MESH__EDGE_LEVEL_QUARTER_PM

    integer <const> :: NORTHWARD = PATH_NORTHWARD
    integer <const> :: WESTWARD  = PATH_WESTWARD 
    integer <const> :: SOUTHWARD = PATH_SOUTHWARD
    integer <const> :: EASTWARD  = PATH_EASTWARD 

    !!>
         |       |       |    _ Contour line       
         m - - - m - - - m   /    at "level"
         |       |       * */             
         |       |    *  |   *   |       |       |      
         m - - - m -*- - p - - * m - - - m - - - m   ej=3
         |       *       |       *       |       |
         |     * |       |       | *     |       |
         m - -*- p - - - p - - - p - * - m - - - m   ej=2
         |    *  |       |       |    *  |       |
         |    *  |       |       |    *  |       |
         m - - * p * * * p * * * p * * - m - - - m   ej=1
    !!<    

    integer :: ei, ej
    real :: pos_u, pos_v

    call ut__assert( path.num == 0,  &
                    '__MODFUNC__: You forgot to reset contour_path.' )

    ! South boundary
    ej = 1
    do ei = 1, mesh_edge.u_nu
      quarter = mesh_edge.u_quarter(ei,ej)
      if ( quarter == PM  .or.  &
           quarter == MP  .or.  &
           quarter == PP ) then
        status = 'have found'
        path.start = contour_path_element_t( 'u', 'on', ei, ej, BORDER_EASTWARD )
        !!>           
            [case PM]
                        |      *|     
                      - p - - * m -   
                        |    *  |     
                        |   *   |     
                        |  *    |     
                    * * p * ====m===  ej=1 (bottom)
                       /   \
            1st register    \
                             2nd register

            [case MP]
                        |*      |     
                      - m * - - p - - 
                        |  *    |     
                        |   *   |     
                        |    *  |     
                    ====m==== * p * *   ej=1 (bottom)
                             /   \
                  1st register    \
                                   2nd register

            [case PP]
                |*      |       |             
                *       |       |             
                p - - - p - - - p -           
                *       |       |             
                *       |       |             
                *       |       |             
                p * * * p * * * p * * ej=1 (bottom)   
        !!<
        select case (quarter)
          case (PM)
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_edge.u_cross_coord(ei,ej)
          case (MP)
            u1 = mesh_edge.u_cross_coord(ei,ej)
            u2 = mesh_vert.pos_u(ei+1)
          case (PP)
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_vert.pos_u(ei+1)
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select

        v1 = mesh_vert.pos_v(ej)
        call register( path, u1, v1 )
        call register( path, u2, v1 )
        call mesh_edge.erase( 'u', ei, ej )

        select case (quarter)
          case (PM)
            path.head = contour_path_element_t( 'u', 'in', ei, ej, PATH_NORTHWARD )
          case (MP,PP)
            if ( ei < mesh_edge.u_nu ) then
              path.head = contour_path_element_t( 'u', 'on', ei+1, ej, PATH_EASTWARD )
            else 
              ! you are on the south-east corner. turn north.
              path.head = contour_path_element_t( 'v', 'on', ei+1, ej, PATH_NORTHWARD )
            end if
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select
        return
      end if
    end do

    ! East boundary
    !!>  
      [case MP]         
               .         *     
             - p - - - - p <-- 2nd register
               .         *
               .         * <-- 1st register
               .        *|     
               .       * |     
               .      *  |     
           * * p - - * - m
               .     *   |
                 
      [case PM]         
               .         |
             . p . . .*. m 
               .       * |     
               .        *|     
               .         *  <== 2nd register   
               .         *
             . p . . . . p  <== 1st register
               .         *
      
      [case PP]         
               .         *            
             - p - - - - p  <== 2nd register          
               .         *             
               .         *             
               .         *             
             - p - - - - p  <== 1st register
               .         *
    !!<
    ei = mesh_edge.v_nu
    do ej = 1, mesh_edge.v_nv
      quarter = mesh_edge.v_quarter(ei,ej)
      if ( quarter == PM  .or.  &
           quarter == MP  .or.  &
           quarter == PP ) then
        status = 'have found'
        path.start = contour_path_element_t( 'v', 'on', ei, ej, PATH_NORTHWARD )
        select case (quarter)
          case (PM)
            v1 = mesh_vert.pos_u(ej)
            v2 = mesh_edge.v_cross_coord(ei,ej)
          case (MP)
            v1 = mesh_edge.v_cross_coord(ei,ej)
            v2 = mesh_vert.pos_v(ej+1)
          case (PP)
            v1 = mesh_vert.pos_v(ej)
            v2 = mesh_vert.pos_v(ej+1)
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select

        u1 = mesh_vert.pos_u(ei)
        call register( path, u1, v1 )
        call register( path, u1, v2 )
        call mesh_edge.erase( 'v', ei, ej )

        select case (quarter)
          case (PM)
            path.head = contour_path_element_t( 'v', 'in', ei, ej, PATH_WESTWARD )
          case (MP,PP)
            if ( ej < mesh_edge.v_nv ) then
              path.head = contour_path_element_t( 'v', 'on', ei, ej+1, PATH_NORTHWARD )
            else 
              ! you are on the north-east corner. turn west.
              path.head = contour_path_element_t( 'u', 'on', ei-1, ej, PATH_WESTWARD )
            end if
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select
        return
      end if
    end do  

    ! North boundary
    ej = mesh_edge.v_nv
    do ei = mesh_edge.u_nu, 1, -1
      quarter = mesh_edge.u_quarter(ei,ej)
      if ( quarter == PM  .or.  &
           quarter == MP  .or.  &
           quarter == PP ) then
        status = 'have found'
        path.start = contour_path_element_t( 'u', 'on', ei, ej, PATH_WESTWARD )

        select case (quarter)
          case (PM)
            !   2nd register     1st register
            !             \     /
            !          * * p * * - - m - 
            u1 = mesh_edge.u_cross_coord(ei,ej)
            u2 = mesh_vert.pos_u(ei)
          case (MP)
            !       2nd register       1st register
            !                 \       /
            !          - - m - * * * p *
            u1 = mesh_vert.pos_u(ei+1)
            u2 = mesh_edge.u_cross_coord(ei,ej)
          case (PP)
            !   2nd register           1st register
            !             \           /
            !          * * p * * * * p *
            u1 = mesh_vert.pos_u(ei+1)
            u2 = mesh_vert.pos_u(ei)
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select

        v1 = mesh_vert.pos_v(ej)
        call register( path, u1, v1 )
        call register( path, u2, v1 )
        call mesh_edge.erase( 'u', ei, ej )

        select case (quarter)
          case (MP)
            path.head = contour_path_element_t( 'u', 'in', ei, ej, PATH_SOUTHWARD )
          case (PM,PP)
            if ( ei > 1 ) then
              path.head = contour_path_element_t( 'u', 'on', ei-1, ej, PATH_WESTWARD )
            else 
              ! you are on the north-west corner. turn south.
              path.head = contour_path_element_t( 'v', 'on', 1, ej-1, PATH_SOUTHWARD )
            end if
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select
        return
      end if
    end do


    ! West boundary
    ei = 1
    do ej = mesh_edge.v_nv, 1, -1
      quarter = mesh_edge.v_quarter(ei,ej)
      if ( quarter == PM  .or.  &
           quarter == MP  .or.  &
           quarter == PP ) then
        status = 'have found'
        path.start = contour_path_element_t( 'v', 'on', ei, ej, PATH_SOUTHWARD )
        select case (quarter)
          case (MP)
            v1 = mesh_vert.pos_u(ej+1)
            v2 = mesh_edge.v_cross_coord(ei,ej)
          case (PM)
            v1 = mesh_edge.v_cross_coord(ei,ej)
            v2 = mesh_vert.pos_v(ej)
          case (PP)
            v1 = mesh_vert.pos_v(ej+1)
            v2 = mesh_vert.pos_v(ej)
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select

        u1 = mesh_vert.pos_u(ei)
        call register( path, u1, v1 )
        call register( path, u1, v2 )
        call mesh_edge.erase( 'v', ei, ej )

        select case (quarter)
          case (MP)
            path.head = contour_path_element_t( 'v', 'in', ei, ej, PATH_EASTWARD )
          case (PM,PP)
            if ( ej > 1 ) then
              path.head = contour_path_element_t( 'v', 'on', ei, ej-1, PATH_SOUTHWARD )
            else 
              ! you are on the south-west corner. turn east.
              path.head = contour_path_element_t( 'u', 'on', ei, ej, PATH_EASTWARD )
            end if
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select
        return
      end if
    end do  

  end subroutine set_starting_edge_on_boundaries


  subroutine set_starting_edge_in_bulk( path,         &
                                        mesh_vert,    &
                                        mesh_edge,    &
                                        status )  
    type(contour_path_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'

    ! To shorten.
    integer <const> :: MM = SLICE_MESH__EDGE_LEVEL_QUARTER_MM
    integer <const> :: PP = SLICE_MESH__EDGE_LEVEL_QUARTER_PP
    integer <const> :: MP = SLICE_MESH__EDGE_LEVEL_QUARTER_MP
    integer <const> :: PM = SLICE_MESH__EDGE_LEVEL_QUARTER_PM

    !!>
          Tring to find a path that goes through an u-edge with "PM".

         | .    |       .
         |  .   |     . |
         |   .  |   .   |
       --m----.-p=.=====m--
         |      .   \_____ Find this edge.
    !!< 
    integer :: ei, ej
    integer :: quarter
    real :: path_tip_u, path_tip_v

    call ut__assert( path.num == 0,  &
                    '__MODFUNC__: You forgot to reset contour_path.' )
    !!> 
        Find a starting edge of a contour line for the input level.
        Mathematically, every contour line is closed unless it touches 
        on the boundary of the simulatin box (u=umin/umax or v=vmin/vmax).

        We set a virtual contour line along the boundary if the boudary grid
        vertices satisfy the condition 
            vert_val >= level  (denoted by "p" in the figure),
        see the upper right figure. 

        Since all contour lines are thus always closed, we first find an
        edge (starting edge) for each contour and draw the contour with
        keeping grid vertices with 
            vert_val >= level
        always in its left-hand side of the path.
        
        Starting edge of a trully closed contour (without touching the
        boundaries) is any u_edge with its quarter value "PM" (plus-in-left
        and minus-in-right of the edge).

        Cares should be taken for contour lines with virual (on-boundary)
        contours. 
                            contour line
      [Case A]                *                 
             ei     ei+1    *           [Case B]                ei=1
             |       |    *                               *   (right boundary)
         - - p - - - p -*-                |       |     * |       *
             |       |*                   |       |   *   |       *
             |      *|                  - m - - - m -*- - p - - - p
             |    *  |                    |       |  *    |       *
      ej - - p==*====m - -                |       |  *    |       *
             | *  \  |                    |       |  *    |       *
             |*   PM |                  - m - - - m -*- - p - - - p
             *      \                     |       | *     |       *
                     \                    |       |*      |       *
                   start edge             |      *|       |       *  ej=1    
                                        --m----***p*******p*******p (bottom
      [Case C]                             \     / \     / \     /   boundary) 
       ei=1 (left boundary)                   MP      PP      PP
        |     * |       |                              \
        |   *   |       |                               start edge
        m -*- - p - - - p -          [Case D]    
        | *     |       |                 |       |      *|       |
        |*      |       |             - - p - - - p - - * m - - - m - -
        *       |       |                 |       |    *  |       |
        p - - - p - - - p -               |       |   *   |       |
        *       |       |                 |       |  *    |       |   ej=1
        *       |       |              ***p*******p** - - m - - - m - (bottom
        *       |       |                  \     / \     / \     /     boundary)
        p*******p*******p*** ej=1             PP      PM      MM
         \     / \     /    (bottom                    \
            BB      BB       boundary)                  start edge
             \
              start edge
    !!< 

    do ej = 2, mesh_edge.u_nv-1
      do ei = 2, mesh_edge.u_nu-1
        quarter = mesh_edge.u_quarter(ei,ej)
        if ( quarter == PM ) then
          ! Found a cell that inlcude at least one contour path.
          ! [Case A] and [Case D] in above figure.
          !!> 
              path tip you
              have just found.  *
                        |    \ *      |
                      --p=====*-------m--
                        |    *        |
             contour ---|-->*         |
                        |  *          |
                        | *           |
          !!<
          status = 'have found'
          path.start = contour_path_element_t( 'u', 'in', ei, ej, NORTHWARD )
          u = mesh_edge.u_cross_coord(ei,ej)
          v = mesh_vert.pos_v(ej)
          call register( path, u, v )
          call mesh_edge.erase( 'u', ei, ej )
          path.head = contour_path_element_t( 'u', 'in', ei, ej, NORTHWARD )
        end if
      end do
    end do

  end subroutine set_starting_edge_in_bulk


  subroutine contour_path__set_starting_edge( this,         &
                                              mesh_vert,    &
                                              mesh_edge,    &
                                              status )
    class(contour_path_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <out> :: status ! 'no contour' or 'have found'

    status = 'no contour'  ! default 

    call set_starting_edge_on_boundaries( this,         &
                                          mesh_vert,    &
                                          mesh_edge,    &
                                          status )
    if ( status == 'have found' ) return

    call set_starting_edge_in_bulk( this,         &
                                    mesh_vert,    &
                                    mesh_edge,    &
                                    status )

  end subroutine contour_path__set_starting_edge


  subroutine contour_path__trace_and_erase( this,  &
                                            vert,  &
                                            edge )
    class(contour_path_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    do
      select case (this.head.lane)
        case ('on')
          call go_along_boundary( this, vert, edge )
        case ('in')
          call jump_to_other_edge( this, vert, edge )
        case default
          call ut__assert( "__MODFUNC__: case error." )
      end select
      if ( this.is_closed ) return
    end do

  end subroutine contour_path__trace_and_erase

end module contour_path_m
