module contour_path_m
  use ut_m
  use slice_mesh_m
  implicit none
  !!>
        P: positive edge: eastward for edgex and
                          northward for edgey
        M: negative edge: westward for edgex and
                          southward for edgey 
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
  !!<

  type contour_path_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    integer, dimension(:), allocatable :: list_i, list_j
  contains
    procedure :: initialize => contour_path__initialize
    procedure :: reset => contour_path__reset
    procedure :: trace_and_erase  &
                       => contour_path__trace_and_erase
    procedure, pass :: set_starting_edge &
                       => contour_path__set_starting_edge
  end type contour_path_t


contains


  function returned_to_start_point( i_start, j_start,  &
                                    i_now, j_now ) result(ans)
    integer <in> :: i_start, j_start
    integer <in> :: i_now, j_now
    logical :: ans
    ans = ( i_start == i_now  .and.  &
            j_start == j_now )
  end function returned_to_start_point

 
  subroutine turn_left( path,            &
                        edge,            &
                        direct_now,      &
                        i_now,           &
                        j_now,           &
                        moved_one_step,  &
                        path_is_closed )
    type(contour_path_t) <in> :: path
    type(slice_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default

    select case (direct_now)
      case ('E')
        !!>
               ^        
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn left (northward) or not.
        !!<
        if ( j_now == path.vert_nv ) return
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          edge.u_ternary(i_now-1,j_now) = 0   ! Erase the trace
          j_now += 1                          ! Move the head point
          direct_now = 'N'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now-1) = 0 ! Erase the last edge.
          end if
        end if
      case ('N')
        !!>
              | 
          <-- + --
              ^
              | 
              N
        !!<
        if ( i_now == 1 ) return
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          edge.v_ternary(i_now,j_now-1) = 0  ! Erase the trace
          i_now -= 1                         ! Move the head point
          direct_now = 'W'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now,j_now) = 0 ! Erase the last edge.
          end if
        end if
      case ('W')
        !!>
              | 
           -- + <---W
              |  
              v
        !!<
        if ( j_now == 1 ) return
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          edge.u_ternary(i_now,j_now) = 0     ! Erase the trace
          j_now -= 1                          ! Move the head point
          direct_now = 'S'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now+1) = 0 ! Erase the last edge.
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
           -- + -->
              |
        !!<
        if ( i_now == path.vert_nu ) return
        if ( edge.u_ternary(i_now,j_now) == +1 ) then
          edge.v_ternary(i_now,j_now) = 0     ! Erase the trace
          i_now += 1                          ! Move the head point
          direct_now = 'E'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now-1,j_now) = 0 ! Erase the last edge.
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine turn_left

 
  subroutine turn_right( path,            &
                         edge,            &
                         direct_now,      &
                         i_now,           &
                         j_now,           &
                         moved_one_step,  &
                         path_is_closed )
    type(contour_path_t) <in> :: path
    type(slice_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn right (southward) or not.
               v
        !!<
        if ( j_now == 1 ) return
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          edge.u_ternary(i_now-1,j_now) = 0  ! Erase the trace
          j_now -= 1                         ! Move the head point
          direct_now = 'S'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now) = 0  ! Erase the last edge.
          end if
        end if
      case ('N')
        !!>
              | 
           -- + -->
              ^
              | 
              N
        !!<
        if ( i_now == path.vert_nu ) return
        if ( edge.u_ternary(i_now,j_now) == +1 ) then
          edge.v_ternary(i_now,j_now-1) = 0    ! Erase the trace
          i_now += 1                           ! Move the head point
          direct_now = 'E'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now-1,j_now) = 0  ! Erase the last edge.
          end if
        end if
      case ('W')
        !!>
              ^
              | 
           -- + <---W
              |  
        !!<
        if ( j_now == path.vert_nv ) return
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          edge.u_ternary(i_now,j_now) = 0      ! Erase the trace
          j_now += 1                           ! Move the head point
          direct_now = 'S'                     ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now-1) = 0  ! Erase the last edge.
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
          <-- + -- 
              |
        !!<
        if ( i_now == 1 ) return
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          edge.v_ternary(i_now,j_now) = 0    ! Erase the trace
          i_now -= 1                         ! Move the head point
          direct_now = 'W'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now,j_now) = 0  ! Erase the last edge.
          end if
        end if
      case default
        call ut__fatal( '__MODFUNC__: Wrong direct case.' )
    end select

  end subroutine turn_right  

 
  subroutine go_forward( path,            &
                         edge,            &
                         direct_now,      &
                         i_now,           &
                         j_now,           &
                         moved_one_step,  &
                         path_is_closed )
    type(contour_path_t) <in> :: path
    type(slice_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default

    !!>
        This routine is called after "turn_left" or
        "turn_right". So, we should be able to go 
        forward, as long as the path is closed.
    !!<

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + -->  at '+' point, and moving eastward.
               |      Checking if you can go straight or not.

        !!<
        call ut__assert( i_now /= path.vert_nu,       &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the right wall.' )
        if ( edge.u_ternary(i_now,j_now) == +1 ) then 
          edge.u_ternary(i_now-1,j_now) = 0   ! Erase the trace
          i_now += 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now-1,j_now) = 0 ! Erase the last edge.
          end if
          return
        end if
      case ('N')
        !!>
               ^
               | 
            -- + --
               ^
               | 
               N
        !!<
        call ut__assert( j_now /= path.vert_nv,       &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the top wall.' )
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          edge.v_ternary(i_now,j_now-1) = 0  ! Erase the trace
          j_now += 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now-1) = 0 ! Erase the last edge.
          end if
          return
        end if
      case ('W')
        !!>
                | 
            <-- + <---W
                |  
        !!<
        call ut__assert( i_now /= 1,                  &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the left wall.' )
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          edge.u_ternary(i_now,j_now) = 0   ! Erase the trace
          i_now -= 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now,j_now) = 0 ! Erase the last edge.
          end if
          return
        end if
      case ('S')
        !!>
                S
                | 
                v
             -- + -- 
                |
                v
        !!<
        call ut__assert( j_now /= 1,                  &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the bottom wall.' )
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          edge.v_ternary(i_now,j_now) = 0   ! Erase the trace
          j_now -= 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now) = 0 ! Erase the last edge.
          end if
          return
        end if
      case default
        call ut__fatal( '__MODFUNC__: Wrong direct case.' )
    end select

    call ut__fatal( '__MODFUNC__: Failed to go forward.' )

  end subroutine go_forward


  subroutine contour_path__reset( this )
    class(contour_path_t) <io> :: this
    this.num = 0
    this.list_i(:) = 0
    this.list_j(:) = 0
  end subroutine contour_path__reset


  subroutine contour_path__initialize( this, vert_nu, vert_nv )
    class(contour_path_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv

    allocate(this.list_i(max_path_element_num))
    allocate(this.list_j(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call contour_path__reset( this )
  end subroutine contour_path__initialize


  subroutine contour_path__set_starting_edge( this,         &
                                              mesh_edge,    &
                                              direct_now,   &
                                              status,       &
                                              i_now, j_now )
    class(contour_path_t) <io> :: this
    type(slice_mesh_edge_t) <io> :: mesh_edge
    char(len=1) <in> :: direct_now
    char(len=10) <out> :: status ! 'no contour' or 'have found'
    integer <out> :: i_now, j_now
    !!>
          Tring to find an eastward arrow AB.
              +---+---+---+
              |           |
              +---+       +
                  |       |
                  A==>B---+
    !!< 
    integer :: start_i, start_j, ei, ej

    call ut__assert( direct_now=='E',  &
                    '__MODFUNC__: We assume start edge is E(astward).' )
    call ut__assert( this.num == 0,  &
                    '__MODFUNC__: Forgot resetting contour_path.' )

    do ej = 1, mesh_edge.u_nv
      do ei = 1, mesh_edge.u_nu
        if ( mesh_edge.u_ternary(ei,ej) == +1 ) then
          ! Found a boundary curve of 'E(astward)' direction.
          start_i = ei ! Vertex indexes of an left-end of
          start_j = ej ! an edge is the same as the edge indexes.
          call register( this, start_i, start_j )
          i_now = start_i + 1
          j_now = start_j
          call register( this, i_now, j_now )
          mesh_edge.u_ternary(start_i,start_j) = 0  ! Erase the edge
          status = 'have found'
          return
        end if
      end do
    end do 
    status = 'no contour'
    call ut__fatal( 'Cound not find a start edge.' )
  end subroutine contour_path__set_starting_edge    


  subroutine register( contour_path, i, j )
    type(contour_path_t) <io> :: contour_path
    integer <in> :: i, j

    integer :: n
    n = contour_path.num + 1
    call ut__assert( n <= size(contour_path.list_i,dim=1),  &
                    '__MODFUNC__: Increase array size of path_vert.' )
    contour_path.list_i(n) = i
    contour_path.list_j(n) = j
    contour_path.num = n
  end subroutine register


  subroutine contour_path__trace_and_erase( this,       &
                                            mesh_edge,  &
                                            direct_now, &
                                            i_now,      &
                                            j_now )
    class(contour_path_t) <io> :: this
    type(slice_mesh_edge_t) <io> :: mesh_edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now

    logical :: moved_one_step, path_is_closed
!debug s
integer :: i, j
do j=1, mesh_edge.u_nv
do i=1, mesh_edge.u_nu
if ( mesh_edge.u_ternary(i,j) /= 0 ) then
!debugp i, j, mesh_edge.u_ternary(i,j)
end if
end do
end do
do j=1, mesh_edge.v_nv
do i=1, mesh_edge.v_nu
if ( mesh_edge.v_ternary(i,j) /= 0 ) then
!debugp i, j, mesh_edge.v_ternary(i,j)
end if
end do
end do
! debug e

    do 
!debugp 'do loop.'    
!debugp direct_now
      !
      call turn_left( this,            &
                      mesh_edge,       &
                      direct_now,      &
                      i_now,           &
                      j_now,           &
                      moved_one_step,  &
                      path_is_closed )
      if ( moved_one_step ) then
        call register( this, i_now, j_now )
      end if
      if ( path_is_closed ) return

      !
      ! right
      !
      call turn_right( this,            &
                       mesh_edge,       &
                       direct_now,      &
                       i_now,           &
                       j_now,           &
                       moved_one_step,  &
                       path_is_closed )
!debugp 'done turn_right'
      if ( moved_one_step ) then
        call register( this, i_now, j_now )
      end if
      if ( path_is_closed ) return

      !
      ! straight
      !
      call go_forward( this,            &
                       mesh_edge,       &
                       direct_now,      &
                       i_now,           &
                       j_now,           &
                       moved_one_step,  &
                       path_is_closed )
!debugp 'done go forward'
!debugp i_now, j_now, direct_now
      !!>
          We do not need to register the forward-stepped point,
          because the path
                   1---2---3
                           |          
                           4---5---6---7
          is the same as
                   1-------2
                           |          
                           3-----------4
      !!<
      if ( path_is_closed ) then
        call register( this, i_now, j_now )
        return
      end if

    end do

  end subroutine contour_path__trace_and_erase


end module contour_path_m
