module contour_path_m
  use ut_m
  use slice_mesh_m
  implicit none
  private
  !!>
        P: positive edge: eastward for edgex and
                          northward for edgey
        M: negative edge: westward for edgex and
                          southward for edgey 
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+

      To round the corner, we make a 45-degree turn
      at each corner, instead of 90-degree turn.
      In the figure below, we came from left, along the
      bottom line, and have just made a turn to left
      at the corner point "2". And the present vertex
      position (vpos_now) is "1". To draw a "rounded"
      path (...L...L...) with double 45-degree turns.

                        L
                        L
                        1
                      L .\____vpos_now
                    L   .
                  L     .
        L L L L 1 . . . 2
                         \_____vpos_prev
  !!<

  type, public :: contour_path__element_t
    char(len=1) :: which_edge ! 'u' or 'v'
    integer :: edge_i, edge_j
    integer :: direct
  end type contour_path__element_t

  type, public :: contour_path_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    type(contour_path__element_t) :: start
    type(contour_path__element_t) :: next
    real, dimension(:), allocatable :: list_u, list_v
  contains
    procedure :: initialize => contour_path__initialize
    procedure :: reset => contour_path__reset
    procedure :: trace_and_erase  &
                       => contour_path__trace_and_erase
    procedure, pass :: set_starting_edge &
                       => contour_path__set_starting_edge
  end type contour_path_t


contains


  subroutine turn( which_way,       &
                   path,            &
                   edge,            &
                   direct_now,      &
                   vpos_now,        &
                   moved_one_step,  &
                   path_is_closed )
    char(len=*) <in> :: which_way
    type(contour_path_t) <in> :: path
    type(slice_mesh__edge_t) <io> :: edge
    type(slice_mesh_direct_t) <io> :: direct_now 
    type(slice_mesh_ivect_t) <io> :: vpos_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed
    !!>
               ^      When direct_now = 'East' and the current
               |      vertex position (i,j)=(i_now,j_now), which is
          E--> + --   denoted by '+'. If which_way = 'left', you 
               |      are trying to turn left (northward).
    !!<
    type(slice_mesh_direct_t) :: direct_turned

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default.

    call ut__assert( which_way == 'left'    .or.  &
                     which_way == 'right'   .or.  &
                     which_way == 'forward',      &
                    '__MODFUNC__: Bad argument "which_way".' )

    direct_turned = direct_now.turn( which_way )

    if ( edge.can_turn_to( vpos_now, direct_turned ) ) then
      call edge.erase( vpos_now, direct_turned.d )
      vpos_now = vpos_now.shift( direct_turned.d )
      direct_now = direct_turned
      moved_one_step = .true.
      path_is_closed = returned_to_start_point( path.vpos_start, vpos_now )
    end if
  end subroutine turn


  function returned_to_start_point( vpos_start, vpos_now ) result(ans)
    type(slice_mesh_ivect_t) <in> :: vpos_start, vpos_now
    logical :: ans
    ans = ( vpos_start.i == vpos_now.i  .and.  &
            vpos_start.j == vpos_now.j )
  end function returned_to_start_point  


  subroutine contour_path__reset( this )
    class(contour_path_t) <io> :: this
    this.num = 0
    this.list_u(:) = 0.0
    this.list_v(:) = 0.0
  end subroutine contour_path__reset


  subroutine contour_path__initialize( this, vert_nu, vert_nv )
    class(contour_path_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv

    allocate(this.list_u(max_path_element_num))
    allocate(this.list_v(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call contour_path__reset( this )
  end subroutine contour_path__initialize



  subroutine set_starting_edge_on_boundaries( this,         &
                                              mesh_vert,    &
                                              mesh_edge,    &
                                              status )
    type(contour_path_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <out> :: status ! 'no contour' or 'have found'

    ! To shorten.
    integer <const> :: MM = SLICE_MESH__EDGE_LEVEL_QUARTER_MM
    integer <const> :: PP = SLICE_MESH__EDGE_LEVEL_QUARTER_PP
    integer <const> :: MP = SLICE_MESH__EDGE_LEVEL_QUARTER_MP
    integer <const> :: PM = SLICE_MESH__EDGE_LEVEL_QUARTER_PM
    integer <const> :: NORTHWARD = SLICE_MESH__PATH_NORTHWARD
    integer <const> :: WESTWARD  = SLICE_MESH__PATH_WESTWARD 
    integer <const> :: SOUTHWARD = SLICE_MESH__PATH_SOUTHWARD
    integer <const> :: EASTWARD  = SLICE_MESH__PATH_EASTWARD 
    integer <const> :: ON_BORDER = SLICE_MESH__PATH_ON_BORDER

    !!>
         |       |       |    _ Contour line       
         m - - - m - - - m   /    at "level"
         |       |       * */             
         |       |    *  |   *   |       |       |      
         m - - - m -*- - p - - * m - - - m - - - m   ej=3
         |       *       |       *       |       |
         |     * |       |       | *     |       |
         m - -*- p - - - p - - - p - * - m - - - m   ej=2
         |    *  |       |       |    *  |       |
         |    *  |       |       |    *  |       |
         m - - * p * * * p * * * p * * - m - - - m   ej=1
    !!<    

    integer :: ei, ej
    real :: pos_u, pos_v

    status = 'no contour'  ! default 

    ! South boundary
    ej = 1
    do ei = 1, mesh_edge.u_nu
      quarter = mesh_edge.u_quarter(ei,ej)
      if ( quarter == PM  .or.  &
           quarter == MP  .or.  &
           quarter == PP ) then
        status = 'have found'
        this.start = contour_path_element_t( 'u', ei, ej, ON_BORDER )
        call mesh_edge.erase( which, slice_mesh_ivect_t(ei,ej) )
        !!>           
            [case PM]
                        |      *|     
                      - p - - * m -   
                        |    *  |     
                        |   *   |     
                        |  *    |     
                    * * p * ====m===  ej=1 (bottom)
                       /   \
            1st register    \
                             2nd register

            [case MP]
                        |*      |     
                      - m * - - p - - 
                        |  *    |     
                        |   *   |     
                        |    *  |     
                    ====m==== * p * *   ej=1 (bottom)
                             /   \
                  1st register    \
                                   2nd register

            [case PP]
                |*      |       |             
                *       |       |             
                p - - - p - - - p -           
                *       |       |             
                *       |       |             
                *       |       |             
                p * * * p * * * p * * ej=1 (bottom)   
        !!<
        select case (quarter)
          case (PM)
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_edge.u_cross_coord(ei,ej)
          case (MP)
            u1 = mesh_edge.u_cross_coord(ei,ej)
            u2 = mesh_vert.pos_u(ei+1)
          case (PP)
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_vert.pos_u(ei+1)
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select

        v1 = mesh_vert.pos_v(ej)
        call iDouble_register( u1, v1, u2, v1 )

        select case (quarter)
          case (PM)
            this.next = contour_path_element_t( 'u', ei, ej, NORTHWARD )
          case (MP,PP)
            if ( ei < mesh_edge.u_nu ) then
              this.next = contour_path_element_t( 'u', ei+1, ej, ON_BORDER )
            else 
              ! you are on the south-east corner. turn north.
              this.next = contour_path_element_t( 'v', ei+1, ej, ON_BORDER )
            end if
          case default
            call ut__fatal( "__MODFUNC__: case error." )
        end select
        return
      end if
    end do

    ! East boundary
        !!>  
          [case MP]         
                   .         *     
                 - p - - - - p <-- 2nd register
                   .         *
                   .         * <-- 1st register
                   .        *|     
                   .       * |     
                   .      *  |     
               * * p - - * - m
                   .     *   |
                     
          [case PM]         
                   .         |
                 . p . . .*. m 
                   .       * |     
                   .        *|     
                   .         *  <== 2nd register   
                   .         *
                 . p . . . . p  <== 1st register
                   .         *

          [case PP]         
                   .         *            
                 - p - - - - p  <== 2nd register          
                   .         *             
                   .         *             
                   .         *             
                 - p - - - - p  <== 1st register
                   .         *
        !!<
    ei = mesh_edge.u_nu
    do ej = 1, mesh_edge.v_nv
      quarter = mesh_edge.u_quarter(ei,ej)

  
  contains


    subroutine iDouble_register( u1, v1, u2, v2 )
      real <in> :: u1, v1, u2, v2
      call register( this, u1, v1 )
      call register( this, u2, v2 )
    end subroutine iDouble_register

  end subroutine set_starting_edge_on_boundaries


  subroutine contour_path__set_starting_edge( this,         &
                                              mesh_vert,    &
                                              mesh_edge,    &
                                              status,       &
                                              head_cell,    &
                                              head_direct )
    class(contour_path_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <out> :: status ! 'no contour' or 'have found'
    type(slice_mesh_ivect_t) <out> :: head_cell ! path_tip_cell_position
    type(slice_mesh_direct_t) <out> :: path_direct

    call set_starting_edge_on_boundaries( this,         &
                                          mesh_vert,    &
                                          mesh_edge,    &
                                          status,       &
                                          head_cell,    &
                                          head_direct )
    !!>
          Tring to find an eastward arrow AB.

         | .    |       .
         |  .   |     . |
         |   .  |   .   |
       --m----.-p=.=====m--
         |      .   \_____ Find this edge.
    !!< 
    integer :: ei, ej
    integer :: quarter
    real :: path_tip_u, path_tip_v

    call ut__assert( direct_now.d==SLICE_MESH__PATH_NORTHWARD,  &
                    '__MODFUNC__: Path must cross the start edge northtward.' )
    call ut__assert( this.num == 0,  &
                    '__MODFUNC__: You forgot to reset contour_path.' )
    !!> 
        Find a starting edge of a contour line for the input level.
        Mathematically, every contour line is closed unless it touches 
        on the boundary of the simulatin box (u=umin/umax or v=vmin/vmax).

        We set a virtual contour line along the boundary if the boudary grid
        vertices satisfy the condition 
            vert_val >= level  (denoted by "p" in the figure),
        see the upper right figure. 

        Since all contour lines are thus always closed, we first find an
        edge (starting edge) for each contour and draw the contour with
        keeping grid vertices with 
            vert_val >= level
        always in its left-hand side of the path.
        
        Starting edge of a trully closed contour (without touching the
        boundaries) is any u_edge with its quarter value "PM" (plus-in-left
        and minus-in-right of the edge).

        Cares should be taken for contour lines with virual (on-boundary)
        contours. 
                            contour line
      [Case A]                *                 
             ei     ei+1    *           [Case B]                ei=1
             |       |    *                               *   (right boundary)
         - - p - - - p -*-                |       |     * |       *
             |       |*                   |       |   *   |       *
             |      *|                  - m - - - m -*- - p - - - p
             |    *  |                    |       |  *    |       *
      ej - - p==*====m - -                |       |  *    |       *
             | *  \  |                    |       |  *    |       *
             |*   PM |                  - m - - - m -*- - p - - - p
             *      \                     |       | *     |       *
                     \                    |       |*      |       *
                   start edge             |      *|       |       *  ej=1    
                                        --m----***p*******p*******p (bottom
      [Case C]                             \     / \     / \     /   boundary) 
       ei=1 (left boundary)                   MP      PP      PP
        |     * |       |                              \
        |   *   |       |                               start edge
        m -*- - p - - - p -          [Case D]    
        | *     |       |                 |       |      *|       |
        |*      |       |             - - p - - - p - - * m - - - m - -
        *       |       |                 |       |    *  |       |
        p - - - p - - - p -               |       |   *   |       |
        *       |       |                 |       |  *    |       |   ej=1
        *       |       |              ***p*******p** - - m - - - m - (bottom
        *       |       |                  \     / \     / \     /     boundary)
        p*******p*******p*** ej=1             PP      PM      MM
         \     / \     /    (bottom                    \
            BB      BB       boundary)                  start edge
             \
              start edge
    !!< 
    do ej = 1, mesh_edge.u_nv
      do ei = 1, mesh_edge.u_nu
        quarter = mesh_edge.u_quarter(ei,ej)
        if ( quarter == SLICE_MESH__EDGE_LEVEL_QUARTER_PM ) then
          ! Found a cell that inlcude at least one contour path.
          ! [Case A] and [Case D] in above figure.
          !!> 
                  -+-------------+-
                   | Northward   |
                   | head direct |
                   |     .       | <== head_cell to be
                   |     |       |     checked in the next step.
                   |     |       |     
                  -p=====*-------m-
                   |    . \      |
                   |   .   path_tip you have just found.
                   |  .          |   
                   | . \         |
                   |    contour  |
          !!<
          start_edge_u = slice_mesh_ivect_t(ei,ej)
          head_cell = slice_mesh_ivect_t(ei,ej) ! cell's ij = edge's ij
          path_tip_v = mesh_vert.pos_v(ej)
          path_tip_u = mesh_edge.u_cross_coord(ei,ej)
          call register( this, path_tip_u, path_tip_v )
          head_direct = SLICE_MESH__PATH_NORTHWARD
        else if ( quarter == SLICE_MESH__EDGE_LEVEL_QUARTER_BB ) then
          ! [Case B] and [Case C] in above figure.
          !!> 
                                      head_cell
                                       /
                   +------------+------------+
                   |            |            |
                   |            | Eastward   |
                   |          ==|=>  head    |
                   |            |  direct    |
                   |            |            |
                   B============B------------+
                         |           \
             Currently registering   We will find the next virtual
             bottom edge_u           contour on this bottom edge_u.
          !!<
          path_tip_u = mesh_vert.pos_u(ei)    ! left vertex of the edge
          path_tip_v = mesh_vert.pos_v(ej)
          call register( this, path_tip_u, path_tip_v )
          path_tip_u = mesh_vert.pos_u(ei+1)  ! right vertex of the edge
          call register( this, path_tip_u, path_tip_v )

          if ( ei==mesh_edge.u_nu ) then
            !!>
                     .       *     .
                     .       *     .
                 . . p . . . * . . m
                     .         *   .
                     .           * . 
                     .        <=== *
                     .             *
                     .             *
                 . . B * * * * * * B
                                    \__ Lower-right corner
                  
            !!<
integer :: ej2            
            do ej2 = 1, mesh_edge.v_nv
              quarter = mesh_edge.u_quarter(ei,ej2)
              if ( quarter == SLICE_MESH__EDGE_LEVEL_QUARTER_PM ) then
                
              path_tip_u = mesh_vert.pos_u(ei)    ! left vertex of the edge
              path_tip_v = mesh_vert.pos_v(ej2)
              if ( )
              call register( this, path_tip_u, path_tip_v )
              
          head_cell = slice_mesh_ivect_t(ei+1,ej) ! cell's ij = edge's ij
          head_direct = SLICE_MESH__PATH_EASTWARD
          call mesh_edge.erase( vpos_start, SLICE_MESH__EAST )

        else
            call ut__fatal( "__MODFUNC__: Missing some case?" )
          end if
          status = 'have found'
          return
        end if
      end do
    end do 
    status = 'no contour'
  end subroutine contour_path__set_starting_edge


  subroutine register( contour_path, u, v )
    type(contour_path_t) <io> :: contour_path
    real <in> :: u, v

    integer :: n

    n = contour_path.num + 1
    call ut__assert( n <= size(contour_path.list_u,dim=1),  &
                    '__MODFUNC__: Increase array size of path_vert.' )

    contour_path.list_u(n) = u
    contour_path.list_v(n) = v
    contour_path.num = n
  end subroutine register


  subroutine contour_path__trace_and_erase( this,       &
                                            mesh_vert,  &
                                            mesh_edge,  &
                                            direct_now, &
                                            vpos_now )
    class(contour_path_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    type(slice_mesh_direct_t) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    type(slice_mesh_ivect_t) <io> :: vpos_now

    logical :: moved_one_step, path_is_closed

    do
        !!> 
          Turn left if you can.
                       C
                       |
                       |
                       |
            A -------> B <= You are here. Checking if you can
                  \         turn to the left (upward) direction.
                   \
                    You came along this edge.
        !!<
      call turn( 'left',          &
                 this,            &
                 mesh_edge,       &
                 direct_now,      &
                 vpos_now,        &
                 moved_one_step,  &
                 path_is_closed )
      if ( moved_one_step ) then
        !!>
            OK. You have turned to left. "vpos" has moved.
            
                         C <= You are here now.
                         |
                         M <= Place a path point at 
                         |    the middle of edge BC.
               A - - - - B
        !!<
        call register( this, mesh_vert, vpos_now )
      end if
      if ( path_is_closed ) return
        ! Your job is done if you have returned to the starting point.

      !!>
        You are at C. Turn right if you can the next step,
        and you will place another path point at the middle
        of edge CD.
        
           O - - - - - - - C - - - M - --> D
           |               |     *         |
           |               |   *           |
           |               | *             |
           |               M(iddle of BC)  |
           |             * |               |
           |           *   |               |
           |         *     |               |
           A - - - * - - - B - - - - - - - O
      !!<
      call turn( 'right',         &
                 this,            &
                 mesh_edge,       &
                 direct_now,      &
                 vpos_now,        &
                 moved_one_step,  &
                 path_is_closed )
      if ( moved_one_step ) then
        call register( this, mesh_vert, vpos_now )
      end if
      if ( path_is_closed ) return

      !!>
         If you could not turn left nor right, you should
         be able to go forward.
      !!<
      call turn( 'forward',       &
                 this,            &
                 mesh_edge,       &
                 direct_now,      &
                 vpos_now,        &
                 moved_one_step,  &
                 path_is_closed )
      if ( moved_one_step ) then
        call register( this, mesh_vert, vpos_now )
      end if
      if ( path_is_closed ) return
    end do

  end subroutine contour_path__trace_and_erase

end module contour_path_m
