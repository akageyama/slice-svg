module contour_path_m
  use ut_m
  use slice_mesh_m
  implicit none
  private
  !!>
        P: positive edge: eastward for edgex and
                          northward for edgey
        M: negative edge: westward for edgex and
                          southward for edgey 
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
  !!<

  type contour_path_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    integer, dimension(:), allocatable :: list_i, list_j
  contains
    procedure :: initialize => contour_path__initialize
    procedure :: reset => contour_path__reset
    procedure :: trace_and_erase  &
                       => contour_path__trace_and_erase
    procedure, pass :: set_starting_edge &
                       => contour_path__set_starting_edge
  end type contour_path_t


contains

  

  function returned_to_start_point( i_start, j_start,  &
                                    i_now, j_now ) result(ans)
    integer <in> :: i_start, j_start
    integer <in> :: i_now, j_now
    logical :: ans
    ans = ( i_start == i_now  .and.  &
            j_start == j_now )
  end function returned_to_start_point


  function impossible_turn( i, j, nu, nv, direction, turn ) result(ans)
    integer <in> :: i, j, nu, nv
    integer <in> :: direction
    char(len=*) <in> :: turn
    logical :: ans

    !!>
        
          + - + - + - N<==+ - + - + - + ...j=nv
          |   |   |   |   |   |   |   |
          + - + - + - + - + - + - + - +
          |   |   |   |   |   |   |   |
          + - + - + - M<==+ - + - + - +
          |   |   |   |   |   |   |   |
          + - + - + - + - + - + - + - +
          |   |   |   |   |   |   |   |
          + - + - + - + - + - + - + - + ...j=1
          .                           .
          .                           .
         i=nu                        i=nu

          Suppose you are going westward. When
        you have arrived the vertex position
        labeld 'M' in the above figure, you may 
        be able to turn left or right as long as 
        the edge value (edge_v.ternary) there is
        -1 (southward) or +1 (northward), respect-
        ively. However, when you are at the vertex 
        point 'N', it is apparent that you cannot 
        turn right.
    !!<

    call ut__assert( which_turn == 'left' .or.  &
                     which_turn == 'right',     &
                    '__MODFUNC__: Bad argument "turn".' )

    ans = .false.  ! Default.

    select case (direction)
      case (SLICE_MESH__EAST)
        if ( j == 1  .and. turn == 'right' ) ans = .true.
        if ( j == nv .and. turn == 'left'  ) ans = .true.
      case (SLICE_MESH__NORTH)
        if ( i == 1  .and. turn == 'left'  ) ans = .true.
        if ( i == nu .and. turn == 'right' ) ans = .true.
      case (SLICE_MESH__WEST)
        if ( j == 1  .and. turn == 'left'  ) ans = .true.
        if ( j == nv .and. turn == 'right' ) ans = .true.
      case (SLICE_MESH__SOUTH)
        if ( i == 1  .and. turn == 'right' ) ans = .true.
        if ( i == nu .and. turn == 'left'  ) ans = .true.
      case default
        call ut__fatal( '__MODFUNC__: case error.' )
    end select
  end subroutine impossible_turn


  subroutine turn( which_turn,      &
                   path,            &
                   edge,            &
                   direct_now,      &
                   vpos_now,        &
                   moved_one_step,  &
                   path_is_closed )
    char(len=*) <in> :: which_turn
    type(contour_path_t) <in> :: path
    type(slice_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    type(slice_mesh_ivec_t) <io> :: vpos_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default.

    call ut__assert( which_turn == 'left' .or.  &
                     which_turn == 'right',     &
                    '__MODFUNC__: Bad argument "which_turn".' )

    if ( impossible_turn( vpos_now.i,   vpos_now.j,    &
                          path.vert_nu, path.vert.nv,  &
                          direct_now.d, which_turn ) ) return

    if ( edge.can_turn_to)


    select case (direct_now.d)
      case (SLICE_MESH__EAST)
        !!>
               ^        
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn left (northward) or not.
        !!<
        if ( j_now == path.vert_nv ) return
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          edge.u_ternary(i_now-1,j_now) = 0   ! Erase the trace
          j_now += 1                          ! Move the head point
          direct_now = 'N'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now-1) = 0 ! Erase the last edge.
          end if
        end if
      case ('N')
        !!>
              | 
          <-- + --
              ^
              | 
              N
        !!<
        if ( i_now == 1 ) return
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          edge.v_ternary(i_now,j_now-1) = 0  ! Erase the trace
          i_now -= 1                         ! Move the head point
          direct_now = 'W'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now,j_now) = 0 ! Erase the last edge.
          end if
        end if
      case ('W')
        !!>
              | 
           -- + <---W
              |  
              v
        !!<
        if ( j_now == 1 ) return
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          edge.u_ternary(i_now,j_now) = 0     ! Erase the trace
          j_now -= 1                          ! Move the head point
          direct_now = 'S'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now+1) = 0 ! Erase the last edge.
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
           -- + -->
              |
        !!<
        if ( i_now == path.vert_nu ) return
        if ( edge.u_ternary(i_now,j_now) == +1 ) then
          edge.v_ternary(i_now,j_now) = 0     ! Erase the trace
          i_now += 1                          ! Move the head point
          direct_now = 'E'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now-1,j_now) = 0 ! Erase the last edge.
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine turn_left
 
  subroutine turn_left( path,            &
                        edge,            &
                        direct_now,      &
                        i_now,           &
                        j_now,           &
                        moved_one_step,  &
                        path_is_closed )
    type(contour_path_t) <in> :: path
    type(slice_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default

    select case (direct_now)
      case ('E')
        !!>
               ^        
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn left (northward) or not.
        !!<
        if ( j_now == path.vert_nv ) return
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          edge.u_ternary(i_now-1,j_now) = 0   ! Erase the trace
          j_now += 1                          ! Move the head point
          direct_now = 'N'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now-1) = 0 ! Erase the last edge.
          end if
        end if
      case ('N')
        !!>
              | 
          <-- + --
              ^
              | 
              N
        !!<
        if ( i_now == 1 ) return
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          edge.v_ternary(i_now,j_now-1) = 0  ! Erase the trace
          i_now -= 1                         ! Move the head point
          direct_now = 'W'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now,j_now) = 0 ! Erase the last edge.
          end if
        end if
      case ('W')
        !!>
              | 
           -- + <---W
              |  
              v
        !!<
        if ( j_now == 1 ) return
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          edge.u_ternary(i_now,j_now) = 0     ! Erase the trace
          j_now -= 1                          ! Move the head point
          direct_now = 'S'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now+1) = 0 ! Erase the last edge.
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
           -- + -->
              |
        !!<
        if ( i_now == path.vert_nu ) return
        if ( edge.u_ternary(i_now,j_now) == +1 ) then
          edge.v_ternary(i_now,j_now) = 0     ! Erase the trace
          i_now += 1                          ! Move the head point
          direct_now = 'E'                    ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now-1,j_now) = 0 ! Erase the last edge.
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine turn_left

 
  subroutine turn_right( path,            &
                         edge,            &
                         direct_now,      &
                         i_now,           &
                         j_now,           &
                         moved_one_step,  &
                         path_is_closed )
    type(contour_path_t) <in> :: path
    type(slice_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn right (southward) or not.
               v
        !!<
        if ( j_now == 1 ) return
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          edge.u_ternary(i_now-1,j_now) = 0  ! Erase the trace
          j_now -= 1                         ! Move the head point
          direct_now = 'S'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now) = 0  ! Erase the last edge.
          end if
        end if
      case ('N')
        !!>
              | 
           -- + -->
              ^
              | 
              N
        !!<
        if ( i_now == path.vert_nu ) return
        if ( edge.u_ternary(i_now,j_now) == +1 ) then
          edge.v_ternary(i_now,j_now-1) = 0    ! Erase the trace
          i_now += 1                           ! Move the head point
          direct_now = 'E'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now-1,j_now) = 0  ! Erase the last edge.
          end if
        end if
      case ('W')
        !!>
              ^
              | 
           -- + <---W
              |  
        !!<
        if ( j_now == path.vert_nv ) return
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          edge.u_ternary(i_now,j_now) = 0      ! Erase the trace
          j_now += 1                           ! Move the head point
          direct_now = 'S'                     ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now-1) = 0  ! Erase the last edge.
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
          <-- + -- 
              |
        !!<
        if ( i_now == 1 ) return
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          edge.v_ternary(i_now,j_now) = 0    ! Erase the trace
          i_now -= 1                         ! Move the head point
          direct_now = 'W'                   ! Turn 90 degree
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now,j_now) = 0  ! Erase the last edge.
          end if
        end if
      case default
        call ut__fatal( '__MODFUNC__: Wrong direct case.' )
    end select

  end subroutine turn_right  

 
  subroutine go_forward( path,            &
                         edge,            &
                         direct_now,      &
                         i_now,           &
                         j_now,           &
                         moved_one_step,  &
                         path_is_closed )
    type(contour_path_t) <in> :: path
    type(slice_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: moved_one_step
    logical <out> :: path_is_closed

    moved_one_step = .false.  ! Default.
    path_is_closed = .false.  ! Default

    !!>
        This routine is called after "turn_left" or
        "turn_right". So, we should be able to go 
        forward, as long as the path is closed.
    !!<

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + -->  at '+' point, and moving eastward.
               |      Checking if you can go straight or not.

        !!<
        call ut__assert( i_now /= path.vert_nu,       &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the right wall.' )
        if ( edge.u_ternary(i_now,j_now) == +1 ) then 
          edge.u_ternary(i_now-1,j_now) = 0   ! Erase the trace
          i_now += 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now-1,j_now) = 0 ! Erase the last edge.
          end if
          return
        end if
      case ('N')
        !!>
               ^
               | 
            -- + --
               ^
               | 
               N
        !!<
        call ut__assert( j_now /= path.vert_nv,       &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the top wall.' )
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          edge.v_ternary(i_now,j_now-1) = 0  ! Erase the trace
          j_now += 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now-1) = 0 ! Erase the last edge.
          end if
          return
        end if
      case ('W')
        !!>
                | 
            <-- + <---W
                |  
        !!<
        call ut__assert( i_now /= 1,                  &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the left wall.' )
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          edge.u_ternary(i_now,j_now) = 0   ! Erase the trace
          i_now -= 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.u_ternary(i_now,j_now) = 0 ! Erase the last edge.
          end if
          return
        end if
      case ('S')
        !!>
                S
                | 
                v
             -- + -- 
                |
                v
        !!<
        call ut__assert( j_now /= 1,                  &
                        '__MODFUNC__: Impossible! '   &
                     // ' Tying to go through the bottom wall.' )
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          edge.v_ternary(i_now,j_now) = 0   ! Erase the trace
          j_now -= 1
          moved_one_step = .true.
          path_is_closed = returned_to_start_point( path.list_i(1),  &
                                                    path.list_j(1),  &
                                                    i_now,           &
                                                    j_now )
          if ( path_is_closed ) then
            edge.v_ternary(i_now,j_now) = 0 ! Erase the last edge.
          end if
          return
        end if
      case default
        call ut__fatal( '__MODFUNC__: Wrong direct case.' )
    end select

    call ut__fatal( '__MODFUNC__: Failed to go forward.' )

  end subroutine go_forward


  subroutine contour_path__reset( this )
    class(contour_path_t) <io> :: this
    this.num = 0
    this.list_i(:) = 0
    this.list_j(:) = 0
  end subroutine contour_path__reset


  subroutine contour_path__initialize( this, vert_nu, vert_nv )
    class(contour_path_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv

    allocate(this.list_i(max_path_element_num))
    allocate(this.list_j(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call contour_path__reset( this )
  end subroutine contour_path__initialize


  subroutine contour_path__set_starting_edge( this,         &
                                              mesh_edge,    &
                                              direct_now,   &
                                              status,       &
                                              vpos_now )
    class(contour_path_t) <io> :: this
    type(slice_mesh_edge_t) <io> :: mesh_edge
    type(slice_mesh_direct_t) <in> :: direct_now
    char(len=10) <out> :: status ! 'no contour' or 'have found'
    type(slice_mesh_ivect_t) <out> :: vpos_now ! vert position

    type(slice_mesh_ivect_t) :: vpos_start
    !!>
          Tring to find an eastward arrow AB.
              +---+---+---+
              |           |
              +---+       +
                  |       |
                  A==>B---+
    !!< 
    integer :: ei, ej

    call ut__assert( direct_now.d==SLICE_MESH__EAST,  &
                    '__MODFUNC__: We assume the start edge is Eastward.' )
    call ut__assert( this.num == 0,  &
                    '__MODFUNC__: You forgot to reset contour_path.' )

    do ej = 1, mesh_edge.u_nv
      do ei = 1, mesh_edge.u_nu
        if ( mesh_edge.u_ternary(ei,ej) == +1 ) then
          ! Found a boundary curve of 'Eastward' direction.
          vpos_start = slice_mesh_ivect_t(ei,ej)
            ! Vertex indexes of an left-end of
            ! an edge is the same as the edge indexes.
          call register( this, vpos_start )
          vpos_now = vpos_start.shift( SLICE_MESH__EAST )
          call register( this, vpos_now )
          call mesh_edge.erase( vpos_start, SLICE_MESH__EAST )
          status = 'have found'
          return
        end if
      end do
    end do 
    status = 'no contour'
    call ut__fatal( '__MODFUNC__: Cound not find a start edge.' )
  end subroutine contour_path__set_starting_edge    


  subroutine register( contour_path, vpos )
    type(contour_path_t) <io> :: contour_path
    type(slice_mesh_ivect_t) <in> :: vpos

    integer :: n
    n = contour_path.num + 1
    call ut__assert( n <= size(contour_path.list_i,dim=1),  &
                    '__MODFUNC__: Increase array size of path_vert.' )
    contour_path.list_i(n) = vpos.i
    contour_path.list_j(n) = vpos.j
    contour_path.num = n
  end subroutine register


  subroutine contour_path__trace_and_erase( this,       &
                                            mesh_edge,  &
                                            direct_now, &
                                            vpos_now )
    class(contour_path_t) <io> :: this
    type(slice_mesh_edge_t) <io> :: mesh_edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    type(slice_mesh_ivec_t) <io> :: vpos_now

    logical :: moved_one_step, path_is_closed

    do 
!debugp 'do loop.'    
!debugp direct_now
      !
      call turn( 'left',          &
                 this,            &
                 mesh_edge,       &
                 direct_now,      &
                 vpos_now,        &
                 moved_one_step,  &
                 path_is_closed )
      if ( moved_one_step ) then
        call register( this, vpos_now )
      end if
      if ( path_is_closed ) return
!debugp 'done turn_right'

      !
      ! right
      !
      call turn( 'right',         &
                 this,            &
                 mesh_edge,       &
                 direct_now,      &
                 vpos_now,        &
                 moved_one_step,  &
                 path_is_closed )
      if ( moved_one_step ) then
        call register( this, i_now, j_now )
      end if
      if ( path_is_closed ) return
!debugp 'done turn_right'

      !
      ! straight
      !
      call go_forward( this,            &
                       mesh_edge,       &
                       direct_now,      &
                       vpos_now,        &
                       moved_one_step,  &
                       path_is_closed )
!debugp 'done go forward'
!debugp i_now, j_now, direct_now
      !!>
          We do not need to register the forward-stepped point,
          because the path
                   1---2---3
                           |          
                           4---5---6---7
          is the same as
                   1-------2
                           |          
                           3-----------4
      !!<
      if ( path_is_closed ) then
        call register( this, vpos_now )
        return
      end if
    end do

  end subroutine contour_path__trace_and_erase


end module contour_path_m
