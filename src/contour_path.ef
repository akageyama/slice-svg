module contour_path_m
  use ut_m
  use slice_mesh_m
  implicit none
  !!>
        P: positive edge: eastward for edgex and
                          northward for edgey
        M: negative edge: westward for edgex and
                          southward for edgey 
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
  !!<

  type contour_path_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    integer, dimension(:), allocatable :: list_i, list_j
    integer :: start_position_i, start_position_j
  contains
    procedure :: initialize => contour_path__initialize
    procedure :: register => contour_path__register
    procedure :: reset => contour_path__reset
    procedure :: explore => contour_path__explore
    procedure :: turn_left => contour_path__turn_left
    procedure :: turn_right => contour_path__turn_right
    procedure :: go_foward => contour_path__go_forward
  end type contour_path_t


contains


  function contour_path_closed( this, i_now, j_now ) result(ans)
    type(contour_path_t) <in> :: this
    integer <in> :: i_now, j_now
    logical :: ans

    ans = ( i_now == this.start_position_i .and. &
            j_now == this.start_position_j )

  end function contour_path_closed

 
  subroutine contour_path__turn_left( this, edge,               &
                                      direct_now, i_now, j_now, &
                                      path_closed  )
    class(contour_path_t) <io> :: this
    type(grid_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: path_closed

    path_closed = .false.  ! default value.
    
    select case (direct_now)
      case ('E')
        !!>
               ^        
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn left (northward) or not.
        !!<
        call assert( j <= this.vert_nv-1,  &
                    'Impossible! You are going easthward on j=jmax?!' )
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          j_now += 1                         ! Move the head point
          direct_now = 'N'                   ! Turn 90 degree
          edge.u_ternary(i_now-1,j_now) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('N')
        !!>
              | 
          <-- + --
              ^
              | 
              N
        !!<
        call assert( i >= 2,  &
                    'Impossible!? You are going northward on i=1?!' )
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          i_now -= 1                         ! Move the head point
          direct_now = 'W'                   ! Turn 90 degree
          edge.v_ternary(i_now,j_now-1) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('W')
        !!>
              | 
           -- + <---W
              |  
              v
        !!<
        call assert( j >= 2,  &
                    'Impossible!? You are going westward on j=1?!' )
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          j_now -= 1                       ! Move the head point
          direct_now = 'S'                 ! Turn 90 degree
          edge.u_ternary(i_now,j_now) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
           -- + -->
              |
        !!<
        call assert( i <= this.vert_nu-1,  &
                    'Impossible!? You are going southward on i=imax?!' )
        if ( edge.u_ternary(i_now,j_now) == +1 ) then
          i_now += 1                       ! Move the head point
          direct_now = 'E'                 ! Turn 90 degree
          edge.v_ternary(i_now,j_now) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine contour_path__turn_left_check

 
  subroutine contour_path__turn_right( this, edge,               &
                                       direct_now, i_now, j_now, &
                                       path_closed  )
    class(contour_path_t) <io> :: this
    type(grid_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: path_closed

    path_closed = .false.  ! default value.

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + --   at '+' point, and moving eastward.
               |      Checking if you can turn right (southward) or not.
               v
        !!<
        call assert( j >= 2,  &
                    'Impossible! You are going easthward on j=1?!' )
        if ( edge.v_ternary(i_now,j_now-1) == -1 ) then
          j_now -= 1                         ! Move the head point
          direct_now = 'S'                   ! Turn 90 degree
          edge.u_ternary(i_now-1,j_now) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('N')
        !!>
              | 
           -- + -->
              ^
              | 
              N
        !!<
        call assert( i <= this.vert_nu-1,  &
                    'Impossible!? You are going northward on i=imax?!' )
        if ( edge.u_ternary(i_now,j_now) == +1 ) then
          i_now += 1                         ! Move the head point
          direct_now = 'E'                   ! Turn 90 degree
          edge.v_ternary(i_now,j_now-1) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('W')
        !!>
              ^
              | 
           -- + <---W
              |  
        !!<
        call assert( j <= this.vert_nv-1,  &
                    'Impossible!? You are going westward on j=jmax?!' )
        if ( edge.v_ternary(i_now,j_now) == +1 ) then
          j_now += 1                       ! Move the head point
          direct_now = 'S'                 ! Turn 90 degree
          edge.u_ternary(i_now,j_now) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('S')
        !!>
              S
              | 
              v
          <-- + -- 
              |
        !!<
        call assert( i >= 2 ,  &
                    'Impossible!? You going southward on i=1?!' )
        if ( edge.u_ternary(i_now-1,j_now) == -1 ) then
          i_now -= 1                       ! Move the head point
          direct_now = 'W'                 ! Turn 90 degree
          edge.v_ternary(i_now,j_now) = 0  ! Erase the edge
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine contour_path__turn_right  

 
  subroutine contour_path__go_forward( this, edge,               &
                                       direct_now, i_now, j_now, &
                                       path_closed  )
    class(contour_path_t) <io> :: this
    type(grid_mesh_edge_t) <io> :: edge
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <io> :: i_now, j_now
    logical <out> :: path_closed

    path_closed = .false.  ! default value.

    select case (direct_now)
      case ('E')
        !!>
                       
               |      You are now (i,j)=(i_now,j_now),
          E--> + -->  at '+' point, and moving eastward.
               |      Checking if you can go straight or not.

        !!<
        if ( i_now == this.vert_nu ) return  ! You cannot go forward.
        if ( edgex_ternary(i_now,j_now) == +1 ) then 
          i_now += 1
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('N')
        !!>
               ^
               | 
            -- + --
               ^
               | 
               N
        !!<
        if ( j_now == this.vert_nv ) return  ! You cannot go forward.
        if ( edgey_ternary(i_now,j_now) == +1 ) then
          j_now += 1
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('W')
        !!>
                | 
            <-- + <---W
                |  
        !!<
        if ( i_now == 1 ) return  ! You cannot go forward.
        if ( edgex_ternary(i_now-1,j_now) == -1 ) then
          i_now -= 1
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case ('S')
        !!>
                S
                | 
                v
             -- + -- 
                |
                v
        !!<
        if ( j_now == 1 ) return  ! You cannot go forward.
        if ( edgey_ternary(i_now,j_now-1) == -1 ) then
          j_now -= 1
          if ( contour_path_closed( this, i_now, j_now ) ) then
            path_closed = .true.
          end if
        end if
      case default
        call ut__fatal( 'Wrong direct case.' )
    end select

  end subroutine contour_path__go_forward


  subroutine contour_path__reset( this )
    class(contour_path_t) <io> :: this
    this.num = 0
    this.list_i(:) = 0
    this.list_j(:) = 0
    this.start_position_i = 0
    this.start_position_j = 0
  end subroutine contour_path__reset


  subroutine contour_path__initialize( this, vert_nu, vert_nv )
    class(contour_path_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv

    allocate(this.list_i(max_path_element_num))
    allocate(this.list_j(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call contour_path__reset( this )
  end subroutine contour_path__initialize


  subroutine countour_path__set_start_position( this, i, j )
    class(contour_path_t) <io> :: this
    integer <in> :: i, j

    call ut__assert( this.num == 0,   &
                    'You forgot to reset vert num.' )
    call contour_path__register( this, i, j )
    this.start_position_i = i
    this.start_position_j = j
  end subroutine countour_path__set_start_position


  subroutine contour_path__register( this, i, j )
    class(contour_path_t) <io> :: this
    integer <in> :: i, j

    integer :: n
    n = this.num + 1
    call assert( n <= size(this.list_i,dim=1),  &
                'Increase array size of path_vert.' )
    this.lis_i(n) = i
    this.lis_j(n) = j
    this.num = n
  end subroutine contour_path__register


end module contour_path_m
