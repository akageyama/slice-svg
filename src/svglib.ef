!!>
    Note: svglib_fig_t ==> svglib_t
!!<
module svglib_m
  use color_m
  use const_base_m
  use fileut_m
  implicit none
  private
  public :: svglib__text_line
  public :: SVGLIB__BSL

  type, public :: svglib_t
    char(len=300) :: file_name
    real :: width, height
    integer :: file_unit
    integer :: indent_level
  contains
    procedure :: group_begin => svglib__group_begin
    procedure :: group_end => svglib__group_end
    procedure :: open => svglib__open
    procedure :: close => svglib__close
    procedure :: line => svglib__line
    procedure :: arrow => svglib__arrow
    procedure :: text => svglib__text
  end type svglib_t



  interface svglib__text_line
     module procedure text_line_str_i,                  &
                      text_line_str_r,                  &
                      text_line_s1_r1_s2_r2,            &
                      text_line_str_r1_r2_r3_r4,        &
                      text_line_s1_r1_s2_r2_s3_r3_s4_r4
  end interface svglib__text_line

  char(len=1) <const> :: QUOTE = '"'
  char(len=1) <const> :: SPACE = ' '
  integer <const> :: SVGLIB__BSL = 100  ! Basic text string length
                                        ! e.g., '<line = "... >'

contains


  subroutine assert( condition, lastwill )
    logical <in> :: condition
    char(len=*) <in> :: lastwill
    if ( .not. condition ) then
      print *, "__MODULE__: "//trim(lastwill)
      stop
    end if
  end subroutine assert
  
  
  function text_line_str_r( string, r ) result(line)
    char(len=*) <in> :: string
    real <in> :: r  ! real value
    char(len=SVGLIB__BSL) :: line

    write(line, "(a)") trim(string)//QUOTE//trim(r2s(r))//QUOTE
  end function text_line_str_r

  
  function text_line_s1_r1_s2_r2( s1, r1,   &
                                  s2, r2) result(line)
    char(len=*) <in> :: s1, s2
    real <in> :: r1, r2
    char(len=SVGLIB__BSL) :: line

    write(line, "(a)") trim(s1)//QUOTE//trim(r2s(r1))//QUOTE   &
              //SPACE//trim(s2)//QUOTE//trim(r2s(r2))//QUOTE
  end function text_line_s1_r1_s2_r2

  
  function text_line_s1_r1_s2_r2_s3_r3_s4_r4( s1, r1,   &
                                              s2, r2,   &
                                              s3, r3,   &
                                              s4, r4 ) result(line)
    char(len=*) <in> :: s1, s2, s3, s4
    real <in> :: r1, r2, r3, r4
    char(len=SVGLIB__BSL) :: line

    write(line, "(a)") trim(s1)//QUOTE//trim(r2s(r1))//QUOTE   &
              //SPACE//trim(s2)//QUOTE//trim(r2s(r2))//QUOTE   &
              //SPACE//trim(s3)//QUOTE//trim(r2s(r3))//QUOTE   &
              //SPACE//trim(s4)//QUOTE//trim(r2s(r4))//QUOTE
  end function text_line_s1_r1_s2_r2_s3_r3_s4_r4



  function text_line_str_r1_r2_r3_r4( string, r1, r2, r3, r4 ) result(line)
    char(len=*) <in> :: string
    real <in> :: r1, r2, r3, r4
    char(len=SVGLIB__BSL) :: line

    write(line, "(a)") trim(string)//QUOTE//trim(r2s(r1))   &
                                   //SPACE//trim(r2s(r2))   &
                                   //SPACE//trim(r2s(r3))   &
                                   //SPACE//trim(r2s(r4))   &
                                   //QUOTE
  end function text_line_str_r1_r2_r3_r4

  
  function text_line_str_i( string, val ) result(line)
    char(len=*) <in> :: string
    integer <in> :: val
    char(len=SVGLIB__BSL) :: line

    write(line, "(a,a,i0,a)") trim(string), QUOTE, val, QUOTE
  end function text_line_str_i


  function get_date_and_time() result(string)
    ! copied from ut.ef
    char(len=8)  :: date   ! e.g., "20221126"
    char(len=10) :: time   ! "HHMMSS.sss"
    char(len=4)  :: year
    char(len=2)  :: month, day, hour, minute, second
    char(len=10) :: year_month_day     ! e.g., "2022.07.09"
    char(len=8)  :: hour_minute_second ! e.g., "16:56:00"
    char(len=19) :: string ! e.g., "2022.07.09/16:56:00"

    call date_and_time(date, time)

    year   = date(1:4)
    month  = date(5:6)
    day    = date(7:8)
    hour   = time(1:2)
    minute = time(3:4)
    second = time(5:6)

    year_month_day     = year // '.' // month // '.' // day
    hour_minute_second = hour // ':' // minute // ':' // second
    string = year_month_day // '/' // hour_minute_second
  end function get_date_and_time


  subroutine indent_pop( this )
    type(svglib_t) <io> :: this

    if ( this.indent_level > 0 ) then
      this.indent_level -= 1
    else
      ! Something is wrong, but do nothing, anyway.
    end if
  end subroutine indent_pop


  subroutine indent_push( this )
    type(svglib_t) <io> :: this

    this.indent_level += 1
  end subroutine indent_push


  subroutine print_footer( this )
    type(svglib_t) <in> :: this

    call write_out( this, ' ' )
    call write_out( this, '</svg>' )
  end subroutine print_footer



  subroutine print_header( this, width, height )
    type(svglib_t) <in> :: this
    real <in> :: width,  height

    char(len=*) <const> :: STR_XMLNS = 'xmlns="http://www.w3.org/2000/svg"'
    char(len=SVGLIB__BSL) :: str_width,   &
                             str_height,  &
                             str_viewbox

    str_width   = svglib__text_line( 'width=',  width )
    str_height  = svglib__text_line( 'height=', height )
    str_viewbox = svglib__text_line( 'viewBox=', 0.0, 0.0, width, height )

    call write_out( this, '<svg ' // STR_XMLNS          &
                         // SPACE // trim(str_width)    &
                         // SPACE // trim(str_height)   &
                         // SPACE // trim(str_viewbox)  &
                         // SPACE // '>' )
    call write_out( this, '<!-- SVG file generated by __MODULE__ on ' &
                           // get_date_and_time()                     &
                           // '-->' )
  end subroutine print_header


  subroutine print_marker_arrow( this, scale )
    type(svglib_t) <in> :: this
    integer <in> :: scale

    real :: buffer, px, py, qx, qy, rx, ry, sx, sy, tx, ty
    real :: viewbox_upperleft_x, viewbox_upperleft_y
    real :: viewbox_lowerright_x, viewbox_lowerright_y
    real :: viewbox_width, viewbox_height

    char(len=SVGLIB__BSL) :: str_viewbox
    char(len=SVGLIB__BSL) :: str_markerWidth, str_markerHeight
    char(len=SVGLIB__BSL) :: str_line_start_finish, str_stroke_width
    char(len=SVGLIB__BSL) :: str_refX = 'refX="0.0"'
    char(len=SVGLIB__BSL) :: str_refY = 'refY="0.0"'

    !!>

                                     S
                                     * *
                                     *   *
                   P  *  *  *  *  *  Q  *  R
                   .     .     .     *   * .
                   .     .     .     * *   .
                   .     .     .     T     .
        -----------+-----+-----+-----+-----+-----+---
                   .     .     0     .     .     
                   .     .           .     .     
               -2*scale  .           .  2*scale  
                     -1*scale      scale         
    !!<    

    buffer = 1.0
    px = -2.0*scale
    py = 0.0
    qx = scale
    qy = 0.0
    rx = 2.0*scale
    ry = 0.0
    sx = scale
    sy = -scale*0.5
    tx = scale
    ty = scale*0.5
    viewbox_upperleft_x = px - buffer
    viewbox_upperleft_y = sy - buffer
    viewbox_lowerright_x = rx + buffer
    viewbox_lowerright_y = ty + buffer
    viewbox_width = viewbox_lowerright_x - viewbox_upperleft_x
    viewbox_height = viewbox_lowerright_y - viewbox_upperleft_y

    str_viewbox = svglib__text_line( 'viewBox=', viewbox_upperleft_x,   &
                                                 viewbox_upperleft_y,   &
                                                 viewbox_width,         &
                                                 viewbox_height )
    str_markerWidth  = svglib__text_line(' markerWidth=',  viewbox_width )
    str_markerHeight = svglib__text_line(' markerHeight=', viewbox_height )

    call write_out( this, '<marker'                             &
                          // SPACE // trim(str_viewbox)         &
                          // SPACE // trim(str_markerWidth)     &
                          // SPACE // trim(str_markerHeight)    &
                          // SPACE // trim(str_refX)            &
                          // SPACE // trim(str_refY)            &
                          // SPACE // 'stroke="currentcolor"'   &
                          // SPACE // 'fill="currentcolor"'     &
                          // SPACE // 'id="arrow"'              &
                          // SPACE // 'orient="auto"'           &
                          // SPACE // '>' )                        

    str_line_start_finish = svglib__text_line( 'x1=', px,  &
                                               'y1=', py,  &
                                               'x2=', qx,  &
                                               'y2=', qy )
    str_stroke_width = svglib__text_line( 'stroke-width=', 2 )

    ! memo: indent
    call write_out( this, '  <line'                                  &
                             // SPACE // trim(str_line_start_finish) &
                             // SPACE // trim(str_stroke_width)      &
                             // SPACE //                             &
                             '/>' )
    call write_out( this, '  <polygon points="'//trim(r2s(rx))  &
                                          //','//trim(r2s(ry))  &
                                          //' '//trim(r2s(sx))  &
                                          //','//trim(r2s(sy))  &
                                          //' '//trim(r2s(tx))  &
                                          //','//trim(r2s(ty))  &
                                          //'" />' )
    call write_out( this, '</marker>' )
  end subroutine print_marker_arrow


  function r2s( val ) result(str)
    ! real to string
    real <in> :: val
    char(len=100) :: str

    write(str,"(f0.2)") val
  end function r2s


  subroutine write_out( this, line )
    type(svglib_t) <in> :: this
    char(len=*) <in> :: line

    integer <const> :: NUM_SPACES_PER_INDENT = 2
    integer :: num_spaces
    char(len=*) <const> :: BLANK_LINE = '                                         '

    num_spaces = this.indent_level*NUM_SPACES_PER_INDENT

    write(this.file_unit, *) BLANK_LINE(1:num_spaces)//trim(line)
  end subroutine write_out


  subroutine svglib__arrow( this, x, y, vx, vy )
    class(svglib_t) <in> :: this
    real <in> :: x, y, vx, vy

    real <const> :: VERY_SHORT = 0.1 
    real :: vector_amp, vx_norm, vy_norm
    real :: slightly_shifted_x
    real :: slightly_shifted_y
    real :: amaf ! arrow_marker_amplification_factor

    logical :: first_time_call = .true.
    integer <const> :: ASCALE=10 ! arrow glyph length scale

    if (first_time_call) then
      call print_marker_arrow( this, scale=ASCALE )
      first_time_call = .false.
    end if

    vector_amp = sqrt(vx**2+vy**2)
    if ( vector_amp < VERY_SHORT ) return

    !!>
          1
         /     0: (x,y)
        /      1: (slightly...x,slightly...y)
       0
    !!<

    vx_norm = vx / vector_amp
    vy_norm = vy / vector_amp

    slightly_shifted_x = x + VERY_SHORT*vx_norm
    slightly_shifted_y = y + VERY_SHORT*vy_norm

    amaf = vector_amp / real(ASCALE)
!debugp vector_amp, amaf    
    call svglib__line( this, x, y,          &
                       slightly_shifted_x,  &
                       slightly_shifted_y,  &
                       width=amaf,          &
                       color="none",        &
                       marker_start="arrow" )
  end subroutine svglib__arrow


  subroutine svglib__close( this )
    class(svglib_t) <in> :: this

    call print_footer( this )
    call fileut__close( this.file_unit )
  end subroutine svglib__close


  subroutine svglib__group_begin( this, attribute )
    class(svglib_t) <io> :: this
    char(len=*) <in> :: attribute

    write(this.file_unit, *) ''
    write(this.file_unit, *) '<g' // SPACE // trim(attribute) // '>'
    call indent_push( this )
  end subroutine svglib__group_begin


  subroutine svglib__group_end( this )
    class(svglib_t) <io> :: this
    write(this.file_unit, *) '</g>'
    call indent_pop( this )
  end subroutine svglib__group_end


  subroutine svglib__line( this, x1, y1,        &
                                 x2, y2,        &
                                 width,         &
                                 color,         &
                                 marker_start,  &
                                 marker_end )
    class(svglib_t) <in> :: this

    real <in> :: x1, y1, x2, y2
    real <in> :: width
    char(len=*) <optin> :: color
    char(len=*) <optin> :: marker_start, marker_end

!    char(len=SVGLIB__BSL) :: str_line_start_finish
!    char(len=SVGLIB__BSL) :: str_line_stroke, str_line_stroke_width
!    char(len=SVGLIB__BSL) :: str_marker_start, str_marker_end

    integer :: n, nopt  ! number of options
    integer <const> :: MAX_NOP = 10
    char(len=SVGLIB__BSL), dimension(MAX_NOP) :: str
    char(len=SVGLIB__BSL*MAX_NOP) :: str_all
    integer :: unit

    unit = this.file_unit

    !!>
         <line x1="40" y1="220" x2="41" y2="219.9" 
          stroke="none" stroke-width="1" 
          marker-end="url(#arrow-blue)" />  
    !!<          

    str(1) = svglib__text_line( 'x1=', x1,  &
                                'y1=', y1,  &
                                'x2=', x2,  &
                                'y2=', y2 )
    str(2) = svglib__text_line( 'stroke-width=', width )
    
    nopt = 2

    if ( present( color) ) then
      nopt += 1
      str(nopt) = 'stroke=' // QUOTE // trim(color) // QUOTE
    end if

    if ( present(marker_start) ) then
      nopt += 1
      str(nopt) = 'marker-start=' // QUOTE               &
                                  // 'url(#'             &
                                  // trim(marker_start)  &
                                  // ')'                 &
                                  // QUOTE 
    end if

    if ( present(marker_end) ) then
      nopt += 1
      str(nopt) = 'marker-end=' // QUOTE               &
                                // 'url(#'             &
                                // trim(marker_end)    &
                                // ')'                 &
                                // QUOTE 
    end if

    str_all = ''
    do n = 1, nopt
      str_all = trim(str_all) // SPACE // str(n)
    end do

    call write_out( this, '<line ' // trim(str_all) // '/>' )

  end subroutine svglib__line


  subroutine svglib__open( this, file_name, width, height )
    class(svglib_t) <io> :: this
    char(len=*) <in> :: file_name
    real <in> :: width, height

real :: v
integer :: i
 char(len=7) :: color_code

    this.file_name = trim(file_name)
    this.indent_level = 0

    this.file_unit = fileut__open( file=trim(file_name),  &
                                   action="readwrite",    &
                                   status="unknown" ) 
    this.width = width
    this.height = height
    call print_header( this, this.width, this.height )

    do i = 0, 100
      v = 0.01*i
      color_code = color__norm_real_to_color_code( v )
      print *, color_code
    end do

  end subroutine svglib__open


  subroutine svglib__text( this, x, y,                &
                                 string,              &
                                 font_size_in_pixel,  &
                                 color,               &
                                 text_anchor,         &
                                 stroke_width )
    class(svglib_t) <io> :: this
    real <in> :: x, y
    char(len=*) <in> :: string
    real <in> :: font_size_in_pixel
    char(len=*) <optin> :: color
    char(len=*) <optin> :: text_anchor
    real <optin> :: stroke_width

    integer :: n, nopt   ! number of options
    integer <const> :: MAX_NOP = 10  ! max
    char(len=SVGLIB__BSL), dimension(MAX_NOP) :: str
    char(len=SVGLIB__BSL*MAX_NOP) :: str_all

    str(1) = svglib__text_line( 'x=', x, 'y=', y )
    str(2) = svglib__text_line( 'font-size=',       &
                                 font_size_in_pixel )
    nopt = 2

    if ( present(color) ) then
      nopt += 1
      str(nopt) = 'fill=' // QUOTE // trim(color) // QUOTE
    end if

    if ( present(text_anchor) ) then
      nopt += 1
      str(nopt) = 'text-anchor=' // QUOTE // trim(text_anchor) // QUOTE
    end if

    str_all = ''
    do n = 1, nopt
      str_all = trim(str_all) // SPACE // trim(str(n))
    end do

    call write_out( this, '<text' // trim(str_all) // '>' )
      call indent_push( this )
        call write_out( this, string )
      call indent_pop( this )
    call write_out( this, '</text>' )

  end subroutine svglib__text

end module svglib_m
