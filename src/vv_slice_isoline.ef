module vv_slice_isoline_m
  use ut_m
  use const_base_m
  use vv_slice_mesh_m
  implicit none
  private

  !!> 
     To draw contour paths for a given level.
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m *-- - p - - * m - - - m -  
             |      *|       |       *       |   
             |    *  |       |       |*      |   
           - m -*- - p - - - p - - - p * - - m -  
             |   *   |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |     * |       |       |*      |   
             |     * |       |       *       |   
           - m - - * m - - - P - - * M - - - m -  
             |      *|       |  *    |       |   
             |       * * * * *       |       |   
           - m - - - m - - - m - - - m - - - m -  
             |       |       |       |       |   

     The border is usually rectangular,

          +=======+=======+=======+=======+=======+
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          +=======+=======+=======+=======+=======+


     but it can be more complex shape like,

          . . . . . . . . S=======+=======+=======W
          .       .       |       .       .       |     
          .       .       |       .       .       |     
          . . . . S=======W . . . + . . . E=======N
          .       |       .       .       |       .     
          .       |       .       .       |       .     
          S=======W . . . + . . . + . . . N=======W
          |       .       .       .       .       |     
          |       .       .       .       .       |     
          E=======S . . . + . . . + . . . + . . . +
          .       |       .       .       .       |     
          .       |       .       .       .       |     
          . . . . E=======S . . . E=======+=======N
          .       .       |       |       .       .     
          .       .       |       |       .       .     
          . . . . . . . . E=======N . . . . . . . .
     
     Here the letter 'W' stands for the turning direction 
     when you go along the border in the anti-crlockwise.

     Another possible complex border is diagonal edge like

                         SW=======W=======W 
                        / .       .       . \    going
                      /   .       .       .   \    north-west
                    /     .       .       .     \    from this
                 SW . . . + . . . + . . . + . . . NW   <== vert 
                / .       .       .       .       |     
              /   .       .       .       .       |     
            /     .       .       .       .       |     
          S . . . + . . . + . . . + . . . + . . . N
          |       .       .       .       .       |     
          |       .       .       .       .       |     
          |       .       .       .       .       |     
         SE . . . + . . . + . . . + . . . + . . . N
            \     .       .       .       .     /
              \   .       .       .       .   /
                \ .       .       .       . /
                  E=======E=======E=======NE

      Mathematically, every contour line is closed unless it touches 
      on the border of the simulatin box (u=umin/umax or v=vmin/vmax).

      We set a virtual contour line along the border if the boudary grid
      vertices satisfy the condition 
          vert_val >= level  (denoted by "p" in the figure),
      see the upper right figure. 

      Since all contour lines are thus always closed, we first find an
      edge (starting edge) for each contour and draw the contour with
      keeping grid vertices with 
          vert_val >= level
      always in its left-hand side of the path.
      
      Starting edge of a trully closed contour (without touching the
      boundaries) is any u_edge with its quarter value "PM" (plus-in-left
      and minus-in-right of the edge).

      Cares should be taken for contour lines with virual (on-border)
      contours. 

           ei     ei+1    *      
           |       |    *       
       - - p - - - p -*-       
           |       |*         
           |      *|         
           |    *  |        
    ej - - p==*====m - -   
           | *  \  |              
           |*   PM |             
           *      \
                   \
                 start edge   
  !!< 

  type, public :: vv_slice_isoline__element_t
    character :: edge_type       ! 'u' or 'v' or 'a' or 'd'
    char(len=2) :: cruising_lane ! 'in' (bulk) or 'on' (border)
    integer :: ei, ej  ! edge id
    character :: path_go_toward  ! along the edge (for on border lane)
                                 ! perp to the edge (for bulk lane)
  end type vv_slice_isoline__element_t

  type, public :: vv_slice_isoline_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    type(vv_slice_isoline__element_t) :: start
    type(vv_slice_isoline__element_t) :: head
    real, dimension(:), allocatable :: list_u, list_v
  contains
    procedure :: initialize => vv_slice_isoline__initialize
    procedure :: trace_and_erase => vv_slice_isoline__trace_and_erase
    procedure :: set_start_edge  &
                 => vv_slice_isoline__set_start_edge
    procedure :: reset => vv_slice_isoline__reset
    procedure :: is_closed => vv_slice_isoline__is_closed
    procedure :: register_new_vert  &
                          => vv_slice_isoline__register_new_vert
    procedure, private :: vv_slice_isoline__replace_head_by_vert
    procedure, private :: vv_slice_isoline__replace_head_direct
    generic :: replace_head_edge => vv_slice_isoline__replace_head_by_vert, &
                                    vv_slice_isoline__replace_head_direct
  end type vv_slice_isoline_t


contains


  subroutine vv_slice_isoline__replace_head_by_vert( this,         &
                                                     vi, vj,       &
                                                     octa_direct,  &
                                                     cruising_lane )
    class(vv_slice_isoline_t) <io> :: this
    integer <in> :: vi, vj
    integer <in> :: octa_direct
    char(len=2) <in> :: cruising_lane

    if ( cruising_lane == 'on' ) then
      select case ( octa_direct )
        case (0)
          this.head = vv_slice_isoline__element_t( 'v', 'on',   vi,   vj, 'N' )
        case (1)    
          this.head = vv_slice_isoline__element_t( 'a', 'on',   vi,   vj, 'N' )
        case (2)    
          this.head = vv_slice_isoline__element_t( 'u', 'on',   vi,   vj, 'E' )
        case (3)  
          this.head = vv_slice_isoline__element_t( 'd', 'on',   vi, vj-1, 'S' )
        case (4)  
          this.head = vv_slice_isoline__element_t( 'v', 'on',   vi, vj-1, 'S' )
        case (5)
          this.head = vv_slice_isoline__element_t( 'a', 'on', vi-1, vj-1, 'S' )
        case (6)
          this.head = vv_slice_isoline__element_t( 'u', 'on', vi-1,   vj, 'W' )
        case (7)  
          this.head = vv_slice_isoline__element_t( 'd', 'on', vi-1,   vj, 'N' )
        case default
          call ut__fatal( '__MODULE__(__LINE__): case error.' )
      end select
    else if ( cruising_lane == 'in' ) then
      select case ( octa_direct )
        case (0)
          this.head = vv_slice_isoline__element_t( 'v', 'in',   vi,   vj, 'W' )
        case (1)    
          this.head = vv_slice_isoline__element_t( 'a', 'in',   vi,   vj, 'N' )
        case (2)    
          this.head = vv_slice_isoline__element_t( 'u', 'in',   vi,   vj, 'N' )
        case (3)  
          this.head = vv_slice_isoline__element_t( 'd', 'in',   vi, vj-1, 'N' )
        case (4)  
          this.head = vv_slice_isoline__element_t( 'v', 'in',   vi, vj-1, 'E' )
        case (5)
          this.head = vv_slice_isoline__element_t( 'a', 'in', vi-1, vj-1, 'S' )
        case (6)
          this.head = vv_slice_isoline__element_t( 'u', 'in', vi-1,   vj, 'S' )
        case (7)  
          this.head = vv_slice_isoline__element_t( 'd', 'in', vi-1,   vj, 'S' )
        case default
          call ut__fatal( '__MODULE__(__LINE__): case error.' )
      end select
    else
      call ut__fatal( '__MODULE__(__LINE__): cruising_lane error.' )
    end if

  end subroutine vv_slice_isoline__replace_head_by_vert


  subroutine vv_slice_isoline__replace_head_direct( this,                  &
                                                    edge_type,             &
                                                    cruising_lane,         &
                                                    ei, ej,                &
                                                    cross_this_edge_toward )
    class(vv_slice_isoline_t) <io> :: this
    character <in> :: edge_type
    char(len=2) <in> :: cruising_lane
    integer <in> :: ei, ej
    character <in> :: cross_this_edge_toward

    this.head = vv_slice_isoline__element_t( edge_type,               &
                                             cruising_lane,           &
                                             ei,                      &
                                             ej,                      &
                                             cross_this_edge_toward )
  end subroutine vv_slice_isoline__replace_head_direct


  subroutine vv_slice_isoline__register_new_vert( this, u, v )
    class(vv_slice_isoline_t) <io> :: this
    real <in> :: u, v

    integer :: n
    n = this.num + 1
    call ut__assert( n <= size(this.list_u,dim=1),  &
                    '__MODULE__(__LINE__): Increase array size of path_vert.' )

    this.list_u(n) = u
    this.list_v(n) = v
    this.num = n
  end subroutine vv_slice_isoline__register_new_vert


  subroutine jump_to_u_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    !!>  
             __ left
            /       ___ right
           /       /
          o - - - o
              |
            edge_u
    !!<
    integer :: vi_left, vj
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi_left  = ei
    vj = ej

    if ( edge.u_quarter(ei,ej) == VV_SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = edge.u_cross_coord(ei,ej)
      v = vert.pos_v(vj)
      call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v )

      if ( edge.u_is_boundary(ei,ej) ) then
        !            
        !    n  n  P * - - M - - 
        !          .   *   .
        !          .     * .
        octa_direct_along_border = vert.octa_direct(vi_left,vj)
        call ut__assert( octa_direct_along_border >= 0 .and. &
                         octa_direct_along_border <= 7,      &
                         "__MODULE__(__LINE__): " //         &
                         "Not a border vert?" )
        call path.replace_head_edge( vi_left,                  &
                                     vj,                       &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'u', ei, ej ) 
      else
        !     . n     .     
        !     .  n    .       n: next path
        ! - - P - * - M - -
        !     .    *  .
        !     .     * .
        call path.replace_head_edge( 'u', 'in', ei, ej, 'N' ) 
        call edge.erase( 'u', ei, ej )
      end if
    end if
  end subroutine jump_to_u_edge_pm_if_possible


  subroutine jump_to_u_edge_mp_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi_right, vj
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi_right = ei + 1
    vj = ej

    if ( edge.u_quarter(ei,ej) == VV_SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = edge.u_cross_coord(ei,ej)
      v = vert.pos_v(vj)
      call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v )
      if ( edge.u_is_boundary(ei,ej) ) then
        !
        !        . *     .
        !        .  *    .
        !    - - M - * * P n n n
        !
        octa_direct_along_border = vert.octa_direct(vi_right,vj)
        call ut__assert( octa_direct_along_border >= 0 .and. &
                         octa_direct_along_border <= 7,      &
                         "__MODULE__(__LINE__): " //         &
                         "Not a border vert?" )
        call path.replace_head_edge( vi_right,                 &
                                     vj,                       &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'u', ei, ej ) 
      else
        !     . *     .
        !     .  *    .
        ! - - M - * - P - -
        !     .     n .   n: next path
        !     .       n
        call path.replace_head_edge( 'u', 'in', ei, ej, 'S' ) 
        call edge.erase( 'u', ei, ej )
      end if

    end if
  end subroutine jump_to_u_edge_mp_if_possible  


  subroutine jump_to_d_edge_pm_if_possible( path, vert,    &
                                            edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi_ul, vj_ul ! upper-left
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    !!>
              ___ vert(vi_ul,vj_ul)    ul = upper-left
             /
            p - - - - - o
            | n     ____|___ d_edge(ei,ej)
            |   n  /    |
            |     n     |
            |      *.   |
            |     *   . |
            p - -*- - - m
             \
              \__vert(vi,vj)
    !!<

    vi_ul = ei
    vj_ul = ej + 1

    call ut__assert( edge.d_is_boundary(ei,ej), &
                     "assuming now d_edge is boundary." )
         
    if ( edge.d_quarter(ei,ej) == VV_SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = edge.d_cross_coord_u(ei,ej)
      v = edge.d_cross_coord_v(ei,ej)
      call ut__assert( u /= NAN .and. v /= NAN,     &
                       "__MODULE__(__LINE__): " //  &
                       "Invalid cross coord." )
      call path.register_new_vert( u, v )
      octa_direct_along_border = vert.octa_direct(vi_ul,vj_ul)
      call ut__assert( octa_direct_along_border >= 0 .and. &
                       octa_direct_along_border <= 7,      &
                       "__MODULE__(__LINE__): " //         &
                       "Not a border vert?" )
      call path.replace_head_edge( vi_ul,                    &
                                   vj_ul,                    &
                                   octa_direct_along_border, &
                                   'on' )
      call edge.erase( 'd', ei, ej ) 
    end if
  end subroutine jump_to_d_edge_pm_if_possible


  subroutine jump_to_d_edge_mp_if_possible( path, vert,    &
                                            edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi_lr, vj_lr ! upper-left
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    !!>
            m - - * - - p
            | .   *     |
            |   . *     |
            |     *     |
            |       n___|___ d_edge(ei,ej)
            |         n |
            o - - - - - p
             \           \
              \__vert(vi,vj)
                           \
                            \____ vert(vi+1,vj)
    !!<

    call ut__assert( edge.d_is_boundary(ei,ej), &
                     "__MODULE__(__LINE__): " //  &
                     "assuming now d_edge is boundary." )
    vi_lr = ei + 1
    vj_lr = ej 

    if ( edge.d_quarter(ei,ej) == VV_SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = edge.d_cross_coord_u(ei,ej)
      v = edge.d_cross_coord_v(ei,ej)
      call ut__assert( u /= NAN .and. v /= NAN,     &
                       "__MODULE__(__LINE__): " //  &
                       "Invalid cross coord." )
      call path.register_new_vert( u, v )
      octa_direct_along_border = vert.octa_direct(vi_lr,vj_lr)
        call ut__assert( octa_direct_along_border >= 0 .and. &
                         octa_direct_along_border <= 7,      &
                         "__MODULE__(__LINE__): " //         &
                         "Not a border vert?" )
      call path.replace_head_edge( vi_lr,                    &
                                   vj_lr,                    &
                                   octa_direct_along_border, &
                                   'on' )
      call edge.erase( 'd', ei, ej ) 
    end if
  end subroutine jump_to_d_edge_mp_if_possible


  subroutine jump_to_a_edge_pm_if_possible( path, vert,    &
                                            edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi_ll, vj_ll  ! lower-left
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.
    !!>
              
            o - - - - - m
            |         . |
            |       .___|___a_edge(ei,ej)
            |     * * * *
            |   n       |
            | n         |
            p - - - - - p
             \
              \__vert(vi,vj)
    !!<

    vi_ll = ei
    vj_ll = ej

    call ut__assert( edge.a_is_boundary(ei,ej), &
                     "assuming now a_edge is boundary." )
         
    if ( edge.a_quarter(ei,ej) == VV_SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = edge.a_cross_coord_u(ei,ej)
      v = edge.a_cross_coord_v(ei,ej)
      call ut__assert( u /= NAN .and. v /= NAN,     &
                       "__MODULE__(__LINE__): " //  &
                       "Invalid cross coord." )
      call path.register_new_vert( u, v )
      octa_direct_along_border = vert.octa_direct(vi_ll,vj_ll)
        call ut__assert( octa_direct_along_border >= 0 .and. &
                         octa_direct_along_border <= 7,      &
                         "__MODULE__(__LINE__): " //         &
                         "Not a border vert?" )
      call path.replace_head_edge( vi_ll,                    &
                                   vj_ll,                    &
                                   octa_direct_along_border, &
                                   'on' )
      call edge.erase( 'a', ei, ej ) 
    end if
  end subroutine jump_to_a_edge_pm_if_possible


  subroutine jump_to_a_edge_mp_if_possible( path, vert,    &
                                            edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi_ur, vj_ur  ! lower-left
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.
    !!>
              
            m - - * - - p
            |     *   n |
            |     * n___|___a_edge(ei,ej)
            |     *     |
            |   .       |
            | .         |
            m - - - - - o
             \
              \__vert(vi,vj)
    !!<

    vi_ur = ei + 1
    vj_ur = ej + 1

    call ut__assert( edge.a_is_boundary(ei,ej), &
                     "assuming now a_edge is boundary." )
         
    if ( edge.a_quarter(ei,ej) == VV_SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = edge.a_cross_coord_u(ei,ej)
      v = edge.a_cross_coord_v(ei,ej)
      call ut__assert( u /= NAN .and. v /= NAN,     &
                       "__MODULE__(__LINE__): " //  &
                       "Invalid cross coord." )
      call path.register_new_vert( u, v )
      octa_direct_along_border = vert.octa_direct(vi_ur,vj_ur)
        call ut__assert( octa_direct_along_border >= 0 .and. &
                         octa_direct_along_border <= 7,      &
                         "__MODULE__(__LINE__): " //         &
                         "Not a border vert?" )
      call path.replace_head_edge( vi_ur,                    &
                                   vj_ur,                    &
                                   octa_direct_along_border, &
                                   'on' )
      call edge.erase( 'a', ei, ej ) 
    end if
  end subroutine jump_to_a_edge_mp_if_possible


  subroutine jump_to_v_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi, vj_lower
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi = ei
    vj_lower = ej
    if ( edge.v_quarter(ei,ej) == VV_SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = vert.pos_u(vi)
      v = edge.v_cross_coord(ei,ej)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v )

      if ( edge.v_is_boundary(ei,ej) ) then
        !             
        !      .   *   .
        !      M - * - + - -
        !      . *     .
        !      *       .
        !      n       .
        !      P - - - + - -
        !      n       .
        !      n       .
        !
        octa_direct_along_border = vert.octa_direct(vi,vj_lower)
        call ut__assert( octa_direct_along_border >= 0 .and. &
                         octa_direct_along_border <= 7,      &
                         "__MODULE__(__LINE__): " //         &
                         "Not a border vert?" )
        call path.replace_head_edge( vi,                       &
                                     vj_lower,                 &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'v', ei, ej ) 
      else
        !             
        !      .   *   .
        !  - - M - * - + - -
        !      . *     .
        !      *       .
        !    n .       .
        !  n - P - - - + - -
        !      .       .
        call path.replace_head_edge( 'v', 'in', ei, ej, 'W' ) 
        call edge.erase( 'v', ei, ej )
      end if
    end if
  end subroutine jump_to_v_edge_pm_if_possible   


  subroutine jump_to_v_edge_mp_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi, vj_upper
    real :: u, v
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi = ei
    vj_upper = ej + 1

    if ( edge.v_quarter(ei,ej) == VV_SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = vert.pos_u(vi)
      v = edge.v_cross_coord(ei,ej)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v ) 
      if ( edge.v_is_boundary(ei,ej) ) then
        !             
        !   .       n 
        !   .       n 
        !   + - - - P 
        !   .       n
        !   .       *       
        !   .     * .       
        !   + - * - M
        !   .  *    .       
        !
        octa_direct_along_border = vert.octa_direct(vi,vj_upper)
        call ut__assert( octa_direct_along_border >= 0 .and. &
                         octa_direct_along_border <= 7,      &
                         "__MODULE__(__LINE__): " //         &
                         "Not a border vert?" )
        call path.replace_head_edge( vi,                       &
                                     vj_upper,                 &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'v', ei, ej ) 
      else
        !             
        !   .       .     n 
        !   + - - - P - n -
        !   .       . n     
        !   .       *       
        !   .     * .       
        !   + - * - M - - -
        !   .  *    .       
        call path.replace_head_edge( 'v', 'in', ei, ej, 'E' ) 
        call edge.erase( 'v', ei, ej )
      end if
    end if
      
  end subroutine jump_to_v_edge_mp_if_possible 
 

  subroutine leave_from_boundary( vi, vj,        &
                                  octa_direct,   &
                                  ei, ej,        &
                                  edge_type,     &
                                  path_go_toward )
    integer <in> :: vi, vj
    integer <in> :: octa_direct
    integer <out> :: ei, ej
    character <out> :: edge_type
    character <out> :: path_go_toward

    select case (octa_direct)
      case (0)
        edge_type = 'v'
        path_go_toward = 'W'
        ei = vi
        ej = vj
      case (1) 
        edge_type = 'a'
        path_go_toward = 'N'
        ei = vi
        ej = vj
      case (2)
        edge_type = 'u'
        path_go_toward = 'N'
        ei = vi
        ej = vj
      case (3) 
        edge_type = 'd'
        path_go_toward = 'N'
        ei = vi
        ej = vj - 1
      case (4)
        edge_type = 'v'
        path_go_toward = 'E'
        ei = vi
        ej = vj - 1
      case (5) 
        edge_type = 'a'
        path_go_toward = 'S'
        ei = vi - 1
        ej = vj - 1
      case (6)
        edge_type = 'u'
        path_go_toward = 'S'
        ei = vi - 1
        ej = vj
      case (7) 
        edge_type = 'd'
        path_go_toward = 'S'
        ei = vi - 1
        ej = vj
      case default
        call ut__fatal( "__MODULE__(__LINE__) " //  &
                        "case error." )
    end select
    
  end subroutine leave_from_boundary


  subroutine one_step_along_boundary( path, vert, edge, boundary, nth )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    type(vv_slice_mesh__boundary_t) <io> :: boundary
    integer <io> :: nth ! this is nth-vert of the border

    integer :: vi, vj  ! vertex indeces i and j
    integer :: vi2, vj2, nth_next
    integer :: ei, ej  ! edge indeces i and j
    integer :: numbv, quarter
    real :: u2, v2
    integer :: octa_direct
    character :: path_go_toward
    character :: edge_type
    char(len=2) :: cruising_lane

    call ut__assert( path.head.cruising_lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

    !!>
               v1--[e1]--v2--[e2]--v3
              /                    /
            [e6]                 [e3]
            /                    /
           v6--[e5]--v5--[e4]--v4
    !!<

    ei = boundary.edge.ei(nth)
    ej = boundary.edge.ej(nth)
    edge_type = boundary.edge.type(nth)


    call ut__assert(        ei == path.head.ei .and.    &
                            ej == path.head.ej .and.    &
                     edge_type == path.head.edge_type,  &
                     "__MODULE__(__LINE__): " //        &
                     "edge id inconsistent." )

    numbv = boundary.vert.num

    quarter = boundary.edge.quarter(nth)

    if ( quarter == VV_SLICE_MESH__EDGE_PP ) then
      !!>
                 .            
                 .            
                 .            
             - - p <== You are going to register this vert (vi2,vj2)
                 *
                 * <== You are going to replace by this edge.
                 *            
             - - p <== present num, present (vi,vj)
                 . \_____ previous (vi2,vj2), lastly registered vert
                 . <== previous head edge
                 . 
             - - p <== previous (vi,vj)
                 .            
      !!<      
      nth_next = nth + 1
      if ( nth_next > numbv ) nth_next -= numbv ! cyclic.
      vi2 = boundary.vert.vi(nth_next)
      vj2 = boundary.vert.vj(nth_next)
      u2 = vert.pos_u(vi2)
      v2 = vert.pos_v(vj2)
      call path.register_new_vert( u2, v2 )
      call boundary.edge.erase( nth )
      call edge.erase( edge_type, ei, ej ) 
      octa_direct = boundary.vert.octa_direct(nth_next)
      cruising_lane = 'on'
      call path.replace_head_edge( vi2, vj2, octa_direct, cruising_lane )
      nth = nth_next
    else if ( quarter == VV_SLICE_MESH__EDGE_PM ) then
      !!>
                 .
                 .            
             - - p  _____ you are going to register this point
                 . /
             * * * <== present head edge
                 *            
             - - p <== present num, present (vi,vj)
                 . \_____ previous (vi2,vj2), lastly registered vert
                 . <== previous head edge
                 . 
             - - p <== previous (vi,vj)
                 .            
      !!<
      u2 = boundary.edge.cross_coord_u(nth)
      v2 = boundary.edge.cross_coord_v(nth)
      call ut__assert( u2 /= NAN .and. v2 /= NAN,   &
                       "__MODULE__(__LINE__): Invalid cross coord." )

      call path.register_new_vert( u2, v2 )
      call boundary.edge.erase( nth )
      call edge.erase( edge_type, ei, ej ) 
      octa_direct = boundary.vert.octa_direct(nth)
      vi = boundary.vert.vi(nth)
      vj = boundary.vert.vj(nth)
      call leave_from_boundary( vi, vj,         &
                                octa_direct,    &
                                ei, ej,         &
                                edge_type,      &
                                path_go_toward )
      cruising_lane = 'in'
      call path.replace_head_edge( edge_type,      &
                                   cruising_lane,  &
                                   ei,             &
                                   ej,             &
                                   path_go_toward )
    else
      call ut__fatal( '__MODULE__(__LINE__): Strange. Path terminated?' )
    end if

  end subroutine one_step_along_boundary


  subroutine jump_to_other_edge_from_edge_uv( path,  &
                                              vert,  &
                                              edge )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge

    integer :: ei, ej
    logical :: jumped
    call ut__assert( path.head.edge_type == 'u' .or.   &
                     path.head.edge_type == 'v',       &
                     "__MODULE__(__LINE__): " //       &
                     "head is to be u_ or v_edge." )
    call ut__assert( path.head.cruising_lane == 'in',  &
                     "__MODULE__(__LINE__): The path should be in the region." )

    jumped = .false.  ! Default.

    ei = path.head.ei
    ej = path.head.ej

    select case (path.head.path_go_toward)
      !!>
                        edge.u(ei,ej+1)
                            .
                 vertex     .     vertex
                 (vi,vj+1)  .     (vi+1,vj+1)
                       \    .    /
                        + - - - +
                        | \   / |
        edge.v(vi,vj) --|   x   |-- edge.v(ei+1,ej)
                        | /   \ |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (vi,vj) .    (vi+1,vj)
                            .
                        edge.u(ei,ej)
      !!<
      case ('N')
        call ut__assert( path.head.edge_type == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )

        if ( edge.d_is_boundary(ei,ej) ) then
          call jump_to_d_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                         !!>
                              p - - - - o
                              | n       |
                              |   n To  |
                              |    *.   |
                              |   *   . |
                              p -*- - - m
                                From 
                         !!<
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                         !!>
                              m - - - - o
                              | .       |
                           To *   .     |
                              | *   .   |
                              |   *   . |
                              p - - * - m
                                  From 
                         !!<
        else if ( edge.a_is_boundary(ei,ej) ) then
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej )
                         !!>
                              o - - - - p
                              |       . |
                              |     .   | 
                              |   .     * To
                              | .     * |
                              p - - * - m
                                  From 
                         !!<
          call jump_to_a_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                         !!>
                              o - - - - m
                              |    To . |
                              |     *   |
                              |   n *   |
                              | n   *   |
                              p - - * - m
                                  From 
                         !!<
        else  
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej )
                           !!>
                                p - - p
                                |    *|To
                                |   * |
                                p -*- m
                                  From 
                           !!<
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej+1 )
                           !!>
                                  To
                                p -*- m
                                |  *  |
                                |  *  |
                                p -*- m
                                  From 
                           !!<
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                           !!>
                                m - - m
                              To*     |
                                | *   |
                                p - * m
                                  From 
                           !!<
        end if
      case ('W')
        call ut__assert( path.head.edge_type == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )

        if ( edge.a_is_boundary(ei-1,ej) ) then
          call jump_to_a_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei-1, ej )
                         !!>
                              + - - - - m
                              |       . |
                              | To  .   | From
                              |   * * * *
                              | n       |
                              p - - - - p
                                
                         !!<
          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei-1, ej )
                         !!>
                              o - - - - m
                              |       . |
                              |     .   * From
                              |   .   * |
                              | .   *   |
                              m - * - - p
                                  To
                         !!<
        else if ( edge.d_is_boundary(ei-1,ej) ) then
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei-1, ej+1 )
                         !!>
                                 To
                              p - * - - m
                              | .   *   |
                              |   .   * | 
                              |     .   * From
                              |       . |
                              o - - - - p
                         !!<
          call jump_to_d_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei-1, ej )
                         !!>
                              m - - - - m
                              | .       |
                              |To * * * * From
                              |     n   |
                              |       n |
                              o - - - - p
                         !!<
        else  
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei-1, ej+1 )
                         !!>
                                  To
                                p -*- m
                                |   * |
                                |    *|From
                                p - - p
                         !!<
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei-1, ej )
                         !!>
                                m - - m
                                |     |
                              To|* * *|From
                                p - - p
                         !!<

          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei-1, ej )
                         !!>
                                m - - m
                                |    *|
                                |   * |From
                                m -*- p
                                  To
                         !!<
        end if
      case ('S')
        call ut__assert( path.head.edge_type == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )

        if ( edge.d_is_boundary(ei,ej-1) ) then
          call jump_to_d_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej-1 )
                         !!>
                                 From
                              m - * - - p
                              | . *     |
                              |   *     |
                              |  To n   |
                              |       n |
                              o - - - - p
                         !!<
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej-1 )
                         !!>
                                 From
                              m - * - - p
                              | .   *   |
                              |   .   * | To
                              |     .   *
                              |       . |
                              o - - - - m
                         !!<
        else if ( edge.a_is_boundary(ei,ej-1) ) then
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej-1 )
                         !!>
                                   From
                              m - - * - p
                              |   *   . |
                              | *   .   |
                           To *   .     |
                              | .       |
                              p - - - - o
                                
                         !!<
          call jump_to_a_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej-1 )
                         !!>
                                 From
                              m - * - - p
                              |   *   n |
                              |   * n   |
                              |   *     |
                              | . To    |
                              m - - - - o
                               
                         !!<
        else  
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej-1 )
                         !!>
                                  From
                                m -*- p
                                | *   |
                             To |*    |
                                p - - p
                         !!<
          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej-1 )
                         !!>
                                  From
                                m -*- p
                                |  *  |
                                |  *  |
                                m -*- p
                                   To
                         !!<
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej-1 )
                         !!>
                                  From
                                m -*- p
                                |   * |
                                |    *|To
                                m - - m
                         !!<
        end if
      case ('E')
        call ut__assert( path.head.edge_type == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )

        if ( edge.d_is_boundary(ei,ej) ) then
          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                         !!>
                              p - - - - o
                              | .       |
                         From *   .     |
                              | *   .   |
                              |   *   . |
                              m - - * - p
                                    To
                         !!<
          call jump_to_d_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                         !!>
                              p - - - - o
                              | n       |
                              |   n     |
                         From * * * *To |
                              |       . |
                              m - - - - m
                                
                         !!<
        else if ( edge.a_is_boundary(ei,ej) ) then
          call jump_to_a_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                         !!>
                              p - - - - p
                              |       n |
                         From * * * n   |
                              |   .     |
                              | .       |
                              m - - - - o
                         !!<
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej+1 )
                         !!>
                                    To
                              p - - * - m
                              |   *   . |
                              | *   .   |
                         From *   .     |
                              | .       |
                              m - - - - o
                         !!<
        else  


          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
                         !!>
                                p - - p
                           From *     |
                                |*    |
                                m * - p
                                  To
                         !!<
          call jump_to_v_edge_mp_if_possible ( path, vert, edge,  &
                                              jumped, ei+1, ej )
                         !!>
                                p - - p
                           From * * * * To
                                |     |
                                m - - m
                         !!<
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej+1 )
                         !!>
                                  To
                                p * - m
                                |*    |
                           From *     |
                                m - - m
                         !!<
        end if
      case default
        call ut__fatal( '__MODULE__(__LINE__): case error.' )
    end select

    call ut__assert( jumped,  &
                     "__MODULE__(__LINE__): Failed to find next path." )
  end subroutine jump_to_other_edge_from_edge_uv



  subroutine jump_to_other_edge_from_edge_ad( path,  &
                                              vert,  &
                                              edge )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge

    integer :: ei, ej
    logical :: jumped

    call ut__assert( path.head.cruising_lane == 'in',  &
                     "__MODULE__(__LINE__): The path should be in the region." )

    jumped = .false.  ! Default.

    ei = path.head.ei
    ej = path.head.ej

    select case (path.head.edge_type)
      case ('a')
        if ( path.head.path_go_toward == 'N' ) then
          !!>                     
               vertex(i,j+1)=> P - * - M
                               |   * . |
                               |   *   |
                               | *     |
                vertex(i,j) => P - - - + 
          !!<
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej+1 )
          !!>
               vertex(i,j+1)=> M - - - M
                               |     . |
                               * * *   |
                               | *     |
                vertex(i,j) => P - - - + 
          !!<
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
        else if ( path.head.path_go_toward == 'S' ) then
          !!>                     
               vertex(i,j+1)=> + - - - P
                               |     * |
                               |   *   |
                               | . *   |
                vertex(i,j) => M - * - P 
          !!<
          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
          !!> 
               vertex(i,j+1)=> M - - - P
                               |     * |
                               |   * * *
                               | .     |
                vertex(i,j) => M - - - M 
          !!<
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej )
        else 
          call ut__fatal( "__MODULE__(__LINE__): arg error." )
        end if
      case ('d')
        if ( path.head.path_go_toward == 'N' ) then
          !!>
               vertex(i,j+1)=> P - - - P
                               | *     |
                               |   * * *
                               |     . |
                vertex(i,j) => + - - - M 
          !!<
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej )
          !!>                     
               vertex(i,j+1)=> P - - * M
                               | *  *  |
                               |   *   |
                               |     . |
                vertex(i,j) => + - - - M 
          !!<
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej+1 )
        else if ( path.head.path_go_toward == 'S' ) then
          !!> 
               vertex(i,j+1)=> M - - - +
                               | .     |
                               * * *   |
                               |     * |
                vertex(i,j) => P - - - P 
          !!<
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
          !!>                     
               vertex(i,j+1)=> M - - - +
                               | .     |
                               |   *   |
                               |  *  * |
                vertex(i,j) => M * - - P 
          !!<
          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
        else 
          call ut__fatal( "__MODULE__(__LINE__): arg error." )
        end if
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

    call ut__assert( jumped,  &
                     "__MODULE__(__LINE__): Failed to find next path." )
  end subroutine jump_to_other_edge_from_edge_ad


  function vv_slice_isoline__is_closed( this ) result(ans)
    class(vv_slice_isoline_t) <in> :: this
    logical :: ans

    logical :: con1, con2, con3

    con1 = ( this.head.edge_type == this.start.edge_type )
    con2 = ( this.head.ei == this.start.ei )
    con3 = ( this.head.ej == this.start.ej )
    ans = ( con1 .and. con2 .and. con3 )
  end function vv_slice_isoline__is_closed  


  subroutine vv_slice_isoline__reset( this )
    class(vv_slice_isoline_t) <io> :: this
    this.num = 0
    this.list_u(:) = 0.0
    this.list_v(:) = 0.0
  end subroutine vv_slice_isoline__reset


  subroutine vv_slice_isoline__initialize( this, vert_nu, vert_nv )
    class(vv_slice_isoline_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv
      ! extreme case like a Peano path

    allocate(this.list_u(max_path_element_num))
    allocate(this.list_v(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call this.reset
  end subroutine vv_slice_isoline__initialize


  subroutine find_start_edge_on_boundaries( path,     &
                                            vert,     &
                                            boundary, &
                                            status )
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__boundary_t) <io> :: boundary
    char(len=10) <io> :: status ! 'no contour' or 'have found'


    !!>
             |       |       |    _ Contour line     | 
           - m - - - m - - - m   /    at "level" - - m
             |       |       * */                    |
             |       |    *  |   *   |       |       |      
           - m - - - m -*- - p - - * m - - - m - - - m   ej=3
             |       *       |       *       |       |
             |     * |       |       | *     |       |
           - m - -*- p - - - p - - - p - * - m - - - m   ej=2
             |    *  |       |       |    *  |       |
             |    *  |       |       |    *  |       |
           - m - - * p * * * p * * * p * * - m - - - m   ej=1
                 \
                  \__ Will find this edge_u


        We will search for the start edge in this order,
           1. South border
           2. East border
           3. North border
           4. West border

                       <---
                   +----------+
                   |  North   |    
               |  W|          |E   ^
               |  e|          |a   |
               v  s|          |s   |
                  t|  South   |t    
                   +----------+
                       ---> 
    !!<    

    integer :: quarter
    integer :: vert_index1, vert_index2
    integer :: edge_index, ei, ej
    integer :: octa_direct
    real :: u1, v1, u2, v2
    char(len=2) :: cruising_lane
    character :: path_go_toward
    character :: edge_type

    call ut__assert( path.num == 0,  &
                    '__MODULE__(__LINE__): You forgot to reset vv_slice_isoline.' )

    do edge_index = 1, boundary.edge.num
      quarter = boundary.edge.quarter(edge_index)
      if ( quarter == VV_SLICE_MESH__EDGE_PP  .or.  &
           quarter == VV_SLICE_MESH__EDGE_PM ) then
        status = 'have found'
        vert_index1 = edge_index
        u1 = vert.pos_u(boundary.vert.vi(vert_index1))
        v1 = vert.pos_v(boundary.vert.vj(vert_index1))
        call path.register_new_vert( u1, v1 )

        if ( quarter == VV_SLICE_MESH__EDGE_PP ) then
          vert_index2 = vert_index1 + 1 ! next vert in the border path
          if ( vert_index2 > boundary.vert.num )  &
               vert_index2 -= boundary.vert.num
          u2 = vert.pos_u(boundary.vert.vi(vert_index2))
          v2 = vert.pos_v(boundary.vert.vj(vert_index2))
          edge_type = boundary.edge.type(edge_index)
          cruising_lane = 'on'
          ei = boundary.edge.ei(edge_index)
          ej = boundary.edge.ej(edge_index)
        else ! quarter == VV_SLICE_MESH__EDGE_PM
          u2 = boundary.edge.cross_coord_u(edge_index)
          v2 = boundary.edge.cross_coord_v(edge_index)
          call ut__assert( u2 /= NAN .and. v2 /= NAN,  &
                           "__MODULE__(__LINE__): Invalid cross coord." )
          cruising_lane = 'in'
          call leave_from_boundary( boundary.vert.vi(vert_index1),          &
                                    boundary.vert.vj(vert_index1),          &
                                    boundary.vert.octa_direct(vert_index1), &
                                    ei, ej,                                 &
                                    edge_type,                              &
                                    path_go_toward )
        end if

        call path.register_new_vert( u2, v2 )
        octa_direct = boundary.vert.octa_direct(vert_index1)
        call path.replace_head_edge( edge_type,      &
                                     cruising_lane,  &
                                     ei,             &
                                     ej,             &
                                     path_go_toward )
        path.start = path.head
        return
      end if
    end do

  end subroutine find_start_edge_on_boundaries


  subroutine find_start_edge_in_bulk( path,    &
                                      vert,    &
                                      edge,    &
                                      status )  
    type(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'

    !!>
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m -*- - p - - * m - - - m -  
             |       *       |       *       |   
             |     * |       |       |*      |   
           - m - -*- p - - - p - - - p * - - m -  
             |    *  |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |      *|       |       |*      |   
             |       *       |       *       |   
           - m - - - m * - - P=====*=M - - - m -  
             |       |    *  |  * \  |       |   
             |       |       *     \ |       |   
           - m - - - m - - - m - - -\m - - - m -  
             |       |       |       \       |   
                                      \
                                       \___ Try to find this edge with "PM".
                 
    !!< 
    integer :: ei, ej      ! index of edge position
    integer :: vj ! index of vert position
    integer :: quarter
    real :: u, v

    call ut__assert( path.num == 0,                     &
                    '__MODULE__(__LINE__): ' //         &
                    'Forgot to reset vv_slice_isoline.' )

    !!>
        The rectangular edges of v_edge(1,:), u_edge(:,1), etc. 
        cannot be 'i' grid, i.e., inside the border.
    !!<
    do ej = 2, edge.u_nv-1
      vj = ej
      do ei = 2, edge.u_nu-1
        quarter = edge.u_quarter(ei,ej)
        if ( quarter == VV_SLICE_MESH__EDGE_PM ) then
          !!> 
               path tip you
               have just found.  *
                         |    \ *      |
                       --p=====*-------m--
                         |    *        |
              contour ---|-->*         |
                         |  *          |
                         | *           |
          !!<
          status = 'have found'
          u = edge.u_cross_coord(ei,ej)
          v = vert.pos_v(vj)
          call ut__assert( u /= NAN,                    &
                           "__MODULE__(__LINE__): " //  &
                           "Invalid cross coord." )
          call path.register_new_vert( u, v )
          call path.replace_head_edge( 'u', 'in', ei, ej, 'N' )
          path.start = path.head
          return
        end if
      end do
    end do

  end subroutine find_start_edge_in_bulk


  subroutine vv_slice_isoline__set_start_edge( this,     &
                                               vert,     &
                                               edge,     &
                                               boundary, &
                                               status )
    class(vv_slice_isoline_t) <io> :: this
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__edge_t) <io> :: edge
    type(vv_slice_mesh__boundary_t) <io> :: boundary
    char(len=10) <out> :: status ! 'no contour' or 'have found'

    status = 'no contour'  ! default 
    call find_start_edge_on_boundaries( this,     &
                                        vert,     &
                                        boundary, &
                                        status )
    if ( status == 'have found' ) return

    call find_start_edge_in_bulk( this,    &
                                  vert,    &
                                  edge,    &
                                  status )

  end subroutine vv_slice_isoline__set_start_edge


  subroutine vv_slice_isoline__trace_and_erase( path,      &
                                                vert,      &
                                                edge,      &
                                                boundary )
    class(vv_slice_isoline_t) <io> :: path
    type(vv_slice_mesh__vert_t) <in> :: vert
    type(vv_slice_mesh__boundary_t) <io> :: boundary
    type(vv_slice_mesh__edge_t) <io> :: edge

    integer :: nthbe ! nth of border edge
    integer :: nthbv ! nth of border vert
    logical :: start_flag_of_cruising_on_border
    integer :: nthbe_start_path

    start_flag_of_cruising_on_border = .true.
    do
      select case (path.head.cruising_lane)
        case ('on')
          if ( start_flag_of_cruising_on_border ) then
            ! newly start tracing on the border.
            nthbe = boundary.edge.get_nth( path.head.edge_type,  &
                                           path.head.ei,         &
                                           path.head.ej )
            nthbe_start_path = nthbe
            nthbv = nthbe  ! same number
              !    v1 - - - v2 - - - v3 - - - v4 - ...
              !         e1       e2       e3  ...
            start_flag_of_cruising_on_border = .false.
          end if
          call one_step_along_boundary( path, vert, edge, boundary, nthbv )
          if ( path.is_closed() ) then
            call boundary.edge.erase( nthbe_start_path )
            call edge.erase( path.start.edge_type,  &
                             path.start.ei,         &
                             path.start.ej ) 
            return
          end if
        case ('in')
          if ( path.head.edge_type == 'u' .or.  &
               path.head.edge_type == 'v'  ) then
            call jump_to_other_edge_from_edge_uv( path, vert, edge )
          else
            call jump_to_other_edge_from_edge_ad( path, vert, edge )
          end if
          start_flag_of_cruising_on_border = .true.
          if ( path.is_closed() ) then
            call edge.erase( path.start.edge_type,  &
                             path.start.ei,         &
                             path.start.ej ) 
            return
          end if
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
    end do

  end subroutine vv_slice_isoline__trace_and_erase

end module vv_slice_isoline_m
