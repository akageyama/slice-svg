module color_m
  use ut_m
  implicit none
  private
  public :: COLOR__CONST
  public :: color__normalized_real_to_color


  type, public :: color_t ! basic color type
    real :: r, g, b       ! float 0.0 to 1.0
  contains
    procedure :: to_code => color__to_code
    procedure :: to_byte => color__to_byte
  end type color_t

  type, public :: color__byte_t 
    integer :: r, g, b   ! 0 to 255
  end type color__byte_t

  type, public :: color__hsv_t
    real :: hue, sat, val
  contains
    procedure :: to_rgb => color__hsv__to_rgb
  end type color__hsv_t

  type, public :: color__const_t
    type(color_t) :: white   = color_t(1.0, 1.0, 1.0)
    type(color_t) :: black   = color_t(0.0, 0.0, 0.0)
    type(color_t) :: red     = color_t(1.0, 0.0, 0.0)
    type(color_t) :: green   = color_t(0.0, 1.0, 0.0)
    type(color_t) :: blue    = color_t(0.0, 0.0, 1.0)
    type(color_t) :: magenta = color_t(1.0, 0.0, 1.0)
    type(color_t) :: yellow  = color_t(1.0, 1.0, 0.0)
    type(color_t) :: cyan    = color_t(0.0, 1.0, 1.0)
  contains
    procedure :: gray => color_const__gray
    procedure, pass :: test_print => color__const__test_print
  end type color__const_t

  type(color__const_t), protected :: COLOR__CONST


contains

  function color__hsv__to_rgb( this ) result(rgb)  
    class(color__hsv_t) <in> :: this
    type(color_t) :: rgb

    real :: h, s, v
    real :: r, g, b
    integer :: hue6
    real    :: f, p, q, t
  
    h = this.hue
    s = this.sat
    v = this.val

    call iClip( h )
    call iClip( s )
    call iClip( v )
  
    if( s == 0.0 ) then
      rgb.r = v
      rgb.g = v
      rgb.b = v
      return
    end if
  
    if( h == 1.0 ) then
      h = 0.0
    end if
  
    h *= 6.0
    hue6 = int(h)
    f = h - hue6
    p = v*(1.0-s)
    q = v*(1.0-(s*f))
    t = v*(1.0-(s*(1-f)))
  
    select case (hue6)
      case (0) 
        r=v; g=t; b=p
      case (1) 
        r=q; g=v; b=p
      case (2) 
        r=p; g=v; b=t
      case (3) 
        r=p; g=q; b=v
      case (4) 
        r=t; g=p; b=v
      case (5) 
        r=v; g=p; b=q
      case default
    end select
  
    rgb.r = r
    rgb.g = g
    rgb.b = b

  contains
  
    subroutine iClip( val )
      real <io> :: val
  
      if ( val < 0.0 ) val = 0.0
      if ( val > 1.0 ) val = 1.0
    end subroutine iClip

  end function color__hsv__to_rgb

  function color__normalized_real_to_color( value ) result(col)
    real <in> :: value
    type(color_t) :: col

    char(len=7) :: code ! '#FFFFFF' for white

    type(color__hsv_t) :: hsv

!debugp value
    call ut__assert( value >= 0.0 .and. value <= 1.0,  &
                    '__MODULE__(__LINE__): Normalized value out of range.' )

    hsv.hue = 0.3 + 0.5 * value
    hsv.sat = 0.7
    hsv.val = 0.6

    col = hsv.to_rgb()

  end function color__normalized_real_to_color


  subroutine color__const__test_print( this )
    class(color__const_t) <in> :: this

    type(color_t) :: gray_0p5, gray_0p8

    call ut__message( '===<COLOR__CONST available color list>===' )
    call iPrint( '        white', COLOR__CONST.white   )
    call iPrint( '        black', COLOR__CONST.black   )
    call iPrint( '          red', COLOR__CONST.red     )
    call iPrint( '        green', COLOR__CONST.green   )
    call iPrint( '         blue', COLOR__CONST.blue    )
    call iPrint( '      magenta', COLOR__CONST.magenta )
    call iPrint( '       yellow', COLOR__CONST.yellow  )
    call iPrint( '         cyan', COLOR__CONST.cyan    )

    gray_0p5 = COLOR__CONST.gray( 0.5 )
    gray_0p8 = COLOR__CONST.gray( 0.8 )

    call iPrint( '    gray(0.5)', gray_0p5 )
    call iPrint( '    gray(0.8)', gray_0p8 )
    call ut__message( '===</COLOR__CONST available color list>===' )


  contains

    subroutine iPrint( message, col )
      char(len=*) <in> :: message
      type(color_t) <in> :: col

      char(len=7) :: code

      code = col.to_code()
      call ut__message( trim(message) // ' (' // code // ')' )
    end subroutine iPrint        

  end subroutine color__const__test_print


  function color_const__gray( this, whiteness ) result(gray)
    class(color__const_t) <in> :: this
    real <in> :: whiteness
    type(color_t) :: gray

    real :: w
    w = max(0.0, whiteness)
    w = min(1.0, w)
    gray = color_t(w, w, w)
  end function color_const__gray


  function color__to_code( rgb ) result(code) 
    class(color_t) <in> :: rgb ! e.g., rgb=(1.0, 0.0, 0.0)
    char(len=7) :: code        !          ==> '#FF0000'

    type(color__byte_t) :: byte

    byte = rgb.to_byte()

    write(code,"('#'3(Z2.2))") byte.r, byte.g, byte.b
  end function color__to_code


  function color__to_byte( rgb ) result(rgb_byte)
    class(color_t) <in> :: rgb     ! e.g., rgb=(1.0, 0.0, 0.0)
    type(color__byte_t) :: rgb_byte !            ==>(255, 0, 0)

    integer :: r, g, b

    r = nint(255*rgb.r)
    g = nint(255*rgb.g)
    b = nint(255*rgb.b)    
    rgb_byte = color__byte_t(r,g,b)
  end function color__to_byte

end module color_m
