module sketch_m
  use color_m
  use svglib_m
  use ut_m
  implicit none
  private

  type, public :: sketch_pos_t
    real :: u, v
  end type sketch_pos_t

  type screen_pos_t
    real :: x, y
  end type screen_pos_t

  type screen_size_t
    real :: width, height
    real :: margin_x, margin_y
  end type screen_size_t

  type, public :: sketch_t
    type(screen_size_t) :: screen_size
    real :: u_max, u_min, v_max, v_min
    real :: dxdu, dydv
    char(len=300) :: title
    char(len=300) :: filename
    type(svglib_t) :: svglib
  contains
    procedure :: initialize => sketch__initialize
    procedure :: finalize => sketch__finalize
    procedure :: to_screen_pos => sketch__to_screen_pos
    procedure :: group_begin => sketch__group_begin
    procedure :: group_end => sketch__group_end
  end type sketch_t


contains


  subroutine sketch__group_begin( this, line_type,            &
                                        line_width_in_pixel,  &
                                        line_color,           &
                                        line_opacity,         &
                                        fill_color,           &
                                        fill_opacity )
    class(sketch_t) <io> :: this
    char(len=6) <optin> :: line_type  ! 'dotted' or
                                      ! 'dashed'
    real <optin> :: line_width_in_pixel
    real <optin> :: line_opacity
    type(color_t) <optin> :: line_color
    type(color_t) <optin> :: fill_color
    real <optin> :: fill_opacity

    integer :: nop ! number of options
    integer <const> :: MAX_NOP = 20
    char(len=SVGLIB__BSL), dimension(MAX_NOP) :: str
    char(len=SVGLIB__BSL*MAX_NOP) :: str_long
    integer :: n

    call iClear_str

    if ( present(line_color) ) then
      nop += 1
      str(nop) = 'line-color=' // line_color.to_code()
    end if

    if ( present(fill_color) ) then
      nop += 1
      str(nop) = 'fill-color=' // fill_color.to_code()
    end if

    if ( present(line_width_in_pixel) ) then
      nop += 1
      str(nop) = svglib__text_line( 'line-width=', line_width_in_pixel )
    end if

    if ( present(line_opacity) ) then
      nop += 1
      str(nop) = svglib__text_line( 'line-opacity=', line_opacity )
    end if    

    if ( present(fill_opacity) ) then
      nop += 1
      str(nop) = svglib__text_line( 'fill-opacity=', fill_opacity )
    end if    

    if ( present(line_type) ) then
      nop += 1
      select case (line_type)
        case ('dotted')
          str(nop) = 'stroke-width="5 5"'
        case ('dashed')
          str(nop) = 'stroke-width="10 5"'
        case default
          call ut__fatal( '__MODFUNC__: case error.' )
      end select
    end if    

    if ( nop > 0 ) then
      str_long = ''
      do n = 1, nop
        str_long = trim(str_long) // trim(str(n)) // ' '
      end do
      call this.svglib.group_begin( trim(str_long) )
    end if

  contains

    subroutine iClear_str
      nop = 0
      str(:) = ''
    end subroutine iClear_str

  end subroutine sketch__group_begin


  subroutine sketch__group_end( this )
    class(sketch_t) <io> :: this

    call this.svglib.group_end
  end subroutine sketch__group_end


  subroutine sketch__text( this, u, v,                &
                                 string,              &
                                 font_size_in_pixel,  &
                                 text_anchor,         &
                                 color )

    real <in> :: u, v
    char(len=*) <in> :: string
    real <in> :: font_size_in_pixel
    char(len=*) <in> :: text_anchor   ! start/ middle / end
    type(clor_t) <optin> :: color

    type(screen_pos_t) :: pos
    char(len=SVGLIB__BSL) :: str_text_anchor

    pos = this.to_screen_pos( sketch_pos_t(u,v) )
    
    if ( present(text_anchor) ) then
      str_text_anchor = text_anchor
    else 
      str_text_anchor = 'middle'  ! default
    end if

    if ( present(color) ) then
      color_code = color.to_code()
      call this.svglib.text( pos.u, pos.v,        &
                             string,              &
                             font_size_in_pixel,  &
                             color_code )
    else
      call this.svglib.text( pos.u, pos.v,        &
                             string,              &
                             font_size_in_pixel )
    end if
  end subroutine sketch__text

  subroutine sketch__line( this, u1, v1,  &
                                 u2, v2,  &
                                 width,   &
                                 color )
    class(sketch_t) <in> :: this
    real <in> :: u1, v1 ! line start position in simulation coords.
    real <in> :: u2, v2 ! line finish position in simulation coords.
    real <in> :: width
    type(color_t) <optin> :: color

    char(len=7) :: color_code

    type(screen_pos_t) :: start, finish

    start  = this.to_screen_pos( sketch_pos_t(u1,v1) )
    finish = this.to_screen_pos( sketch_pos_t(u2,v2) )

    if ( present(color) ) then
      color_code = color.to_code()
    else
      color_code = COLOR__CONST.black.to_code()
    end if
    call this.svglib.line( start.x,  start.y,   &
                           finish.x, finish.y,  &
                           color_code,          &
                           width )

  end subroutine sketch__line


  function sketch__to_screen_pos( this, sketch_pos ) result(screen_pos)
    class(sketch_t) <in> :: this
    type(sketch_pos_t) <in> :: sketch_pos
    type(screen_pos_t) :: screen_pos

    !!>
                 umin   u           umax
             . mx .     .            .    
         .....____._____.____________.____
          my |    .     .            .    |
             |    +$ $ $. $ $ $ $ $ U-R...|...vmax
             |    $     .            $    |  .\
             |    $     .            $    |  . delta_v
             |    $     .            $    |  ./
             |    $.....*............$....|...v
             |    $     .\__(u,v)    $    |
             |    $     .            $    |
             |...L-L $ $.$ $ $ $ $ $ $....|...vmin
             |____._____._________________|
                  .     . 
                  .......
                  delta_u
    !!<
    real :: delta_u, delta_v 
    real :: mx, my   ! margin x and y
    delta_u = sketch_pos.u - this.u_min
    delta_v = this.v_max - sketch_pos.v
    mx = this.screen_size.margin_x
    my = this.screen_size.margin_y
    screen_pos.x = mx + this.dxdu*delta_u
    screen_pos.y = my + this.dydv*delta_v
  end function sketch__to_screen_pos


  subroutine sketch__initialize( this,                  &
                                 lower_left_in_phys,    &
                                 upper_right_in_phys,   &
                                 screen_width_in_pixel, &
                                 title,                 &
                                 filename )
    class(sketch_t) <out> :: this
    type(sketch_pos_t) <in> :: lower_left_in_phys,  &
                               upper_right_in_phys
    real <in> :: screen_width_in_pixel
    char(len=*) <in> :: title
    char(len=*) <in> :: filename

    real :: draw_area_width_in_phys,   &
            draw_area_height_in_phys
    real :: draw_area_width_in_pixel,  &
            draw_area_height_in_pixel
    real :: aspect_ratio
    real :: u_max, u_min, v_max, v_min

    u_max = upper_right_in_phys.u
    u_min =  lower_left_in_phys.u
    v_max = upper_right_in_phys.v
    v_min =  lower_left_in_phys.v

    call ut__assert( u_max > u_min .and.  &
                     v_max > v_min,       &
                     '__MODFUNC__: size error.' )

    this.title = title
    this.filename = filename

    !!>
        In the following fig, 
           L = lower_left (in meters),
           U = upper_right (in meters),
        are coordinates in the simulation
        data with physical unit, such as meters.

          mx = margin in x (in pixels)
          my = margin in y (in pixels)
              
             | mx |                  | mx |
         --- +----------------------------+---
          my |    |      title       |    |    \
         --- | ---+------------------U--- |     s  
             |    |                  |    |     c h
             |    |                  |    |     r e
             |    |                  |    |     e i
             |    |                  |    |     e h
         --- | ---L------------------+--- |     n g
          my |    |                  |    |    /  t
         --- +----------------------------+---     .
             |                            |         .
             |<------ screen width ------>|    (in pixels)
                      (in pixels)
    !!<

    draw_area_width_in_phys = u_max - u_min
    draw_area_height_in_phys = v_max - v_min
    aspect_ratio = draw_area_height_in_phys  &
                 / draw_area_width_in_phys

    this.screen_size.width = screen_width_in_pixel
    this.screen_size.margin_x = 0.1*screen_width_in_pixel
    this.screen_size.margin_y = this.screen_size.margin_x 

    ! Keeping the aspect ratio,
    draw_area_width_in_pixel = screen_width_in_pixel     &
                             - 2*this.screen_size.margin_x
    draw_area_height_in_pixel = draw_area_width_in_pixel &
                              * aspect_ratio
    this.screen_size.height = draw_area_height_in_pixel  &
                            + 2*this.screen_size.margin_y

    this.dxdu = this.screen_size.width  / draw_area_width_in_phys   
    this.dydv = this.screen_size.height / draw_area_height_in_phys

    call ut__assert( this.dxdu > 0.0 .and. &
                     this.dydv > 0.0,      &
                     '__MODFUNC__: Something is strange.' )

    call this.svglib.open( this.filename,           &
                           this.screen_size.width,  &
                           this.screen_size.height )

  end subroutine sketch__initialize


  subroutine sketch__finalize( this )
    class(sketch_t) <in> :: this

    call this.svglib.close
  end subroutine sketch__finalize

end module sketch_m