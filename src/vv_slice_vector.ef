module vv_slice_vector_m
  !!>
      vv_slice: Visualize 2-dimensional cross sections 
      of 3- (or more) dimensional simulation data.

      Draw vector arrow glyphs for vector fields.
      
      In this module, positions are specified by the
      simulation coordinates (u,v) with simulation unit
      such as meters.

  !!< 
  use vv_color_m
  use ut_m
  use vv_slice_mesh_m
  use vv_slice_isoline_m
  use vv_sketch_m
  implicit none
  private

  integer <const> :: TAG_NAME_MAX = 100

  type, public :: vv_slice_vector_t
    char(len=TAG_NAME_MAX) :: tag
    type(vv_slice_mesh__vert_t) :: mesh_vert
    type(vv_slice_mesh__edge_t) :: mesh_edge
    type(vv_slice_mesh__boundary_t) :: mesh_boundary
    real, dimension(:,:), allocatable :: comp_u
    real, dimension(:,:), allocatable :: comp_v
    real :: amp_max, amp_min
  contains
    procedure, private :: vv_slice_vector__initialize_with_uvmax
    procedure, private :: vv_slice_vector__initialize_with_grids
    generic :: initialize => vv_slice_vector__initialize_with_uvmax,  &
                             vv_slice_vector__initialize_with_grids
    procedure :: finalize => vv_slice_vector__finalize    
    procedure :: set_val => vv_slice_vector__set_val
    procedure :: vis_arrows => vv_slice_vector__vis_arrows
    procedure :: vis_boundary => vv_slice_vector__vis_boundary
  end type vv_slice_vector_t


contains

  subroutine vv_slice_vector__vis_boundary( vector, vv_sketch,        &
                                                    width_in_pixels,  &
                                                    line_color,       &
                                                    fill_color )
    class(vv_slice_vector_t) <io> :: vector
    type(vv_sketch_t) <io> :: vv_sketch
    real <optin> :: width_in_pixels
    type(vv_color_t) <optin> :: line_color
    type(vv_color_t) <optin> :: fill_color

    integer :: n, nvert, counter
    character :: SVG_directive
    type(vv_sketch__sim_pos_t), dimension(:), allocatable :: verts_sim
    character, dimension(:), allocatable :: path_directive
    real :: u_sim, v_sim, dummy

    nvert = vector.mesh_boundary.vert.num

    allocate(verts_sim(nvert+1))
    allocate(path_directive(nvert+1))

    counter = 0
    do n = 1, nvert
      counter += 1
      if ( n == 1 ) then
        SVG_directive = 'M' ! Move to 
      else if ( n == 2 ) then
        SVG_directive = 'L' ! Line to
      else
        SVG_directive = ' ' ! Line to (You can ommit this after 1st 'L'.)
      end if
      path_directive(counter) = SVG_directive 
      u_sim = vector.mesh_boundary.vert.vi(n)
      v_sim = vector.mesh_boundary.vert.vj(n)
      verts_sim(counter) = vv_sketch__sim_pos_t(u_sim,v_sim)
    end do

    ! To close the path
    counter += 1
    path_directive(counter) = 'Z' ! Close the sub-path.
    dummy = 0.0  ! any number
    verts_sim(counter) = vv_sketch__sim_pos_t( dummy, dummy )

    call vv_sketch.path( counter,         &
                         path_directive,  &
                         verts_sim,       &
                         width_in_pixels, &
                         line_color,      &
                         fill_color )      

    deallocate(verts_sim)
    deallocate(path_directive)
  end subroutine vv_slice_vector__vis_boundary


  subroutine vv_slice_vector__initialize_with_uvmax( vector,      &
                                                     tag,         &
                                                     nu,          &
                                                     nv,          &
                                                     u_min,       &
                                                     u_max,       &
                                                     v_min,       &
                                                     v_max,       &
                                                     comp_u,      &
                                                     comp_v )
    class(vv_slice_vector_t) <out> :: vector
    char(len=*) <in> :: tag
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max
    real, dimension(nu,nv) <optin> :: comp_u, comp_v

    real, dimension(nu,nv) :: amp_vect

    vector.tag = tag

    call vector.mesh_vert.initialize( nu,     &
                                      nv,     &
                                      u_min,  &
                                      u_max,  &
                                      v_min,  &
                                      v_max )

    allocate(vector.comp_u(nu,nv))
    allocate(vector.comp_v(nu,nv))

    if ( present(comp_u) ) then
      vector.comp_u(:,:) = comp_u(:,:)
    else
      vector.comp_u(:,:) = 0.0
    end if

    if ( present(comp_v) ) then
      vector.comp_v(:,:) = comp_v(:,:)
    else
      vector.comp_v(:,:) = 0.0
    end if

    amp_vect = sqrt(comp_u**2+comp_v**2)

    vector.amp_max = maxval(amp_vect)
    vector.amp_min = minval(amp_vect)
  end subroutine vv_slice_vector__initialize_with_uvmax


  subroutine vv_slice_vector__initialize_with_grids( vector,     &
                                                     tag,        &
                                                     nu,         &
                                                     nv,         &
                                                     grid_pos_u, &
                                                     grid_pos_v, &
                                                     comp_u,     &
                                                     comp_v,     &
                                                     grid_flag )
    class(vv_slice_vector_t) <out> :: vector
    char(len=*) <in> :: tag
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    real, dimension(nu,nv) <optin> :: comp_u, comp_v
    character, dimension(nu,nv) <optin> :: grid_flag

    real, dimension(nu,nv) :: amp_vect

    vector.tag = tag

    if ( present(grid_flag) ) then
      call vector.mesh_vert.initialize( nu,         &
                                        nv,         &
                                        grid_pos_u, &
                                        grid_pos_v, &
                                        grid_flag )
    else
      call vector.mesh_vert.initialize( nu,         &
                                        nv,         &
                                        grid_pos_u, &
                                        grid_pos_v )
    end if

    call vector.mesh_edge.initialize( vector.mesh_vert )
    call vector.mesh_boundary.initialize( vector.mesh_vert,  &
                                          vector.mesh_edge )

    allocate(vector.comp_u(nu,nv))
    allocate(vector.comp_v(nu,nv))

    if ( present(comp_u) .and. present(comp_v) ) then
      vector.comp_u(:,:) = comp_u(:,:)
      vector.comp_v(:,:) = comp_v(:,:)
      amp_vect = sqrt(comp_u**2+comp_v**2)
      vector.amp_max = maxval(amp_vect)
      vector.amp_min = minval(amp_vect)
    else
      vector.comp_u(:,:) = 0.0
      vector.comp_v(:,:) = 0.0
      vector.amp_max = 0.0
      vector.amp_min = 0.0
    end if


  end subroutine vv_slice_vector__initialize_with_grids

  
  subroutine vv_slice_vector__finalize( vector )
    class(vv_slice_vector_t) <io> :: vector

    deallocate(vector.comp_u)
    deallocate(vector.comp_v)
    call vector.mesh_vert.finalize
  end subroutine vv_slice_vector__finalize


  subroutine vv_slice_vector__set_val( vector, comp_u, comp_v )
    class(vv_slice_vector_t) <io> :: vector
    real, dimension(vector.mesh_vert.nu,  &
                    vector.mesh_vert.nv) <in> :: comp_u, comp_v

    real, dimension(vector.mesh_vert.nu,  &
                    vector.mesh_vert.nv) :: amp_vect

    vector.comp_u(:,:) = comp_u(:,:)
    vector.comp_v(:,:) = comp_v(:,:)
    amp_vect = sqrt(comp_u**2+comp_v**2)
    vector.amp_max = maxval(amp_vect)
    vector.amp_min = minval(amp_vect)
  end subroutine vv_slice_vector__set_val


  subroutine vv_slice_vector__vis_arrows( vector, vv_sketch )
    class(vv_slice_vector_t) <io> :: vector
    type(vv_sketch_t) <io> :: vv_sketch
    !!>
        o--o--o--o--o--o--o--o--o <== Original (=finest) grid
        |  |  |  |  |  |  |  |  |
        o-----o-----o-----o-----o <== Coarse grid (stride=2)
        |  |  |  |  |  |  |  |  |
        o-----------o-----------o <== Coarser grid (stride=4)
        |  |  |  |  |  |  |  |  |
        o-----------------------o <== Coarser2 grid (stride=8)
        |  |  |  |  |  |  |  |  |
        3  0  1  0  2  0  1  0  3 <====== "skip"    
    !!<
    integer :: i, j
    real :: u, v

    integer :: skip, stride
    char(len=11) :: tag_for_group
    logical, dimension(:,:), allocatable :: pass_to_sketch_flag

    allocate(pass_to_sketch_flag(vector.mesh_vert.nu,vector.mesh_vert.nv))

    pass_to_sketch_flag(:,:) = .false.

    do skip = 3, 0, -1
      stride = 2**skip
      write(tag_for_group,"(a,i1)") "arrow-skip", skip
        ! "arrow-skip4, arrow-skip3, ...
      call vv_sketch.group_push( id=trim(tag_for_group),  &
                                 visibility="visible" )
        do j = 1, vector.mesh_vert.nv, stride
          do i = 1, vector.mesh_vert.nu, stride
            if ( vector.mesh_vert.flag(i,j) == 'o' ) cycle
            if ( .not. pass_to_sketch_flag(i,j) ) then
              u = vector.mesh_vert.pos_u(i)
              v = vector.mesh_vert.pos_v(j)
              call vv_sketch.arrow( u, v, &
                                    vector.comp_u(i,j), &
                                    vector.comp_v(i,j) )
              pass_to_sketch_flag(i,j) = .true.
            end if
          end do
        end do
      call vv_sketch.group_pop()
    end do

    deallocate(pass_to_sketch_flag)

    call vector.vis_boundary( vv_sketch, line_color=here here @iwidth_in_pixels=1.0 )
  end subroutine vv_slice_vector__vis_arrows

end module vv_slice_vector_m
