!!>

    slisvg_slice_mesh.ef

    ## Two kinds of grid mesh info; vert(ex) and edge

    ### Vertex


        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |


    ### Edge
                
        edge_u (u-axis)
        edge_v (v-axis)
        edge_a (ascend)
        edge_d (descend)
                                    
            |     / | \     |     / | \     | 
            v   a   v   d   v   a   v   d   v
            | /     |     \ | /     |     \ |
           -+---u---+---u---+---u---+---u---+-
            | \     |     / | \     |     / |
            v   d   v   a   v   d   v   a   v
            |     \ | /     |     \ | /     |
           -+---u---+---u---+---u---+---u---+-
            |     / | \     |     / | \     | 
            v   a   v   d   v   a   v   d   v
            | /     |     \ | /     |     \ |


     ## Quarter for edge (used in contour drawing)
     
       Each edge has one of four integers (0-3) for a given
       value of contour level.

          Take an edge V1-V2. 
                    V1--edge--V2  
          Denote "p" when V1 or V2 > level (of the contour),
          and "m" when V1 or V2 < level. For example, when
          V1 > level and V2 < level, 
                     p--edge--m
             There are four possibilities.

          Combination | quarter
          ------------+--------
               m - m  |  0
               m - p  |  1
               p - m  |  2
               p - p  |  3 (Special quarter for boundary edges)

     ## Flag character for each vert

              'i' : vert inside the boundary
              'b' : the boundary vert
              'o' : vert outside the boundary

     ## Boundary path

        When NU=9, NV=5, the common data assignment for
        each vertex is 

                5    b b b b b b b b b 
                4    b i i i i i i i b
                3    b i i i i i i i b
                2    b i i i i i i i b
                1    b b b b b b b b b 
                     
                     1 2 3 4 5 6 7 8 9

        where 'b' stands for the boundary data and
        'i' stands for the bulk data of the simulation.

        We define the boundary path, a closed line, by connecting 
        the consequtive 'b' points in the counter-clockwise direction.

                     <--- this way -----+ t
                                        | h
                5    b b b b b b b b b  | i
                4    b . . . . . . . b  | s
                3    b . . . . . . . b  |   
                2    b . . . . . . . b  | w
                1    b b b b b b b b b  | a
                                        | y
                                    ----+  
                     1 2 3 4 5 6 7 8 9


        The boundary path can have more complex shape than a rectangle,
        for example,

                     <--- this way -----+ t
                                        | h
                5    b b b b b b . . .  | i
                4    b . . . . b b b b  | s
                3    b b b . . . . . b  |
                2    . . b . . . . . b  | w
                1    . . b b b b b b b  | a
                                        | y
                                    ----+  
                     1 2 3 4 5 6 7 8 9


     ## octa_direct

        We use octal integer (octa_direct) from 0 to 7 to indicate 
        the direction of the path segment.

        0 for North, 2 for East, 4 for South, and 6 for West.

                     4 6 6 6 6 6 . . .   
                     4 . . . . 0 6 6 6  
                     2 2 4 . . . . . 0   
                     . . 4 . . . . . 0   
                     . . 2 2 2 2 2 2 0   

        boundary path may have diagonal edge like

                     . * * * * * . . .
                     * . . . . . * . .
                     . * . . . . * . .
                     . . * . . . * . .  
                     . . . * * * . . .  

        We assign integers from 0 to 7 to the 8 directions as 

                           North : 0                
                      North-East : 1                0  
                            East : 2            7       1  
                      South-East : 3                |            
                           South : 4           6  --+--  2
                      South-West : 5                |
                            West : 6            5       3
                      North-West : 7                4

        The above path is written as

                     . 5 6 6 6 6 . . .
                     3 . . . . . 7 . .
                     . 3 . . . . 0 . .
                     . . 3 . . . 0 . .  
                     . . . 2 2 1 . . .  

!!<

module slisvg_slice_mesh_m
  use slisvg_m
  use slisvg_color_m
  use slisvg_sketch_m
  implicit none
  private
  public :: SLISVG_SLICE_MESH__EDGE_MM,  &
            SLISVG_SLICE_MESH__EDGE_PP,  &
            SLISVG_SLICE_MESH__EDGE_MP,  &
            SLISVG_SLICE_MESH__EDGE_PM

  integer <const> :: SLISVG_SLICE_MESH__EDGE_MM = 0  ! --m---m-- 
  integer <const> :: SLISVG_SLICE_MESH__EDGE_MP = 1  ! --m---p-- 
  integer <const> :: SLISVG_SLICE_MESH__EDGE_PM = 2  ! --p---m-- 
  integer <const> :: SLISVG_SLICE_MESH__EDGE_PP = 3  ! --p---p-- 


  type, public :: slisvg_slice_mesh_vert_t
    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
    integer, dimension(:,:), allocatable :: octa_direct 
    character, dimension(:,:), allocatable :: flag 
                       !        'i' : inside the boundary
                       !        'o' : outside the boundary
                       !        'b' : on the boundary
  contains
    procedure ::       initialize => slisvg_slice_mesh__vert_initialize 
    procedure ::         finalize => slisvg_slice_mesh__vert_finalize
    procedure :: debug_print_flag => slisvg_slice_mesh_vert__debug_print_flag
    procedure ::  grid_flag_check => slisvg_slice_mesh_vert__grid_flag_check
  end type slisvg_slice_mesh_vert_t  


  type, public :: slisvg_slice_mesh_edge_t
    integer :: u_nu, u_nv
    integer :: v_nu, v_nv
    integer, dimension(:,:), allocatable :: u_quarter   ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: v_quarter   ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: a_quarter   ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: d_quarter   ! {0,1,2,3}
    real, dimension(:,:), allocatable :: u_cross_coord
    real, dimension(:,:), allocatable :: v_cross_coord
    real, dimension(:,:), allocatable :: a_cross_coord_u
    real, dimension(:,:), allocatable :: a_cross_coord_v
    real, dimension(:,:), allocatable :: d_cross_coord_u
    real, dimension(:,:), allocatable :: d_cross_coord_v
    logical, dimension(:,:), allocatable :: u_is_boundary
    logical, dimension(:,:), allocatable :: v_is_boundary
    logical, dimension(:,:), allocatable :: a_is_boundary
    logical, dimension(:,:), allocatable :: d_is_boundary
  contains
    procedure :: initialize => slisvg_slice_mesh__edge_initialize
    procedure :: finalize => slisvg_slice_mesh__edge_finalize
    procedure :: set_quarter => slisvg_slice_mesh__edge_set_quarter
    procedure :: erase => slisvg_slice_mesh_edge__erase
  end type slisvg_slice_mesh_edge_t    


  type, public :: slisvg_slice_mesh_boundary_vert_t
    integer :: num ! number of boundary verts
    integer, dimension(:), allocatable :: octa_direct
    integer, dimension(:), allocatable :: vi  ! vert position index
    integer, dimension(:), allocatable :: vj
  contains
    procedure :: initialize => slisvg_slice_mesh__boundary_vert_initialize
    procedure :: finalize => slisvg_slice_mesh__boundary_vert_finalize
    procedure :: get_nth => slisvg_slice_mesh__boundary_vert_vij_to_nth
  end type slisvg_slice_mesh_boundary_vert_t


  type, public :: slisvg_slice_mesh_boundary_edge_t
    integer :: num ! number of boundary edges
    character, dimension(:), allocatable :: type  ! 'u'/'v'/'a'/'d'
    integer, dimension(:), allocatable :: ei  ! edge position index
    integer, dimension(:), allocatable :: ej
    integer, dimension(:), allocatable :: quarter   ! {0,1,2,3}
    real, dimension(:), allocatable :: cross_coord_u
    real, dimension(:), allocatable :: cross_coord_v
  contains
    procedure :: initialize => slisvg_slice_mesh__boundary_edge_init
    procedure :: finalize => slisvg_slice_mesh__boundary_edge_finalize
    procedure :: erase => slisvg_slice_mesh__boundary_edge_erase
    procedure :: get_nth => slisvg_slice_mesh__boundary_edge_eij_to_nth
  end type slisvg_slice_mesh_boundary_edge_t


  type, public :: slisvg_slice_mesh_boundary_t
    type(slisvg_slice_mesh_boundary_vert_t) :: vert
    type(slisvg_slice_mesh_boundary_edge_t) :: edge
  contains
    procedure :: initialize => slisvg_slice_mesh__boundary_initialize
    procedure :: finalize => slisvg_slice_mesh__boundary_finalize
    procedure :: make_list => slisvg_slice_mesh__boundary_make_list
    procedure :: set_quarter => slisvg_slice_mesh__boundary_set_quarter
  end type slisvg_slice_mesh_boundary_t


  type, public :: slisvg_slice_mesh_t
    type(slisvg_slice_mesh_vert_t) :: vert
    type(slisvg_slice_mesh_edge_t) :: edge
    type(slisvg_slice_mesh_boundary_t) :: boundary
  contains
    procedure :: initialize => slisvg_slice_mesh__initialize
    procedure :: finalize => slisvg_slice_mesh__finalize
    procedure :: draw => slisvg_slice_mesh__draw
    procedure :: debug_print => slisvg_slice_mesh__debug_print
  end type slisvg_slice_mesh_t


contains


  subroutine slisvg_slice_mesh__debug_print( mesh, vi_from, &
                                                   vi_to,   &
                                                   vj_from, &
                                                   vj_to )
    class(slisvg_slice_mesh_t) <in> :: mesh
    integer <in> :: vi_from, vi_to, vj_from, vj_to

    integer <const> :: PRINT_VERT_NUM = 50
    integer <const> :: PRINT_LINE_LEN = 2*PRINT_VERT_NUM-1
    !!> 
        Print out the quarter values of edge_u and edge_v.
        This is covenient in debugging.
               |       |
            -- + --u-- + --
               |       |
               v       v
               |       |
            -- + --u-- + --
               |       |

        Example output
         +3+2+1+3+3+3+3+3+3+3+3+
         3 3 2 3 3 3 3 1 1 1 1 1
         +3+3+3+3+3+3+2+0+0+0+0+
         3 3 3 3 3 3 3 2 2 0 0 0
         +3+3+3+3+3+3+2+1+2+0+0+
         3 3 3 3 3 3 3 1 1 0 0 0
         +3+3+3+3+3+3+2+0+0+0+0+
         3 3 3 3 3 3 3 0 0 0 0 0
         +3+3+3+3+3+3+2+0+0+0+0+
    !!<
    char(len=PRINT_LINE_LEN) :: line
    integer :: vj_range, vi_range
    integer :: vi, vj, ei, ej
    character :: char_vert = '+'
    character :: char_edge_u, char_edge_v
    integer :: cc ! character counter

    vi_range = vi_to - vi_from
    vj_range = vj_to - vj_from

    vi_range = min(vi_range,PRINT_VERT_NUM-1)
    vj_range = min(vj_range,PRINT_VERT_NUM-1)

    do vj = vj_from+vj_range, vj_from, -1  ! upside-down
      !! edge-u
      cc = 1
      line = '' ! reset
      do vi = vi_from, vi_from+vi_range
        line(cc:cc) = char_vert
        cc += 1  ! shift rightward
        ei = vi
        ej = vj
        if ( cc <= PRINT_LINE_LEN ) then
          char_edge_u = slisvg__int_to_char1( mesh.edge.u_quarter(ei,ej) )
          line(cc:cc) = char_edge_u
          cc += 1  ! shift rightward
        end if
      end do
      print *, trim(line)

      if ( vj > vj_from ) then  ! Do not print for lowest line.
        !! edge-v
        cc = 1 
        line = '' ! reset
        do vi = vi_from, vi_from+vi_range
          !!>
               |   |
              -o---o- vj=4
               | <== ej=3
              -o---o- vj=3
               |   |
          !!<
          ei = vi
          ej = vj - 1
          char_edge_v = slisvg__int_to_char1( mesh.edge.v_quarter(ei,ej) )
          line(cc:cc) = char_edge_v
          cc += 1  ! shift rightward
          if ( cc <= PRINT_LINE_LEN ) then
            line(cc:cc) = ' '
            cc += 1  ! shift rightward
          end if
        end do
        print *, trim(line)
      end if
    end do
  end subroutine slisvg_slice_mesh__debug_print 


  subroutine slisvg_slice_mesh__draw( mesh, slisvg_sketch,       &
                                            width_in_pixels, &
                                            line_color,      &
                                            fill_color )
    class(slisvg_slice_mesh_t) <in> :: mesh
    type(slisvg_sketch_t) <io> :: slisvg_sketch
    real <optin> :: width_in_pixels
    type(slisvg_color_t) <optin> :: line_color
    type(slisvg_color_t) <optin> :: fill_color

    call iCoordinates_min_max_rectangle( mesh.vert )
    call iBoundary_curve( mesh.boundary.vert, mesh.vert )

  contains

    subroutine iCoordinates_min_max_rectangle( vert )
      type(slisvg_slice_mesh_vert_t) <in> :: vert

      type(slisvg_sketch__sim_pos_t) :: ll ! lower left
      type(slisvg_sketch__sim_pos_t) :: ur ! upper right

      ll = slisvg_sketch__sim_pos_t(vert.u_min, vert.v_min)
      ur = slisvg_sketch__sim_pos_t(vert.u_max, vert.v_max)

      call slisvg_sketch.rectangle( ll, ur,  &
                                    line_width_in_pixel=2.0, &
                                    line_color=SLISVG_COLOR__CONST.black )
    end subroutine iCoordinates_min_max_rectangle


    subroutine iBoundary_curve( b_vert, vert )
      type(slisvg_slice_mesh_boundary_vert_t) <in> :: b_vert
      type(slisvg_slice_mesh_vert_t) <in> :: vert

      character :: SVG_directive
      integer :: n, nvert, counter, vert_i, vert_j
      type(slisvg_sketch__sim_pos_t), dimension(:), allocatable :: verts_sim
      character, dimension(:), allocatable :: path_directive
      real :: u_sim, v_sim, dummy
      
      nvert = b_vert.num

      allocate(verts_sim(nvert+1))
      allocate(path_directive(nvert+1))

      counter = 0
      do n = 1, nvert
        counter += 1
        if ( n == 1 ) then
          SVG_directive = 'M' ! Move to 
        else if ( n == 2 ) then
          SVG_directive = 'L' ! Line to
        else
          SVG_directive = ' ' ! Line to (You can ommit this after 1st 'L'.)
        end if
        path_directive(counter) = SVG_directive 
        vert_i = b_vert.vi(n)
        vert_j = b_vert.vj(n)
        u_sim = vert.pos_u(vert_i)
        v_sim = vert.pos_v(vert_j)
        verts_sim(counter) = slisvg_sketch__sim_pos_t(u_sim,v_sim)
      end do

      ! To close the path
      counter += 1
      path_directive(counter) = 'Z' ! Close the sub-path.
      dummy = 0.0  ! any number
      verts_sim(counter) = slisvg_sketch__sim_pos_t( dummy, dummy )
      call slisvg_sketch.path( counter,         &
                               path_directive,  &
                               verts_sim,       &
                               width_in_pixels, &
                               line_color,      &
                               fill_color )      
      deallocate(verts_sim)
      deallocate(path_directive)
    end subroutine iBoundary_curve

  end subroutine slisvg_slice_mesh__draw


  subroutine slisvg_slice_mesh__initialize( mesh, nu, nv,      &
                                                  grid_pos_u,  &
                                                  grid_pos_v,  &
                                                  grid_flag )
    class(slisvg_slice_mesh_t) <io> :: mesh
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    character, dimension(nu,nv) <optin> :: grid_flag

    call mesh.vert.initialize( nu, nv,      &
                               grid_pos_u,  &
                               grid_pos_v,  &
                               grid_flag )
    !!>
    call mesh.vert.initialize( nu, nv,      &
                               grid_pos_u,  &
                               grid_pos_v,  &
                               grid_flag,   &
                               debug_print_flag = .true. )
    !!<
    call mesh.edge.initialize( mesh.vert )
    call mesh.boundary.initialize( mesh.vert,  &
                                   mesh.edge )
  end subroutine slisvg_slice_mesh__initialize


  subroutine slisvg_slice_mesh__finalize( mesh )
    class(slisvg_slice_mesh_t) <io> :: mesh

    call mesh.vert.finalize
    call mesh.edge.finalize
    call mesh.boundary.finalize
  end subroutine slisvg_slice_mesh__finalize


  subroutine slisvg_slice_mesh_vert__debug_print_flag( vert )
    class(slisvg_slice_mesh_vert_t) <in> :: vert

    integer <const> :: PRINT_LINE_LEN = 120
    char(len=PRINT_LINE_LEN) :: string

    integer :: i, j
    integer :: num_rows_print, num_columns_print

    num_rows_print = min(vert.nv,PRINT_LINE_LEN)
    num_columns_print = min(vert.nu,PRINT_LINE_LEN)


    do j = num_rows_print, 1, -1
      do i = 1, num_columns_print
        string(i:i) = vert.flag(i,j)
      end do
      print *, string(1:num_columns_print)
    end do
  end subroutine slisvg_slice_mesh_vert__debug_print_flag


  subroutine slisvg_slice_mesh_vert__grid_flag_check( vert, debug_print_flag )
    class(slisvg_slice_mesh_vert_t) <in> :: vert
    logical <optin> :: debug_print_flag

    call iCheck_flag_char( vert.nu, vert.nv, vert.flag )

  contains

    subroutine iCheck_flag_char( nu, nv, flag )
      integer <in> :: nu, nv
      character, dimension(nu,nv) <in> :: flag

      integer :: num_i ! inside the boundary
      integer :: num_o ! outside the boundary
      integer :: num_b ! on the boundary
      integer :: i, j

      num_i = 0
      num_o = 0
      num_b = 0

      do j = 1, nv
        do i = 1, nu
          select case (flag(i,j))
            case ('i')
              num_i += 1
            case ('b')
              num_b += 1
            case ('o')
              num_o += 1
            case default
              call slisvg__fatal( "__MODLINE__ " //  &
                              "Grid flag char is not 'i'/'b'/'o'." )
          end select
        end do
      end do

      if ( present(debug_print_flag) ) then
        if ( debug_print_flag ) then
          call slisvg__message( 'slisvg_slice mesh vert nu = ', nu )
          call slisvg__message( '                       nv = ', nv )
          call slisvg__message( '            boundary vert = ', num_b )
          call slisvg__message( '          inside boundary = ', num_i )
          call slisvg__message( '         outside boundary = ', num_o )
        end if
      end if

      call slisvg__assert( num_b > 0,               &
                           "__MODLINE__ " //        &
                           "No boundary point." )
      call slisvg__assert( num_i > 0,               &
                           "__MODLINE__ " //        &
                           "No inner grid point. ")
      call slisvg__assert( num_i+num_b+num_o == nu*nv,  &
                           "__MODLINE__ " //            &
                           "Something is very wrong." )

    end subroutine iCheck_flag_char

  end subroutine slisvg_slice_mesh_vert__grid_flag_check


  subroutine slisvg_slice_mesh__boundary_initialize( boundary, vert,  &
                                                               edge )
    class(slisvg_slice_mesh_boundary_t) <io> :: boundary
    type(slisvg_slice_mesh_vert_t) <io> :: vert
    type(slisvg_slice_mesh_edge_t) <io> :: edge

    call boundary.vert.initialize( vert.nu, vert.nv, vert.flag )
    call boundary.edge.initialize( boundary.vert.num )
    call boundary.make_list( vert, edge )
  end subroutine slisvg_slice_mesh__boundary_initialize


  subroutine slisvg_slice_mesh__boundary_finalize( boundary )
    class(slisvg_slice_mesh_boundary_t) <io> :: boundary

    call boundary.vert.finalize
    call boundary.edge.finalize
  end subroutine slisvg_slice_mesh__boundary_finalize


  subroutine slisvg_slice_mesh__boundary_edge_erase( b_edge, nth )
    class(slisvg_slice_mesh_boundary_edge_t) <io> :: b_edge
    integer <in> :: nth

    b_edge.quarter(nth) = SLISVG_SLICE_MESH__EDGE_MM

  end subroutine slisvg_slice_mesh__boundary_edge_erase


  function slisvg_slice_mesh__boundary_vert_vij_to_nth( b_vert, vi,  &
                                                                vj ) result(nth)
    class(slisvg_slice_mesh_boundary_vert_t) <in> :: b_vert
    integer <in> :: vi, vj
    integer :: nth

    integer :: i, j, n

    nth = -NIL ! To supress uninit warning.

    do n = 1, b_vert.num
      i = b_vert.vi(n)
      j = b_vert.vj(n)
      if ( i == vi .and. j == vj ) then
        nth = n
        return
      end if
    end do
    call slisvg__fatal( "__MODLINE__: Not a boundary vert." )
  end function slisvg_slice_mesh__boundary_vert_vij_to_nth


  function slisvg_slice_mesh__boundary_edge_eij_to_nth( b_edge, edge_type, &
                                                                ei,        &
                                                                ej )       &
                                                                result(nth)
    class(slisvg_slice_mesh_boundary_edge_t) <in> :: b_edge
    character <in> :: edge_type
    integer <in> :: ei, ej
    integer :: nth

    integer :: i, j, n
    character :: t

    nth = -NIL ! To supress uninit warning.

    do n = 1, b_edge.num
      i = b_edge.ei(n)
      j = b_edge.ej(n)
      t = b_edge.type(n)
      if ( i == ei .and. j == ej .and. t == edge_type ) then
        nth = n
        return
      end if
    end do
    call slisvg__fatal( "__MODLINE__: Not a boundary vert." )
  end function slisvg_slice_mesh__boundary_edge_eij_to_nth


  subroutine slisvg_slice_mesh__boundary_vert_initialize( b_vert, nu,  &
                                                                  nv,  &
                                                                  vert_flag )
    class(slisvg_slice_mesh_boundary_vert_t) <out> :: b_vert
    integer <in> :: nu, nv
    character, dimension(nu,nv) <in> :: vert_flag

    integer :: boundary_vert_num

    boundary_vert_num = iCount_boundary_vert( nu, nv, vert_flag )
    b_vert.num = boundary_vert_num

    allocate(b_vert.octa_direct(boundary_vert_num))
    allocate(         b_vert.vi(boundary_vert_num))
    allocate(         b_vert.vj(boundary_vert_num))

  contains

    function iCount_boundary_vert( nu, nv, vert_flag ) result(num)
      integer <in> :: nu, nv
      character, dimension(nu,nv) <in> :: vert_flag
      integer :: num

      integer :: i, j

      num = 0
      do j = 1, nv
        do i = 1, nu
          if ( vert_flag(i,j) == 'b' ) then
            num += 1
          end if
        end do
      end do
    end function iCount_boundary_vert

  end subroutine slisvg_slice_mesh__boundary_vert_initialize


  subroutine slisvg_slice_mesh__boundary_vert_finalize( b_vert )
    class(slisvg_slice_mesh_boundary_vert_t) <io> :: b_vert

    deallocate(b_vert.octa_direct)
    deallocate(b_vert.vi)
    deallocate(b_vert.vj)
  end subroutine slisvg_slice_mesh__boundary_vert_finalize


  function find_direct_for_next_border_vert( vert_nu,      &
                                             vert_nv,      &
                                             flag,         &
                                             i,            &
                                             j,            &
                                             octa_direct ) &
                                     result(ans)
    integer <in> :: vert_nu, vert_nv
    character, dimension(vert_nu,vert_nv) <in> :: flag
    integer <in> :: i, j
    integer <in> :: octa_direct
    integer :: ans
    !!>
             7     0     1
                   .
                   .
             6     b     2
                 . 
               . 
             b     4     3
    !!<
    integer :: octa_direct_came_from
    integer :: odir
    integer :: icheck, jcheck
    integer :: look_around_from_right

    octa_direct_came_from = mod(octa_direct+4,8)
      ! 0 --> 4
      ! 1 --> 5
      ! 2 --> 6
      ! 3 --> 7
      ! 4 --> 0
      ! 5 --> 1
      ! 5 --> 2
      ! 7 --> 3

    ans = NIL  ! dummy 

    do look_around_from_right = 1, 7
      odir = mod(8+octa_direct_came_from-look_around_from_right,8)
        ! plus 8 is necessary to avoid taking mod of a negative integer.
      icheck = i
      jcheck = j
      call shift_vert_position_in_octa_direct( odir, icheck, jcheck )
      if ( icheck >= 1 .and. icheck <= vert_nu .and.  &
           jcheck >= 1 .and. jcheck <= vert_nv ) then

        if ( flag(icheck,jcheck) == 'b' ) then
          ! found the next border 
          ans = odir  ! return this value after check
          return
        end if
      end if
    end do

    call slisvg__fatal( "__MODLINE__: " //           &
                        "Failed to find new octa_direct." )

  end function find_direct_for_next_border_vert


  subroutine shift_vert_position_in_octa_direct( octa_direct,     &
                                                 i, j )
    integer <in> :: octa_direct
    integer <io> :: i, j

    select case (octa_direct)
      case (0) ! North
        j += 1
      case (1) ! North-East
        i += 1
        j += 1
      case (2) ! East
        i += 1
      case (3) ! South-East
        i += 1
        j -= 1
      case (4) ! South
        j -= 1
      case (5) ! South-West
        i -= 1
        j -= 1
      case (6) ! West
        i -= 1
      case (7) ! North-West
        i -= 1
        j += 1
      case default
        call slisvg__fatal( "__MODLINE__: case error." )
    end select
  end subroutine shift_vert_position_in_octa_direct


  subroutine get_next_octa_direct_and_vert( nu, nv,       &
                                            i, j,         &
                                            octa_direct,  &
                                            flag )
    integer <in> :: nu, nv
    integer <io> :: i, j
    integer <io> :: octa_direct  ! 0 (North), 1 (North-East),
                                 ! 2 (East) , 3 (South-East), 
                                 ! 4 (South), 5 (South-West), 
                                 ! 6 (West),  7 (North-West)
    character, dimension(nu,nv) <in> :: flag

    integer :: octa_direct_in_previous_jump

    call slisvg__assert( flag(i,j) == 'b',          &
                         "__MODLINE__: " //         &
                         "This vert is not a border. Inconsistent..." )
    call shift_vert_position_in_octa_direct( octa_direct, i, j )

    call slisvg__assert( i >= 1 .and. i <= nu,  &
                         "__MODLINE__: i-range error." )
    call slisvg__assert( j >= 1 .and. j <= nv,  &
                         "__MODLINE__: j-range error." )

    octa_direct_in_previous_jump = octa_direct

    octa_direct  &
      = find_direct_for_next_border_vert( nu,           &
                                          nv,           &
                                          flag,         &
                                          i,            &
                                          j,            &
                                          octa_direct_in_previous_jump )
  end subroutine get_next_octa_direct_and_vert


  subroutine set_default_vert_flag( nu, nv, vert_flag )
    integer <in> :: nu, nv
    character, dimension(nu,nv) <out> :: vert_flag
    !!>
                  b b b b b b b b b 
                  b i i i i i i i b
                  b i i i i i i i b
                  b i i i i i i i b
                  b b b b b b b b b
    !!<
    vert_flag(2:nu-1,2:nv-1) = 'i'
    vert_flag(1:nu  ,     1) = 'b'
    vert_flag(1:nu  ,    nv) = 'b'
    vert_flag(     1,2:nv-1) = 'b'
    vert_flag(    nu,2:nv-1) = 'b'
  end subroutine set_default_vert_flag


  subroutine get_edge_id( vi, vj, octa_direct, ei, ej, edge_type )
    integer <in> :: vi, vj     ! id of vertex
    integer <in> :: octa_direct  ! from 0 (north) to 7 (north-west)
    integer <out> :: ei, ej    ! id of edge
    character :: edge_type ! 'u' / 'v' / 'a' / 'd'
    !!>
                   edge_u(ei,ej)            edge_v(ei,ej)
       (vi,vj+1)--> + - - - +                + - - - +
                    |       |                v       | \__ (vi+1,vj+1)
                    |       |                v       |
                    |       |                v       |
        (vi,vj) --> + u u u +    (vi,vj) --> + - - - +
                           /          
                     (vi+1,vj)   


                   edge_a(ei,ej)            edge_d(ei,ej)
       (vi,vj+1)--> + - - - a                + - - - +
                    |     a |                | d     |
                    |   a   |                |   d   |
                    | a     |                |     d |
        (vi,vj) --> + - - - +    (vi,vj) --> + - - - +
    !!<

    select case (octa_direct)
      case (0) 
        ei = vi             !    *
        ej = vj             !    *
        edge_type = 'v'     !    * . . .
      case (1)
        ei = vi             !    .   * 
        ej = vj             !    . *
        edge_type = 'a'     !    * . . .
      case (2)
        ei = vi             !    .
        ej = vj             !    .
        edge_type = 'u'     !    * * * *
      case (3)
        ei = vi             !    * . . .
        ej = vj - 1         !    . *
        edge_type = 'd'     !    .   *
      case (4) 
        ei = vi             !    * . . .
        ej = vj - 1         !    *
        edge_type = 'v'     !    *
      case (5) 
        ei = vi - 1         !    . . . *
        ej = vj - 1         !        * .
        edge_type = 'a'     !      *   .
      case (6) 
        ei = vi - 1         !          .
        ej = vj             !          .
        edge_type = 'u'     !    * * * *
      case (7) 
        ei = vi - 1         !      *   .
        ej = vj             !        * .
        edge_type = 'd'     !    . . . *
      case default
        call slisvg__fatal( "__MODLINE__: case error." )
    end select

  end subroutine get_edge_id


  subroutine slisvg_slice_mesh__boundary_make_list( boundary, vert,  &
                                                              edge )
    class(slisvg_slice_mesh_boundary_t) <io> :: boundary
    type(slisvg_slice_mesh_vert_t) <io> :: vert
    type(slisvg_slice_mesh_edge_t) <io> :: edge

    integer :: vi, vj, start_vi, start_vj
    integer :: ei, ej
    integer :: num_of_boundary_vert
    integer :: counter
    integer :: octa_direct
    character :: edge_type

    num_of_boundary_vert = boundary.vert.num

    call iFind_border_vert_and_its_direct( vert.nu, vert.nv, &
                                           vert.flag,        &
                                           vi, vj,           &
                                           octa_direct )

    edge.u_is_boundary(:,:) = .false. ! default
    edge.v_is_boundary(:,:) = .false. ! default
    edge.a_is_boundary(:,:) = .false. ! default
    edge.d_is_boundary(:,:) = .false. ! default

    vert.octa_direct(:,:) = -NIL ! default

    start_vi = vi
    start_vj = vj
    counter = 1
    vert.octa_direct(vi,vj) = octa_direct
    boundary.vert.octa_direct(counter) = octa_direct
    boundary.vert.vi(counter) = vi
    boundary.vert.vj(counter) = vj
    call get_edge_id( vi, vj, octa_direct, ei, ej, edge_type )
    boundary.edge.ei(counter) = ei
    boundary.edge.ej(counter) = ej
    boundary.edge.type(counter) = edge_type
    call iSet_boundary_mark_on_mesh_edge( edge, edge_type, ei, ej )
    call get_next_octa_direct_and_vert( vert.nu, vert.nv, &
                                        vi, vj,           &
                                        octa_direct,      &
                                        vert.flag )
    do counter = 2, num_of_boundary_vert
      vert.octa_direct(vi,vj) = octa_direct
      boundary.vert.octa_direct(counter) = octa_direct
      boundary.vert.vi(counter) = vi
      boundary.vert.vj(counter) = vj
      call get_edge_id( vi, vj, octa_direct, ei, ej, edge_type )
      boundary.edge.ei(counter) = ei
      boundary.edge.ej(counter) = ej
      boundary.edge.type(counter) = edge_type
      call iSet_boundary_mark_on_mesh_edge( edge, edge_type, ei, ej )
      call get_next_octa_direct_and_vert( vert.nu, vert.nv, &
                                          vi, vj,           &
                                          octa_direct,      &
                                          vert.flag )
    end do

    call slisvg__assert( vi == start_vi .and. vj == start_vj,  &
                     "__MODLINE__: Failed to close boundary." )

  contains

    subroutine iSet_boundary_mark_on_mesh_edge( edge, type, ei, ej )
      type(slisvg_slice_mesh_edge_t) <io> :: edge
      character <in> :: type
      integer <in> :: ei, ej

      select case ( type )
        case ('u')
          edge.u_is_boundary(ei,ej) = .true.
        case ('v')
          edge.v_is_boundary(ei,ej) = .true.
        case ('a')
          edge.a_is_boundary(ei,ej) = .true.
        case ('d')
          edge.d_is_boundary(ei,ej) = .true.
        case default
          call slisvg__fatal( "__MODLINE__: " //  &
                              "case error." )
      end select
    end subroutine iSet_boundary_mark_on_mesh_edge


    subroutine iFind_border_vert_and_its_direct( vert_nu, vert_nv, &
                                                 vert_flag,        &
                                                 start_i, start_j, &
                                                 head_octa_direct )
      integer <in> :: vert_nu, vert_nv
      character, dimension(vert_nu,vert_nv) <in> :: vert_flag
      integer <out> :: start_i, start_j
      integer <out> :: head_octa_direct

      integer :: i, j
      character :: flag_me    ! of the 'b' vert
      character :: flag_w     ! of the west neigbhor vert
      character :: flag_sw    ! south-west
      character :: flag_s     ! south

      !!>
                .  .  .  .

                .  .  i  b
                  w__/
                .  .  ?  ?
                sw __/    \__ s
                .  .  .  .

           There are three cases

             case 1
                      i b
                      i b
             case 2
                      i b
                      b o
             case 3
                      i b
                      b b
      !!<

      do j = 2, vert_nv-1  ! up to the top wall - 1
        do i = 2, vert_nu  ! up to the right wall
          flag_me = vert_flag(i  ,j  )
          flag_w  = vert_flag(i-1,j  )
          flag_sw = vert_flag(i-1,j-1)
          flag_s  = vert_flag(i  ,j-1)
          if ( flag_w  == 'i' .and.  &
               flag_me == 'b' ) then
            if ( flag_sw == 'i' .and.  &
                 flag_s  == 'b' ) then
              ! case 1
              start_i = i
              start_j = j - 1
              head_octa_direct = 0
              return
            else if ( flag_sw == 'b' .and.  &
                      flag_s  == 'o' ) then
              ! case 2
              start_i = i - 1
              start_j = j - 1
              head_octa_direct = 1
              return
            else if ( flag_sw == 'b' .and.  &
                      flag_s  == 'b' ) then
              ! case 3
              start_i = i - 1
              start_j = j - 1
              head_octa_direct = 2
              return
            end if
          end if
        end do
      end do

      call slisvg__fatal( "__MODLINE__: " //  &
                          "Failed to find a start vert." )
    end subroutine iFind_border_vert_and_its_direct

  end subroutine slisvg_slice_mesh__boundary_make_list


  function linear_interpol( x1, x2, diff1, diff2 ) result( xi )
    real <in> :: x1, x2, diff1, diff2
    real :: xi
    !!>   
        Diff1 and diff2 can be negative but they 
        must have the same sign.

         \
          \ - - - - - - - - -  val(x1)
          .\                 |
          . \      x=x2      | diff1 > 0.0
          .  \     |         |
      ----o===+====o-------------- level 
          |   .\   .         |
       x=x1   . \  .         | diff2 > 0.0
              .  \ .         |
              .   \ - - - - -  val(x2)
            x=xi   \

    !!<
    real :: weight1, weight2

    call slisvg__assert( diff1*diff2 >= 0.0,  &
                         "__MODLINE__: Cannot interpolate." )

    if ( diff1+diff2 == 0.0  ) then
      ! which means diff1 = 0.0 & diff2 = 0.0
      xi = (x1+x2)/2 ! Take the middle point
                     ! I'm not very sure if this is OK.
    else
      ! The following applies in either cases of
      !  (1) diff1 > 0 & diff2 > 0
      !  (2) diff1 < 0 & diff2 < 0
      weight1 = diff2 / (diff1 + diff2)
      weight2 = 1.0 - weight1
      call slisvg__assert( weight1 >= 0.0 .and. weight1 <= 1.0,  &
                           "__MODLINE__: weight1 is out of range." )
      xi = weight1 * x1 + weight2 * x2
    end if
  end function linear_interpol


  function quarter_of_edge_ends( v1, v2, level ) result(ans)
    real <in> :: v1, v2, level
    integer :: ans

    if ( v1 >= level ) then
      if ( v2 >= level ) then
        ans = SLISVG_SLICE_MESH__EDGE_PP
      else
        ans = SLISVG_SLICE_MESH__EDGE_PM
      end if
    else
      if ( v2 >= level ) then
        ans = SLISVG_SLICE_MESH__EDGE_MP
      else
        ans = SLISVG_SLICE_MESH__EDGE_MM
      end if
    end if
  end function quarter_of_edge_ends


  subroutine slisvg_slice_mesh_edge__erase( edge, edge_type,  &
                                                  ei, ej )
    class(slisvg_slice_mesh_edge_t) <io> :: edge
    character <in> :: edge_type
    integer <in> :: ei, ej
    
    select case (edge_type)
      case ('u')
        edge.u_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
      case ('v') 
        edge.v_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
      case ('a') 
        edge.a_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
      case ('d') 
        edge.d_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
      case default
        call slisvg__fatal( "__MODLINE__: " //  &
                            "case error." )
    end select
  end subroutine slisvg_slice_mesh_edge__erase


  subroutine slisvg_slice_mesh__vert_initialize( vert, nu,          &
                                                       nv,          &
                                                       grid_pos_u,  &
                                                       grid_pos_v,  &
                                                       vert_flag,   &
                                                       debug_print_flag )
    class(slisvg_slice_mesh_vert_t) <out> :: vert
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    character, dimension(nu,nv) <optin> :: vert_flag
    logical <optin> :: debug_print_flag
                       ! 'i' : inside the boundary
                       ! 'o' : outside the boundary
                       ! 'b' : boundary
    !!>
        case 1  境界上の値がカドの点も含めて設定されている場合

                  b b b b b b b b b 
                  b i i i i i i i b
                  b i i i i i i i b
                  b i i i i i i i b
                  b b b b b b b b b 

        case 2  境界上のカドの点には値が設定されていない場合


                        <--- 
                  o b b b b b b b o
              |   b i i i i i i i b  ^
              |   b i i i i i i i b  |
              v   b i i i i i i i b  |
                  o b b b b b b b o 
                        --->

        case 3a  境界が長方形でないが、カドは直角の場合
        
                  o o o b b b b b o
                  b b b b i i i b o
                  b i i i i i i b o
                  b b b b i i i b o
                  o o o b b b b b o
        

        case 3b  直角ではないカドがある場合

                  o o o o b o o o o
                  o o o b i b o o o
                  o o b i i i b o o
                  o b i i i i b o o
                  o o b b b b b o o
    !!<
    real :: u_min, u_max
    real :: v_min, v_max

    u_min = grid_pos_u(1)
    u_max = grid_pos_u(nu)
    v_min = grid_pos_v(1)
    v_max = grid_pos_v(nv)

    call slisvg__assert( u_max > u_min,       &
                        '__MODLINE__: Invalid coords u.' )
    call slisvg__assert( v_max > v_min,       &
                        '__MODLINE__: Invalid coords v.' )

    vert.nu = nu
    vert.nv = nv
    vert.u_min = u_min
    vert.u_max = u_max
    vert.v_min = v_min
    vert.v_max = v_max

    allocate(vert.pos_u(nu))
    allocate(vert.pos_v(nv))
    allocate(vert.flag(nu,nv))
    allocate(vert.octa_direct(nu,nv))

    vert.pos_u(:) = grid_pos_u(:)
    vert.pos_v(:) = grid_pos_v(:)

    if ( present(vert_flag) ) then
      vert.flag(:,:) = vert_flag(:,:)
      if ( present(debug_print_flag) ) then
        call vert.grid_flag_check( debug_print_flag )
      else
        call vert.grid_flag_check
      end if
    else
      call set_default_vert_flag( nu, nv, vert.flag )      
    end if

    if ( present(debug_print_flag) ) then
      if ( debug_print_flag ) then
        call vert.debug_print_flag
      end if
    end if
  end subroutine slisvg_slice_mesh__vert_initialize


  subroutine slisvg_slice_mesh__vert_finalize( vert )
    class(slisvg_slice_mesh_vert_t) <io> :: vert

    deallocate(vert.pos_u)
    deallocate(vert.pos_v)
    deallocate(vert.flag)
    deallocate(vert.octa_direct)
  end subroutine slisvg_slice_mesh__vert_finalize



  subroutine slisvg_slice_mesh__edge_initialize( edge, vert )
    class(slisvg_slice_mesh_edge_t) <out> :: edge
    type(slisvg_slice_mesh_vert_t) <io> :: vert
    !!>
                            edgev                                    
                              |
                              |
                              +---- edgeu

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
    !!<
  
    integer :: u_nu, u_nv, v_nu, v_nv

    u_nu = vert.nu - 1
    u_nv = vert.nv
    v_nu = vert.nu
    v_nv = vert.nv - 1

    edge.u_nu = u_nu
    edge.u_nv = u_nv
    edge.v_nu = v_nu
    edge.v_nv = v_nv

    allocate(edge.u_quarter(u_nu,u_nv))
    allocate(edge.v_quarter(v_nu,v_nv))
    allocate(edge.a_quarter(u_nu,v_nv))
    allocate(edge.d_quarter(u_nu,v_nv))
    allocate(edge.u_cross_coord(u_nu,u_nv))
    allocate(edge.v_cross_coord(v_nu,v_nv))
    allocate(edge.a_cross_coord_u(u_nu,v_nv))
    allocate(edge.a_cross_coord_v(u_nu,v_nv))
    allocate(edge.d_cross_coord_u(u_nu,v_nv))
    allocate(edge.d_cross_coord_v(u_nu,v_nv))
    allocate(edge.u_is_boundary(u_nu,u_nv))
    allocate(edge.v_is_boundary(v_nu,v_nv))
    allocate(edge.a_is_boundary(u_nu,v_nv))
    allocate(edge.d_is_boundary(u_nu,v_nv))
  end subroutine slisvg_slice_mesh__edge_initialize


  subroutine slisvg_slice_mesh__edge_finalize( edge )
    class(slisvg_slice_mesh_edge_t) <io> :: edge

    deallocate(edge.u_quarter)
    deallocate(edge.v_quarter)
    deallocate(edge.a_quarter)
    deallocate(edge.d_quarter)
    deallocate(edge.u_cross_coord)
    deallocate(edge.v_cross_coord)
    deallocate(edge.a_cross_coord_u)
    deallocate(edge.a_cross_coord_v)
    deallocate(edge.d_cross_coord_u)
    deallocate(edge.d_cross_coord_v)
  end subroutine slisvg_slice_mesh__edge_finalize


  subroutine slisvg_slice_mesh__boundary_edge_init( b_edge, num_boundary_vert )
    class(slisvg_slice_mesh_boundary_edge_t) <out> :: b_edge
    integer <in> :: num_boundary_vert

    b_edge.num = num_boundary_vert

    allocate(         b_edge.type(b_edge.num))
    allocate(           b_edge.ei(b_edge.num))
    allocate(           b_edge.ej(b_edge.num))
    allocate(      b_edge.quarter(b_edge.num))
    allocate(b_edge.cross_coord_u(b_edge.num))
    allocate(b_edge.cross_coord_v(b_edge.num))
  end subroutine slisvg_slice_mesh__boundary_edge_init


  subroutine slisvg_slice_mesh__boundary_edge_finalize( b_edge )
    class(slisvg_slice_mesh_boundary_edge_t) <io> :: b_edge

    deallocate(b_edge.type)
    deallocate(b_edge.ei)
    deallocate(b_edge.ej)
    deallocate(b_edge.quarter)
    deallocate(b_edge.cross_coord_u)
    deallocate(b_edge.cross_coord_v)
  end subroutine slisvg_slice_mesh__boundary_edge_finalize


  subroutine set_edge_quarter( vert,       &
                               val_vert,   &
                               level,      &
                               edge )
    type(slisvg_slice_mesh_vert_t) <in> :: vert
    real, dimension(vert.nu,vert.nv) <in> :: val_vert
    real <in> :: level
    type(slisvg_slice_mesh_edge_t) <io> :: edge
    !!>
        Here we compare the scalar field value "vert_val" 
        on each vertex at (i,j) 

                  val_vert(i,j)

        with "level" of the target contour. The comparison
        is applied on every edge. 

        There are two kinds of edges, vertical edges (edgve_v)
        and horizontal edges (edge_u).

                         v ("vertical")
                         |
                         |
                         +----- u ("horizontal")

              edge_u
            o--------o
            |        |
     edge_v |        | edge_v
            |        |
            o--------o
              edge_u

        Every edge is labeled by a pair of indeces
        in u and v directions, (ei,ej), while every
        vertex is also labeled by a pair of indeces.

        The two kinds of indexes are related by the
        following figure.

                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)

        Now we denote a vertex binary label
        p (plus) or m (minus); "p" when
                  val_vert(i,j) > level,
        and "m" when 
                  val_vert(i,j) < level.

        And we assign a quarter (four) label
        for every edge as

              Edge    | quarter
          ------------+--------
             m----m   |  0
             m----p   |  1
             p----m   |  2
             p----p   |  3

        For example,
                    MM
                m--------m
                |        |
             PM |        | MM
                |        |
                p--------m
                    PM

        =====
              Case MM

                The path does not cross this edge.
                         ei   ei+1
                          |    |      .      
                      ----M====M---.---- level
                          |    |._______ val_vert(ei+1,ej)
                          |  . |
                          .----|-------- val_vert(ei,ej)
                       .  |    |

              Case PP

                The path does not cross this edge.
                But special care would be taken when
                this edge is on the boundary (ej=1 or u_nv).
                          .
                          |    . 
                      ----P====P----.------ level
                         ei   ei+1       .

              Case PM

                The path goes through the edge.
                     .
                       .       u2
                       | .     |
                   ----p===.===m----
                       |   | . |
                      u1   |   .
                           |     .
                          u=ui

              Case MP

                The path goes through the edge, too.
                                 .
                       u1      . 
                       |     . |
                   ----m===.===p----
                       | . |   |
                       .   |   u2
                     .     |     
                          u=ui
        =====
    !!<

    integer :: ei, ej  ! edge indexes.
    integer :: vi, vi_left, vi_right
    integer :: vj, vj_lower, vj_upper
    integer :: vi_ll, vj_ll, vi_ur, vj_ur
    integer :: vi_ul, vj_ul, vi_lr, vj_lr
    real :: val_left, val_right
    real :: val_lower, val_upper
    real :: val_ll, val_ur
    real :: val_ul, val_lr

    ! edge_u
    do ej = 1, edge.u_nv  
      do ei = 1, edge.u_nu
        vi_left  = ei
        vi_right = ei + 1
        vj = ej
        val_left  = val_vert(vi_left,  vj)  ! left vert
        val_right = val_vert(vi_right, vj)  ! right vert
        if ( vert.flag(vi_left, vj) == 'o' .or.  &
             vert.flag(vi_right,vj) == 'o' ) then
          edge.u_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
        else
          edge.u_quarter(ei,ej) = quarter_of_edge_ends( val_left,   &
                                                        val_right,  &
                                                        level )
        end if
      end do
    end do

    ! edge_v
    do ej = 1, edge.v_nv  
      do ei = 1, edge.v_nu
        vi = ei
        vj_lower = ej
        vj_upper = ej + 1
        val_lower = val_vert(vi,vj_lower)  ! lower vert
        val_upper = val_vert(vi,vj_upper)  ! upper vert
        if ( vert.flag(vi,vj_lower) == 'o' .or.  &
             vert.flag(vi,vj_upper) == 'o' ) then
          edge.v_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
        else
          edge.v_quarter(ei,ej) = quarter_of_edge_ends( val_lower,  &
                                                        val_upper,  &
                                                        level )
        end if
      end do
    end do    

    ! edge_a
    do ej = 1, edge.v_nv  
      do ei = 1, edge.u_nu
        vi_ll = ei      ! lower-left
        vj_ll = ej
        vi_ur = ei + 1  ! upper-right
        vj_ur = ej + 1
        val_ll = val_vert(vi_ll,vj_ll)  ! lower-left vert
        val_ur = val_vert(vi_ur,vj_ur)  ! upper-right vert
        if ( vert.flag(vi_ll,vj_ll) == 'o' .or.  &
             vert.flag(vi_ur,vj_ur) == 'o' ) then
          edge.a_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
        else
          edge.a_quarter(ei,ej) = quarter_of_edge_ends( val_ll,  &
                                                        val_ur,  &
                                                        level )
        end if
      end do
    end do    

    ! edge_d
    do ej = 1, edge.v_nv  
      do ei = 1, edge.u_nu
        vi_ul = ei      ! upper-left
        vj_ul = ej + 1
        vi_lr = ei + 1  ! lower-right
        vj_lr = ej    
        val_ul = val_vert(vi_ul,vj_ul)  ! lower-left vert
        val_lr = val_vert(vi_lr,vj_lr)  ! upper-right vert
        if ( vert.flag(vi_ul,vj_ul) == 'o' .or.  &
             vert.flag(vi_lr,vj_lr) == 'o' ) then
          edge.d_quarter(ei,ej) = SLISVG_SLICE_MESH__EDGE_MM
        else
          edge.d_quarter(ei,ej) = quarter_of_edge_ends( val_ul,  &
                                                        val_lr,  &
                                                        level )
        end if
      end do
    end do    
  end subroutine set_edge_quarter


  subroutine slisvg_slice_mesh__edge_set_quarter( edge, vert,       &
                                                        val_vert,   &
                                                        level )
    class(slisvg_slice_mesh_edge_t) <io> :: edge
    type(slisvg_slice_mesh_vert_t) <in> :: vert
    real, dimension(vert.nu,vert.nv) <in> :: val_vert
    real <in> :: level

    edge.u_quarter(:,:) = -999  ! Any negative. Note that
    edge.v_quarter(:,:) = -999  ! QUATER_MM, MP, PM, PP are
                                ! all positive.

    call set_edge_quarter( vert, val_vert, level, edge )
    call set_edge_cross_coord( vert, val_vert, level, edge )
    call slisvg__assert( minval(edge.u_quarter) >= 0,  &
                         "__MODLINE__: You missed some edge_u.quarter" )
    call slisvg__assert( minval(edge.v_quarter) >= 0,  &
                         "__MODLINE__: You missed some edge_v.quarter" )
  end subroutine slisvg_slice_mesh__edge_set_quarter  


  function quarter_pm_and_mp_swap( quarter ) result(ans)
    integer <in> :: quarter
    integer :: ans

    select case (quarter)
      case (SLISVG_SLICE_MESH__EDGE_PM)
        ans = SLISVG_SLICE_MESH__EDGE_MP
      case (SLISVG_SLICE_MESH__EDGE_MP ) 
        ans = SLISVG_SLICE_MESH__EDGE_PM
      case default
        ans = quarter
        ! do nothing for PP and MM cases
    end select
  end function quarter_pm_and_mp_swap


  subroutine slisvg_slice_mesh__boundary_set_quarter( boundary, vert,  &
                                                                edge )
    class(slisvg_slice_mesh_boundary_t) <io> :: boundary
    type(slisvg_slice_mesh_vert_t) <in> :: vert
    type(slisvg_slice_mesh_edge_t) <in> :: edge

    integer :: index_e           ! edge index
    integer :: index_v           ! vert index for both ends
    integer :: vi, vj, ei, ej
    real :: u, v, cross_u, cross_v
    integer :: quarter
    logical :: pm_define_direct_reversed
    integer :: quarter_along_path
    integer :: octa_direct

    boundary.edge.cross_coord_u(:) = NAN
    boundary.edge.cross_coord_v(:) = NAN
      !!> 
           To catch errornous cases in which a contour
           path tries to cross a non PM or MP edge.
      !!<

    boundary.edge.quarter(:) = -999  ! Any negative (anomourous) number.

    !!>
              v6--[e5]--v5--[e4]--v4
              /                    /
            [e6]                 [e3]
            /                    /
           v1--[e1]--v2--[e2]--v3
    !!<

    do index_e = 1, boundary.vert.num ! boundary verts num (= edge num)
      index_v = index_e
      octa_direct = boundary.vert.octa_direct(index_v)
      vi = boundary.vert.vi(index_v)
      vj = boundary.vert.vj(index_v)
      ei = boundary.edge.ei(index_e)
      ej = boundary.edge.ej(index_e)
      u = vert.pos_u(vi)
      v = vert.pos_v(vj)
      select case (octa_direct)
        case (0)
          pm_define_direct_reversed = .false.
          quarter = edge.v_quarter(ei,ej)
        case (1)
          pm_define_direct_reversed = .false.
          quarter = edge.a_quarter(ei,ej)
        case (2)
          pm_define_direct_reversed = .false.
          quarter = edge.u_quarter(ei,ej)
        case (3)
          pm_define_direct_reversed = .false.
          quarter = edge.d_quarter(ei,ej)
        case (4)
          pm_define_direct_reversed = .true.
          quarter = edge.v_quarter(ei,ej)
        case (5)
          pm_define_direct_reversed = .true.
          quarter = edge.a_quarter(ei,ej)
        case (6)
          pm_define_direct_reversed = .true.
          quarter = edge.u_quarter(ei,ej)
        case (7)
          pm_define_direct_reversed = .true.
          quarter = edge.d_quarter(ei,ej)
        case default
          call slisvg__fatal( "__MODLINE__: " // &
                          "case error." )
      end select

      call slisvg__assert( quarter >= 0,  &
                           "__MODLINE__: " //    &
                           "Anomalous quarter value." )

      if ( pm_define_direct_reversed ) then
        quarter_along_path = quarter_pm_and_mp_swap( quarter )
      else
        quarter_along_path = quarter
      end if

      boundary.edge.quarter(index_e) = quarter_along_path
      if ( quarter_along_path == SLISVG_SLICE_MESH__EDGE_PM ) then
        ! Only PM case.
        select case (octa_direct)
          case (0)
            cross_u = u
            cross_v = edge.v_cross_coord(ei,ej)
            call slisvg__assert( cross_v /= NAN,     &
                                 "__MODLINE__: " //  &
                                 "not a PM edge?" )
          case (1)
            cross_u = edge.a_cross_coord_u(ei,ej)
            cross_v = edge.a_cross_coord_v(ei,ej)
            call slisvg__assert( cross_u /= NAN .and.       &
                                 cross_v /= NAN,            &
                                 "__MODLINE__: " //         &
                                 "not a PM edge?" )
          case (2)
            cross_u = edge.u_cross_coord(ei,ej)
            cross_v = v
            call slisvg__assert( cross_u /= NAN,            &
                                 "__MODLINE__: " //         &
                                 "not a PM edge?" )
          case (3)
            cross_u = edge.d_cross_coord_u(ei,ej)
            cross_v = edge.d_cross_coord_v(ei,ej)
            call slisvg__assert( cross_u /= NAN .and.       &
                                 cross_v /= NAN,            &
                                 "__MODLINE__: " //         &
                                 "not a PM edge?" )
          case (4)
            cross_u = u
            cross_v = edge.v_cross_coord(ei,ej)
            call slisvg__assert( cross_v /= NAN,            &
                                 "__MODLINE__: " //         &
                                 "not a PM edge?" )
          case (5)
            cross_u = edge.a_cross_coord_u(ei,ej)
            cross_v = edge.a_cross_coord_v(ei,ej)
            call slisvg__assert( cross_u /= NAN .and.       &
                                 cross_v /= NAN,            &
                                 "__MODLINE__: " //         &
                                 "not a PM edge?" )
          case (6)
            cross_u = edge.u_cross_coord(ei,ej)
            cross_v = v
            call slisvg__assert( cross_u /= NAN,            &
                                 "__MODLINE__: " //         &
                                 "not a PM edge?" )
          case (7)
            cross_u = edge.d_cross_coord_u(ei,ej)
            cross_v = edge.d_cross_coord_v(ei,ej)
            call slisvg__assert( cross_u /= NAN .and.       &
                                 cross_v /= NAN,            &
                                 "__MODLINE__: " //         &
                                 "not a PM edge?" )
          case default
            call slisvg__fatal( "__MODLINE__: " //          &
                                "case error." )
        end select

        boundary.edge.cross_coord_u(index_e) = cross_u
        boundary.edge.cross_coord_v(index_e) = cross_v
      end if        
    end do    

  end subroutine slisvg_slice_mesh__boundary_set_quarter  


  subroutine set_edge_cross_coord( vert, val_vert, level, edge )
    type(slisvg_slice_mesh_vert_t) <in> :: vert
    real, dimension(vert.nu,vert.nv) <in> :: val_vert
    real <in> :: level
    type(slisvg_slice_mesh_edge_t) <io> :: edge
    !!> 
            .                                 .
              .       u2            u1      . 
              | .     |             |     . |
          ----p===.===m----     ----m===.===p----
              |   | . |             | . |   |
              u1  |   .             .   |   u2
                  |     .         .     |  
                  u=ui                  u=ui
    !!<
    real :: u_left, u_right
    real :: v_lower, v_upper
    real :: diff_left, diff_right
    real :: diff_lower, diff_upper
    integer :: ei, ej, quarter
    integer :: vi, vi_left,  vi_right
    integer :: vj, vj_lower, vj_upper

    integer :: vi_ll, vj_ll, vi_ur, vj_ur
    integer :: vi_ul, vj_ul, vi_lr, vj_lr
    real :: u_ll, v_ll, u_ur, v_ur
    real :: u_ul, v_ul, u_lr, v_lr
    real :: diff_ll, diff_ur
    real :: diff_ul, diff_lr

    edge.u_cross_coord(:,:) = NAN 
    edge.v_cross_coord(:,:) = NAN 
    edge.a_cross_coord_u(:,:) = NAN 
    edge.a_cross_coord_v(:,:) = NAN 
    edge.d_cross_coord_u(:,:) = NAN 
    edge.d_cross_coord_v(:,:) = NAN 
      !!> 
           To catch errornous cases in which a contour
           path tries to cross a non PM or MP edge.
      !!<

    ! edge_u
    do ej = 1, edge.u_nv
      do ei = 1, edge.u_nu
        vi_left  = ei
        vi_right = ei + 1
        vj = ej
        quarter = edge.u_quarter(ei,ej)
        if ( quarter == SLISVG_SLICE_MESH__EDGE_MP .or.  &
             quarter == SLISVG_SLICE_MESH__EDGE_PM ) then
          u_left  = vert.pos_u(vi_left)   ! left vert
          u_right = vert.pos_u(vi_right)  ! right vert
          diff_left  = val_vert(vi_left,vj) - level
          diff_right = level - val_vert(vi_right,vj)
          call slisvg__assert( diff_left * diff_right >= 0.0,   &
                               "__MODLINE__: Not a PM/MP edge?" )
          ! The following linter interpol is valid both
          ! for diff_left > 0 and < 0 cases.
          edge.u_cross_coord(ei,ej) = linear_interpol( u_left,      &
                                                       u_right,     &
                                                       diff_left,   &
                                                       diff_right )
        end if
      end do
    end do

    ! edge_v
    do ej = 1, edge.v_nv
      do ei = 1, edge.v_nu
        vi = ei
        vj_lower = ej
        vj_upper = ej + 1
        quarter = edge.v_quarter(ei,ej)
        if ( quarter == SLISVG_SLICE_MESH__EDGE_MP  .or.  &
             quarter == SLISVG_SLICE_MESH__EDGE_PM ) then
          v_lower = vert.pos_v(vj_lower)  ! lower vert
          v_upper = vert.pos_v(vj_upper)  ! upper vert
          diff_lower = val_vert(vi,vj_lower) - level
          diff_upper = level - val_vert(vi,vj_upper)
          call slisvg__assert( diff_lower * diff_upper >= 0.0,   &
                               "__MODLINE__: Not a PM/MP edge?" )
          edge.v_cross_coord(ei,ej) = linear_interpol( v_lower,    &
                                                       v_upper,    &
                                                       diff_lower, &
                                                       diff_upper )
        end if
      end do
    end do    

    ! edge_a
    do ej = 1, edge.v_nv
      do ei = 1, edge.u_nu
        vi_ll = ei       ! lower-left
        vj_ll = ej
        vi_ur = ei + 1   ! upper-right
        vj_ur = ej + 1
        quarter = edge.a_quarter(ei,ej)
        if ( quarter == SLISVG_SLICE_MESH__EDGE_MP  .or.  &
             quarter == SLISVG_SLICE_MESH__EDGE_PM ) then
          u_ll = vert.pos_u(vi_ll)
          v_ll = vert.pos_v(vj_ll)
          u_ur = vert.pos_u(vi_ur)
          v_ur = vert.pos_v(vj_ur)
          diff_ll = val_vert(vi_ll,vj_ll) - level
          diff_ur = level - val_vert(vi_ur,vj_ur)
          call slisvg__assert( diff_ll * diff_ur >= 0.0,   &
                               "__MODLINE__: Not a PM/MP edge?" )
          edge.a_cross_coord_u(ei,ej) = linear_interpol( u_ll,    &
                                                         u_ur,    &
                                                         diff_ll, &
                                                         diff_ur )
          edge.a_cross_coord_v(ei,ej) = linear_interpol( v_ll,    &
                                                         v_ur,    &
                                                         diff_ll, &
                                                         diff_ur )
        end if
      end do
    end do    

    ! edge_d
    do ej = 1, edge.v_nv
      do ei = 1, edge.u_nu
        vi_ul = ei       ! upper-left
        vj_ul = ej + 1
        vi_lr = ei + 1   ! loer-right
        vj_lr = ej
        quarter = edge.d_quarter(ei,ej)
        if ( quarter == SLISVG_SLICE_MESH__EDGE_MP  .or.  &
             quarter == SLISVG_SLICE_MESH__EDGE_PM ) then
          u_ul = vert.pos_u(vi_ul)
          v_ul = vert.pos_v(vj_ul)
          u_lr = vert.pos_u(vi_lr)
          v_lr = vert.pos_v(vj_lr)
          diff_ul = val_vert(vi_ul,vj_ul) - level
          diff_lr = level - val_vert(vi_lr,vj_lr)
          call slisvg__assert( diff_ul * diff_lr >= 0.0,   &
                               "__MODLINE__: Not a PM/MP edge?" )
          edge.d_cross_coord_u(ei,ej) = linear_interpol( u_ul,    &
                                                         u_lr,    &
                                                         diff_ul, &
                                                         diff_lr )
          edge.d_cross_coord_v(ei,ej) = linear_interpol( v_ul,    &
                                                         v_lr,    &
                                                         diff_ul, &
                                                         diff_lr )
        end if
      end do
    end do    

  end subroutine set_edge_cross_coord

end module slisvg_slice_mesh_m
