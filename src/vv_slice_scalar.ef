module vv_slice_scalar_m
  !!>
      vv_slice_scalar.ef

      Visualize 2-dimensional cross sections 
      of 3- (or more) dimensional simulation data.

      Draw contour lines for scalar fields.

      Draw vector arrow glyphs for vector fields.
      
      In this module, positions are specified by the
      simulation coordinates (u,v) with simulation unit
      such as meters.

  !!< 
  use vv_color_m
  use ut_m
  use vv_slice_mesh_m
  use vv_slice_isoline_m
  use vv_sketch_m
  implicit none
  private

  integer <const> :: TAG_NAME_MAX = 100

  type, public :: vv_slice_scalar_t
    char(len=TAG_NAME_MAX) :: tag
    type(vv_slice_mesh_t) :: mesh
    real, dimension(:,:), allocatable :: val_vert
    real :: val_vert_max, val_vert_min
  contains
    procedure :: initialize => vv_slice_scalar__initialize
    procedure :: finalize => vv_slice_scalar__finalize
    procedure :: set_val => vv_slice_scalar__set_val
    procedure :: vis_contour => vv_slice_scalar__vis_contour
  end type vv_slice_scalar_t


contains


  subroutine vv_slice_scalar__vis_contour( scalar,          &
                                           vv_sketch,       &
                                           level,           &
                                           width_in_pixels, &
                                           line_color,      &
                                           fill_color )
    class(vv_slice_scalar_t) <io> :: scalar
    type(vv_sketch_t) <io> :: vv_sketch
    real <in> :: level
    real <optin> :: width_in_pixels
    type(vv_color_t) <optin> :: line_color
    type(vv_color_t) <optin> :: fill_color

    integer :: nu, nv
    type(vv_slice_isoline_t), save :: vv_slice_isoline
    logical :: just_once = .true.
    char(len=10) :: status
    type(vv_sketch__sim_pos_t), dimension(:), allocatable, save :: verts_sim
    character, dimension(:), allocatable, save :: path_directive
    character :: SVG_directive
    integer :: i, counter
    real :: u_sim, v_sim, dummy

    ==<just_once>==
      nu = scalar.mesh.vert.nu
      nv = scalar.mesh.vert.nv
      call vv_slice_isoline.initialize( nu, nv )
!debugp 'called vv_slice_isoline.initialize'
      allocate(verts_sim(nu*nv))
      allocate(path_directive(nu*nv))
    ==</just_once>==

!debugp 'calling scalar.mesh.edge.set_quarter'
    call scalar.mesh.edge.set_quarter( scalar.mesh.vert,  &
                                       scalar.val_vert,   &
                                       level )

    call scalar.mesh.boundary.set_quarter( scalar.mesh.vert,  &
                                           scalar.mesh.edge )
    call vv_slice_isoline.reset
!debugp 'calling vv_slice_isoline.set_start_edge'
    call vv_slice_isoline.set_start_edge( scalar.mesh.vert,     &
                                          scalar.mesh.edge,     &
                                          scalar.mesh.boundary, &
                                          status )
!debugp '  ', status
    counter = 0
    do while ( status == 'have found' )
      !!  Tring to find the 1st contour for this level.
!debugp '  calling vv_slice_isoline.trace_and_erase'
      call vv_slice_isoline.trace_and_erase( scalar.mesh.vert,    &
                                             scalar.mesh.edge,    &
                                             scalar.mesh.boundary )
!debugp '    ', vv_slice_isoline.num
      call  ut__assert( vv_slice_isoline.num >= 2,  &
                        "__MODULE__(__LINE__): Path too short." )
        
      do i = 1, vv_slice_isoline.num
!debugp '    ', i
        counter += 1
        if ( i == 1 ) then
          SVG_directive = 'M' ! Move to 
        else if ( i == 2 ) then
          SVG_directive = 'L' ! Line to
        else
          SVG_directive = ' ' ! Line to (You can ommit this after 1st 'L'.)
        end if
        path_directive(counter) = SVG_directive 
        u_sim = vv_slice_isoline.list_u(i)
        v_sim = vv_slice_isoline.list_v(i)
        verts_sim(counter) = vv_sketch__sim_pos_t(u_sim,v_sim)
      end do

      ! To close the path
      counter += 1
      path_directive(counter) = 'Z' ! Close the sub-path.
      dummy = 0.0  ! any number
      verts_sim(counter) = vv_sketch__sim_pos_t( dummy, dummy )

      !!  Generally, more contours exist for this level.
!debugp '(2nd) vv_slice_isoline.reset'
      call vv_slice_isoline.reset
!debugp '(2nd) calling vv_slice_isoline.set_start_edge'
      call vv_slice_isoline.set_start_edge( scalar.mesh.vert,     &
                                            scalar.mesh.edge,     &
                                            scalar.mesh.boundary, &
                                            status )
    end do

    if ( counter > 1 ) then
      call vv_sketch.path( counter,             &
                           path_directive,      &
                           verts_sim,           &
                           width_in_pixels,     &
                           line_color,          &
                           fill_color )      
    end if

  end subroutine vv_slice_scalar__vis_contour



  subroutine vv_slice_scalar__initialize( scalar, tag,        &
                                                  nu, nv,     &
                                                  grid_pos_u, &
                                                  grid_pos_v, &
                                                  val,        &
                                                  grid_flag )
    class(vv_slice_scalar_t) <out> :: scalar
    char(len=*) <in> :: tag
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    real, dimension(nu,nv) <optin> :: val
    character, dimension(nu,nv) <optin> :: grid_flag

    allocate(scalar.val_vert(nu,nv))

    scalar.tag = tag

    call ut__assert( size(grid_pos_u,dim=1) == nu .and. &
                     size(grid_pos_v,dim=1) == nv,      &
                     "__MODULE__(__LINE__): " //        &
                     "grid size inconsistent." )


    call scalar.mesh.initialize( nu, nv,     &
                                 grid_pos_u, &
                                 grid_pos_v, &
                                 grid_flag )

    if ( present(val) ) then
      scalar.val_vert(:,:) = val(:,:)
    else
      scalar.val_vert(:,:) = 0.0
    end if

  end subroutine vv_slice_scalar__initialize


  subroutine vv_slice_scalar__set_val( scalar, nu, nv, val )
    class(vv_slice_scalar_t) <io> :: scalar
    integer <in> :: nu, nv
    real, dimension(nu,nv) <in> :: val

    scalar.val_vert(:,:) = val(:,:)
    scalar.val_vert_max = maxval(val)
    scalar.val_vert_min = minval(val)
  end subroutine vv_slice_scalar__set_val


  subroutine vv_slice_scalar__finalize( scalar )
    class(vv_slice_scalar_t) <io> :: scalar

    deallocate(scalar.val_vert)
    call scalar.mesh.finalize
  end subroutine vv_slice_scalar__finalize

end module vv_slice_scalar_m

