  !!>
      In physical coordinate system.
  !!< 
module slice_m
  use ut_m
  use slice_mesh_m
  use contour_path_m
  implicit none
  private


  type, public :: slice__scalar_t
    type(slice_mesh_vert_t) :: mesh_vert
    type(slice_mesh_cell_t) :: mesh_cell
    type(slice_mesh_edge_t) :: mesh_edge
    real, dimension(:,:), allocatable :: val_vert
    real :: val_vert_max, val_vert_min
  contains
    procedure :: initialize => slice__scalar_initialize
    procedure :: finalize => slice__scalar_finalize
    procedure :: set_val => slice__scalar_set_val
    procedure :: vis_contour => slice__scalar_vis_contour
  end type slice__scalar_t

  type, public :: slice__vector_t
    type(slice_mesh_vert_t) :: mesh_vert
    real, dimension(:,:), allocatable :: vect_x
    real, dimension(:,:), allocatable :: vect_y
    real :: amp_max, amp_min
  contains
    procedure :: initialize => slice__vector_initialize
    procedure :: finalize => slice__vector_finalize    
    procedure :: set_val => slice__vector_set_val
  end type slice__vector_t


contains


  subroutine path_vert_explore( this )
    class(path_vert_t) <io> :: this

    integer :: head_i, head_j
    integer :: step_forward_i, step_forward_j
    integer :: step_turn_left_i, step_turn_left_j
    integer :: step_turn_right_i, step_turn_right_j

    !!>
        edge direction from foot-vert to head-vert
                            .
           f-->h   (1,0)    .     f
       ......................     |  (0,-1)
                            .     h   
             h              ...................  
             |     (0,1)    .   
             f              .  h<--f (-1,0)
    !!<

    head_i = this.i(this.num)
    head_j = this.j(this.num)
    foot_i = this.i(this.num-1)
    foot_j = this.j(this.num-1)
    step_forward_i = head_i - foot_i
    step_forward_j = head_j - foot_j
    step_turn_left_i =  -step_forward_j ! Vector
    step_turn_left_j =  +step_forward_i !  outer
    step_turn_right_i = +step_forward_j !   product
    step_turn_right_j = -step_forward_i !    with unit-z.

    if ( step_forward_i==1 ) then
      direct = 'E'
    else if ( step_foward_j==1 ) then
      direct = 'N'
    else if ( step_foward_i==-1) then
      direct = 'W'
    else if ( step_foward_j=-1 )
      direct = 'S'
    else 
      call ut__fatal( 'Something is strange.' )
    end if

    select case (direct)
      case ('E')
        !!>
                             i=hi
                     -o-------o-------o j=hj-1
                      |       |       |
                      |       |<--edgey(hi,hj-1)
                      |       |       |
                     -f======>h-------o j=hj
                              |       |
                              |<--edgey(hi,hj)

        !!<
         
        if ( this.edgey_ternary(head_i,head_j-1) == 1 ) then
          ! turn left


        
  end subroutine path_vert_explore


  subroutine slice__scalar_initialize( this, nu, nv,  &
                                       u_min, u_max,  &
                                       v_min, v_max,  &
                                       val )
    class(slice__scalar_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max
    real, dimension(vert_nu,vert_nv) <optin> :: val

    call this.mesh_vert.initialize( nu, nv,        &
                                    u_min, u_max,  &
                                    v_min, v_max )

    call this.mesh_cell_initialize( this.mesh_vert )
    call this.mesh_edge_initialize( this.mesh_vert )

    if ( present(val) ) then
      this.val_vert(:,:) = val(:,:)
    else
      this.val_vert(:,:) = 0.0
    end if

    call this.mesh_cell.set_meanval( this.mesh_vert,  &
                                     this.val_vert )
  end subroutine slice__scalar_initialize


  subroutine slice__scalar_set_val( this, nu, nv, val )
    class(slice__scalar_t) <io> :: this
    integer <in> :: nu, nv
    real, dimension(nu,nv) <in> :: val

    this.val_vert(:,:) = val(:,:)
    this.val_vert_max = maxval(val)
    this.val_vert_min = minval(val)
    call this.mesh_cell.set_meanval( this.mesh_vert,  &
                                     this.val_vert )
  end subroutine slice__scalar_set_val


  subroutine slice__scalar_finalize( this )
    class(slice__scalar_t) <io> :: this

    deallocate(this.val_vert)
    call this.mesh_vert.finalize
    call this.mesh_cell.finalize
    call this.mesh_edge.finalize
  end subroutine slice__scalar_finalize


  subroutine slice__scalar_vis_contour( this, level )
    class(slice__scalar_t) <in> :: this
    real <in> :: level
    
    !!>
        In the followings, "e" stands for "edge",
        and "c" stands for "cell". "i" is index
        in the u-direction and "j" is in v-direction.
        So, "ei" is edge-index in u and "cj" is 
        cell-index in v.

                    north               
                edgeu(ei=1,ej=4)       +---+---+---+ ej=4
                +------------+ .       | 3 |   |   |
              w | cell(ci,cj)|e  .     +---+---+---+ ej=3
              e |    with    |a    .   | 2 |   |   |
              s |  ci=1,cj=3 |s\     . +---+---+---+ ej=2
              t/|            |t \      | 1 | 2 | 3 |
              / +------------+ ..\.... +---+---+---+ ej=1
             /      / south       \   ei=1 2   3   4 
            /  edgeu(ei=1,ej=3)    \            
           /                        \
        edgev(ei=1,ej=3)           edgev(ei=2,ej=3)

                              edgeu(ei=3,ej=8)
            vert(vi=3,vj=8)   .    vert(vi=4,vj=8)
                         \    .   / 
                          o------o  
            edgev(3,7)....|      |....edgev(ei=4,ej=7)
                          |      |
                          o=====>V
                         /|  .   | \ vert(vi=4,vj=7)
           vert(vi=3,vj=7)|  .   |..............edgev(ei=4,ej=6)   
                             .   o 
              edgeu(ei=3,ej=7)    \
                                   vert(vi=4,vj=6)

        P: positive edge, eastward edgeu / northward edgev
        M: negative edge, westward edgeu / southward edgev
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
    !!<
    logical :: just_once = .true.
    type(contour_path_t), save :: contour_path

    ==<just_once>==
      call contour_path.initialize( this.mesh_vert.nu,  &
                                    this.mesh_vert.nv )
    ==</just_once>==

    call contour_path.reset
    call this.mesh_edge.apply_stokes( this.mesh_cell, level )

    do while ( this.mesh_edge.contour_path_exist() ) 
      call iFind_start_edge( 'E', i_now, j_now )
      call iTrace_path_and_erase_footprint( 'E', i_now, j_now, closed )


    end do


    call iExtract_boundary_curve

  contains


    subroutine iFind_start_edge( direct_now, i_now, j_now )
      char(len=1) :: direct_now
      integer <out> :: i_now, j_now
      !!>
            Tring to find a eastward arrow AB.
                +---+---+---+
                |           |
                A==>B       +
                 /  |       |
                /   +---+---+
               /
             This.
      !!< 
      integer :: ei, ej, v0i, v0j

      call ut__assert( direct_now=='E',  &
                      'We assume start edge is E(astward).' )
      do ej = 1, this.mesh_edge.u_nv
        do ei = 1, this.mesh_edge.u_nu
          if ( this.mesh_edge.u_ternary(ei,ej) == +1 ) then
            ! Found a boundary curve of 'E(astward)' direction.
            v0i = ei ! Vertex indexes of an left-end of
            v0j = ej ! an edge is the same as the edge indexes.
            i_now = v0i + 1
            j_now = v0j
            call contour_path.set_start_position( v0i, v0j )
            call contour_path.register( i_now, j_now ) ! Other end of edge.
            return
          end if
        end do
      end do 
      call ut__fatal( 'Cound not find a start edge.' )
    end subroutine iFind_start_edge

    subroutine iTrace_path_and_erase_footprint( direct_now,  &
                                                i_now,       &
                                                j_now,       &
                                                path_closed )
      char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
      integer <io> :: i_now, j_now
      logical <out> :: path_cloased
      integer :: p 
      logical :: can_turn, path_closed

      path_closed = .false.

      do 
        ! left
        call contour_path.turn_left( 'just check',       &
                                     this.mesh_edge,     &
                                     this.mesh_vert.nu,  &
                                     this.mesh_vert.nv,  &
                                     direct_now,         &
                                     i_now, j_now,       &
                                     ans=can_turn  )
        if ( can_turn ) then
          call contour_path.turn_left( 'do it',            &
                                       this.mesh_edge,     &
                                       this.mesh_vert.nu,  &
                                       this.mesh_vert.nv,  &
                                       direct_now,         &
                                       i_now, j_now,       &
                                       ans=path_closed )
          if ( path_closed ) then
            return
          else
            call contour_path.register( i_now, j_now )
          end if
        end if
        ! right
        call contour_path.turn_right( 'just check',       &
                                      this.mesh_edge,     &
                                      this.mesh_vert.nu,  &
                                      this.mesh_vert.nv,  &
                                      direct_now,         &
                                      i_now, j_now,       &
                                      ans=can_turn )
        if ( can_turn ) then
          call contour_path.turn_right( 'do it',            &
                                        this.mesh_edge,     &
                                        this.mesh_vert.nu,  &
                                        this.mesh_vert.nv,  &
                                        direct_now,         &
                                        i_now, j_now,       &
                                        ans=path_closed  )
          if ( path_closed ) then
            return
          else
            call contour_path.register( i_now, j_now )
          end if
        end if
        ! straight
        call contour_path.go_foward( 'just check',        &
                                      this.mesh_edge,     &
                                      this.mesh_vert.nu,  &
                                      this.mesh_vert.nv,  &
                                      direct_now,         &
                                      i_now, j_now,       &
                                      ans=can_turn )
        if ( can_turn ) then
          call contour_path.go_foward( 'do it',             &
                                        this.mesh_edge,     &
                                        this.mesh_vert.nu,  &
                                        this.mesh_vert.nv,  &
                                        direct_now,         &
                                        i_now, j_now,       &
                                        ans=path_closed  )
          if ( path_closed ) then
            return
          else
          !!>
              We do not need to register the forward-stepped point,
              because the path
                       1---2---3
                               |          
                               4---5---6---7
              is the same as the folowing:
                       1-------2
                               |          
                               3-----------4
          !!<
            ! call contour_path.register( i_now, j_now )
            ! So, we do nothing here.
          end if
        end if
      end do

    end subroutine iTrace_path_and_erase_footprint

    subroutine iCalc_path_turns_from_edges
  
      integer :: i, j
      char(len=4) :: pattern

      do j = 1, this.vert_nv
        do i = 1, this.vert_nu
          if ( i == this.vert_nu ) then
            east_edge = NULL
          else 
            east_edge = this.edgex_ternary(i,j)
          end if
          if ( i == 1 ) then
            west_edge = NULL
          else 
            west_edge = this.edgex_ternary(i-1,j)
          end if
          if ( j == vert_nv ) then
            north_edge = NULL
          else 
            north_edge = this.edgey_ternary(i,j)
          end if 
          if ( j == 1 ) then
            south_edge = NULL
          else
            south_edge = this.edgey_ternary(i,j-1)
          end if

          pattern = neibhbor_edges_pattern( north_edge, &
                                            west_edge,  &
                                            south_edge, &
                                            east_edge )
          select case ( pattern )
                  !'NWSE'
            case ( 'io  ' )
              this.vert_turn(i,j) = 'R'
            case ( ' io ' )
              this.vert_turn(i,j) = 'R'
            case ( '  io' )
              this.vert_turn(i,j) = 'R'
            case ( 'o  i' )
              this.vert_turn(i,j) = 'R'
            case ( 'ioio' )
              this.vert_turn(i,j) = 'R'
            case ( 'ioio' )
              this.vert_turn(i,j) = 'R'

            pattern(1:4) = iChar(n)//iChar(w)//iChar(s)//iChar(e)

          contains 

            function iChar(i)
              integer <in> :: i

              select case(i)
                case ('+1')
                  iChar = 'i' ! inward

          end function neibhbor_edges_pattern

           lect case (west_edge)
            case (+1) ! coming from west
              if ( north_edge == +1 ) then
                this.vert_turn(i,j) = 'L'
              else if ( south_edge == -1 ) then
                this.vert_turn(i,j) = 'R'
              else if ( east_edge == +1 ) then
                this.vert_vect(i,j) = 'S'
              else
                call ut__assert( 'Something is wrong.' )
              end if
            case (-1) ! coming from east
              if ( north_edge == +1 ) then
                this.vert_turn(i,j) = 'R'
              else 
          
    end subroutine iCalc_path_turns_from_edges

    subroutine iExtract_boundary_curve
      integer :: i, j  ! edges indexes
      integer :: path_vert_i, path_vert_j
      integer :: path_vert_num

      type(contour_path_t) :: contour_path
      integer :: max_path_segment_num_overestimate
      logical :: just_once = .true.



      ==<just_once>==
        max_path_segment_num_overestimate = this.edge_nu*edge_nv
        call contour_path.initialize( max_path_segment_num_overestimate, &
                                      this.vert_nu,  &
                                      this.vert_nv )
      ==</just_once>==

      call contour_path.reset


!      if ( contour_path.num == 0 ) return  ! No contour

      loops_to_folow_the_path : &
        direct_now = 'E'
        
        do ej = 1, this.grid.edgex_nv
          do ei = 1, this.grid.edgex_nu
            if ( this.grid.edgex_ternary(ei,ej) == +1 ) then
              ! Found a boundary curve of 'E(astward)' direction.
              v0i = ei ! Vertex indexes of an left-end of
              v0j = ej ! an edge is the same as the edge indexes.
              v1i = v0i + 1
              v1j = v0j
              call contour_path.set_start_position( v0i, v0j )
              call path_vert.register( v1i, v1j ) ! Other end of edge.
              exit finding_loops
            end if
          end do
        end do &
      loops_to_folow_the_path
      


      call path_vert.follow( )

      select case (vtip_direct)
        case '+x'
          !!>
                          edgex(ei=3,ej=8)
            vert(vi=3,vj=8)   .
                         \    .      
                          o------o  
            edgey(3,7)....|      |....edgey(4,7)
                          |      |
                          o------o
                         /   .    \
            vert(vi=3,vj=7)  .     vert(vi=4,vj=7)
                           edgex(ei=3,ej=7)
          !!<
          if ( this.grid_edgey_tenary(ei+1,ej) == +1 ) then
            ! turn to "up"
            call path_vert.register( vtip_i, vtip_j )
            vtip_direct = '+y'
            exit
          else if ( this.grid_edgey_tenary(ei+1,ej-1) == -1 ) then
            ! turn ton "down"
            call path_vert.register( vtip_i, vtip_j )
            vtip_direct = '-y'
            exit
          else 
            call ut__assert( this.grid_edgex_ternary(ei+1,ej) == +1,  &
                            'Something is strange.' )
            
          end if
          
          next_ej = ej - 1
          next_left_i = vtip_i
          next_left_j = vtip_j-1
          if ( this.grid.edgey_ternary( 'vtip_i,vtip_j))
          

      if ( step_forward_i==1 ) then
        direct = 'E'
      else if ( step_foward_j==1 ) then
        direct = 'N'
      else if ( step_foward_i==-1) then
        direct = 'W'
      else if ( step_foward_j=-1 )
        direct = 'S'
      else 
        call ut__fatal( 'Something is strange.' )
      end if



      call path_vert.set_tip( 'x', )  !   B of A===>B
      j = path_vert_j       !       
      do while ( i /= path_vert_i .and.  &
                 j /= path_vert_j )
        call path.vert_add( i, j )
        path_vert_num += 1
        path_vert_i(path_vert_num) = i
        patH-vert_j(path_vert_num) = j


            

    end subroutine iExtract_boundary_curve

  end subroutine slice__scalar_draw_contour


  subroutine slice__vector_initialize( this,        &
                                       vert_nu,     &
                                       vert_nv,     &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       vect_x,      &
                                       vect_y )
    class(slice__vector_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) <optin> :: vect_x, vect_y

    real, dimension(vert_nu,vert_nv) :: amp_vect

    call this.grid.initialize( vert_nu,     &
                               vert_nv,     &
                               vert_u_min,  &
                               vert_u_max,  &
                               vert_v_min,  &
                               vert_v_max )
    allocate(this.vect_x(vert_nu,vert_nv))
    allocate(this.vect_y(vert_nu,vert_nv))

    if ( present(vect_x) ) then
      this.vect_x(:,:) = vect_x(:,:)
    else
      this.vect_x(:,:) = 0.0
    end if

    if ( present(vect_y) ) then
      this.vect_y(:,:) = vect_y(:,:)
    else
      this.vect_y(:,:) = 0.0
    end if

    amp_vect = sqrt(vect_x**2+vect_y**2)

    this.amp_max = maxval(amp_vect)
    this.amp_min = minval(amp_vect)
  end subroutine slice__vector_initialize

  
  subroutine slice__vector_finalize( this )
    class(slice__vector_t) <out> :: this

    deallocate(this.vect_x)
    deallocate(this.vect_y)
    call this.grid.finalize
  end subroutine slice__vector_finalize


  subroutine slice__vector_set_val( this, vect_x, vect_y )
    class(slice__vector_t) <io> :: this
    real, dimension(vert_nu,vert_nv) <in> :: vect_x, vect_y

    this.vect_x(:,:) = vect_x(:,:)
    this.vect_y(:,:) = vect_y(:,:)
  end subroutine slice__vector_set_val

end module slice_m

