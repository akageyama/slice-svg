!!>
    In physical coordinate system.
!!< 
module slice_m
  use ut_m
  use slice_mesh_m
  use contour_path_m
  implicit none
  private


  type, public :: slice__scalar_t
    type(slice_mesh_vert_t) :: mesh_vert
    type(slice_mesh_cell_t) :: mesh_cell
    type(slice_mesh_edge_t) :: mesh_edge
    real, dimension(:,:), allocatable :: val_vert
    real :: val_vert_max, val_vert_min
  contains
    procedure :: initialize => slice__scalar_initialize
    procedure :: finalize => slice__scalar_finalize
    procedure :: set_val => slice__scalar_set_val
    procedure :: vis_contour => slice__scalar_vis_contour
  end type slice__scalar_t

  type, public :: slice__vector_t
    type(slice_mesh_vert_t) :: mesh_vert
    real, dimension(:,:), allocatable :: vect_x
    real, dimension(:,:), allocatable :: vect_y
    real :: amp_max, amp_min
  contains
    procedure :: initialize => slice__vector_initialize
    procedure :: finalize => slice__vector_finalize    
    procedure :: set_val => slice__vector_set_val
  end type slice__vector_t


contains


  subroutine trace_path_and_erase_trace( edge,         &
                                         vert_nu,      &
                                         vert_nv,      &
                                         direct_now,   &
                                         i_now,        &
                                         j_now )
    type(slice_mesh_edge_t) <in> :: mesh_edge
    integer <in> :: vert_nu, vert_nv
    char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
    integer <in> :: i_now, j_now

    logical :: path_closed
    integer :: i_now_before, j_now_before

    do 
      i_now_before = i_now
      j_now_before = j_now
      !
      call contour_path.turn_left( mesh_edge,     &
                                   vert_nu,       &
                                   vert_nv,       &
                                   direct_now,    &
                                   i_now, j_now,  &
                                   path_closed )
      if ( path_closed ) then
        return
      else
        call contour_path.register( i_now, j_now )
      end if

      !
      ! right
      !
      call contour_path.turn_right( mesh_edge,    &
                                    vert_nu,      &
                                    vert_nv,      &
                                    direct_now,   &
                                    i_now, j_now, &
                                    path_closed )
      if ( path_closed ) then
        return
      else
        call contour_path.register( i_now, j_now )
      end if

      !
      ! straight
      !
      call contour_path.go_foward( mesh_edge,     &
                                   vert.nu,       &
                                   vert.nv,       &
                                   direct_now,    &
                                   i_now, j_now,  &
                                   path_closed )
      if ( path_closed ) then
        return
      else
      !!>
          We do not need to register the forward-stepped point,
          because the path
                   1---2---3
                           |          
                           4---5---6---7
          is the same as
                   1-------2
                           |          
                           3-----------4
      !!<
        ! call contour_path.register( i_now, j_now )
        ! So, we do nothing here.
      end if

      call ut__assert( i_now /= i_now_before .and.  &
                       j_now /= j_now_before,       &
                      'Failed to follow the path?' )
    end do

  end subroutine trace_path_and_erase_trace


  subroutine slice__scalar_initialize( this, nu, nv,  &
                                       u_min, u_max,  &
                                       v_min, v_max,  &
                                       val )
    class(slice__scalar_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max
    real, dimension(vert_nu,vert_nv) <optin> :: val

    call this.mesh_vert.initialize( nu, nv,        &
                                    u_min, u_max,  &
                                    v_min, v_max )

    call this.mesh_cell.initialize( this.mesh_vert )
    call this.mesh_edge.initialize( this.mesh_vert )

    if ( present(val) ) then
      this.val_vert(:,:) = val(:,:)
    else
      this.val_vert(:,:) = 0.0
    end if

    call this.mesh_cell.set_meanval( this.mesh_vert,  &
                                     this.val_vert )
  end subroutine slice__scalar_initialize


  subroutine slice__scalar_set_val( this, nu, nv, val )
    class(slice__scalar_t) <io> :: this
    integer <in> :: nu, nv
    real, dimension(nu,nv) <in> :: val

    this.val_vert(:,:) = val(:,:)
    this.val_vert_max = maxval(val)
    this.val_vert_min = minval(val)
    call this.mesh_cell.set_meanval( this.mesh_vert,  &
                                     this.val_vert )
  end subroutine slice__scalar_set_val


  subroutine slice__scalar_finalize( this )
    class(slice__scalar_t) <io> :: this

    deallocate(this.val_vert)
    call this.mesh_vert.finalize
    call this.mesh_cell.finalize
    call this.mesh_edge.finalize
  end subroutine slice__scalar_finalize


  subroutine slice__scalar_vis_contour( this, level )
    class(slice__scalar_t) <in> :: this
    real <in> :: level
    
    !!>
        In the followings, "e" stands for "edge",
        and "c" stands for "cell". "i" is index
        in the u-direction and "j" is in v-direction.
        So, "ei" is edge-index in u and "cj" is 
        cell-index in v.

                    north               
                edgeu(ei=1,ej=4)       +---+---+---+ ej=4
                +------------+ .       | 3 |   |   |
              w | cell(ci,cj)|e  .     +---+---+---+ ej=3
              e |    with    |a    .   | 2 |   |   |
              s |  ci=1,cj=3 |s\     . +---+---+---+ ej=2
              t/|            |t \      | 1 | 2 | 3 |
              / +------------+ ..\.... +---+---+---+ ej=1
             /      / south       \   ei=1 2   3   4 
            /  edgeu(ei=1,ej=3)    \
           /                        \
        edgev(ei=1,ej=3)           edgev(ei=2,ej=3)

                              edgeu(ei=3,ej=8)
            vert(vi=3,vj=8)   .    vert(vi=4,vj=8)
                         \    .   / 
                          o------o  
            edgev(3,7)....|      |....edgev(ei=4,ej=7)
                          |      |
                          o=====>V
                         /|  .   | \ vert(vi=4,vj=7)
           vert(vi=3,vj=7)|  .   |..............edgev(ei=4,ej=6)   
                             .   o 
              edgeu(ei=3,ej=7)    \
                                   vert(vi=4,vj=6)

        P: positive edge, eastward edgeu / northward edgev
        M: negative edge, westward edgeu / southward edgev
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
    !!<
    type(contour_path_t), save :: contour_path
    logical :: status
    logical :: just_once = .true.

    ==<just_once>==
      call contour_path.initialize( this.mesh_vert.nu,  &
                                    this.mesh_vert.nv )
    ==</just_once>==

    call contour_path.reset
    call this.mesh_edge.apply_stokes( this.mesh_cell, level )

    call iFind_start_edge( 'E', i_now, j_now, status )
    do while ( status == 'have found' )
      call trace_path_and_erase_trace( this.mesh_edge,    &
                                       this.mesh_vert.nu, &
                                       this.mesh_vert.nv, &
                                       'E', i_now, j_now )
      ! <check>
        do i = 1, contour_path.num
          ut__message( i, contour_path.list_i(i), contour_path.list_j(i) )
        end do
      ! </check>
      call iFind_start_edge( 'E', i_now, j_now, status )
    end do

  contains

    subroutine iFind_start_edge( direct_now, i_now, j_now, status )
      char(len=1) :: direct_now
      integer <out> :: i_now, j_now
      char(len=10) :: status ! 'no contour' or 'have found'
      !!>
            Tring to find a eastward arrow AB.
                +---+---+---+
                |           |
                A==>B       +
                 /  |       |
                /   +---+---+
               /
             This.
      !!< 
      integer :: ei, ej, v0i, v0j

      call ut__assert( direct_now=='E',  &
                      'We assume start edge is E(astward).' )
      do ej = 1, this.mesh_edge.u_nv
        do ei = 1, this.mesh_edge.u_nu
          if ( this.mesh_edge.u_ternary(ei,ej) == +1 ) then
            ! Found a boundary curve of 'E(astward)' direction.
            v0i = ei ! Vertex indexes of an left-end of
            v0j = ej ! an edge is the same as the edge indexes.
            i_now = v0i + 1
            j_now = v0j
            call contour_path.set_start_position( v0i, v0j )
            call contour_path.register( i_now, j_now ) ! Other end of edge.
            status = 'have found'
            return
          end if
        end do
      end do 
      status = 'no contour'
      call ut__fatal( 'Cound not find a start edge.' )
    end subroutine iFind_start_edge

  end subroutine slice__scalar_draw_contour


  subroutine slice__vector_initialize( this,        &
                                       vert_nu,     &
                                       vert_nv,     &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       vect_x,      &
                                       vect_y )
    class(slice__vector_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) <optin> :: vect_x, vect_y

    real, dimension(vert_nu,vert_nv) :: amp_vect

    call this.grid.initialize( vert_nu,     &
                               vert_nv,     &
                               vert_u_min,  &
                               vert_u_max,  &
                               vert_v_min,  &
                               vert_v_max )
    allocate(this.vect_x(vert_nu,vert_nv))
    allocate(this.vect_y(vert_nu,vert_nv))

    if ( present(vect_x) ) then
      this.vect_x(:,:) = vect_x(:,:)
    else
      this.vect_x(:,:) = 0.0
    end if

    if ( present(vect_y) ) then
      this.vect_y(:,:) = vect_y(:,:)
    else
      this.vect_y(:,:) = 0.0
    end if

    amp_vect = sqrt(vect_x**2+vect_y**2)

    this.amp_max = maxval(amp_vect)
    this.amp_min = minval(amp_vect)
  end subroutine slice__vector_initialize

  
  subroutine slice__vector_finalize( this )
    class(slice__vector_t) <out> :: this

    deallocate(this.vect_x)
    deallocate(this.vect_y)
    call this.grid.finalize
  end subroutine slice__vector_finalize


  subroutine slice__vector_set_val( this, vect_x, vect_y )
    class(slice__vector_t) <io> :: this
    real, dimension(vert_nu,vert_nv) <in> :: vect_x, vect_y

    this.vect_x(:,:) = vect_x(:,:)
    this.vect_y(:,:) = vect_y(:,:)
  end subroutine slice__vector_set_val

end module slice_m

