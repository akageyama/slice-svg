!!>
    slice: Visualize 2-dimensional cross sections 
    of 3- (or more) dimensional simulation data.

    Draw contour lines for scalar fields.

    Draw vector arrow glyphs for vector fields.
    
    In this module, positions are specified by the
    simulation coordinates (u,v) with simulation unit
    such as meters.

!!< 
module slice_m
  use color_m
  use ut_m
  use slice_mesh_m
  use contour_curve_m
  use sketch_m
  implicit none
  private

  type, public :: slice__scalar_t
    type(slice_mesh__vert_t) :: mesh_vert
    type(slice_mesh__edge_t) :: mesh_edge
    type(slice_mesh__boundary_t) :: mesh_boundary
    real, dimension(:,:), allocatable :: val_vert
    real :: val_vert_max, val_vert_min
  contains
    procedure, private :: slice__scalar_initialize_with_uvmax
    procedure, private :: slice__scalar_initialize_with_grids
    generic :: initialize => slice__scalar_initialize_with_uvmax,  &
                             slice__scalar_initialize_with_grids
    procedure :: finalize => slice__scalar_finalize
    procedure :: set_val => slice__scalar_set_val
    procedure :: vis_contour => slice__scalar_vis_contour
  end type slice__scalar_t

  type, public :: slice__vector_t
    type(slice_mesh__vert_t) :: mesh_vert
    real, dimension(:,:), allocatable :: vect_u
    real, dimension(:,:), allocatable :: vect_v
    real :: amp_max, amp_min
  contains
    procedure :: initialize => slice__vector_initialize
    procedure :: finalize => slice__vector_finalize    
    procedure :: set_val => slice__vector_set_val
    procedure :: vis_arrows => slice__vector_vis_arrows
  end type slice__vector_t


contains


  subroutine slice__scalar_vis_contour( this,            &
                                        sketch,          &
                                        level,           &
                                        width_in_pixels, &
                                        line_color,      &
                                        fill_color )
    class(slice__scalar_t) <io> :: this
    type(sketch_t) <io> :: sketch
    real <in> :: level
    real <optin> :: width_in_pixels
    type(color_t) <optin> :: line_color
    type(color_t) <optin> :: fill_color

    integer :: nu, nv
    type(contour_curve_t), save :: contour_curve
    logical :: just_once = .true.
    char(len=10) :: status
    type(sketch__sim_pos_t), dimension(:), allocatable, save :: verts_sim
    character, dimension(:), allocatable, save :: path_directive
    character :: SVG_directive
    integer :: i, counter
    real :: u_sim, v_sim, dummy

    ==<just_once>==
      nu = this.mesh_vert.nu
      nv = this.mesh_vert.nv
!debugp "calling contour_curve.initialize"
      call contour_curve.initialize( nu, nv )
      allocate(verts_sim(nu*nv))
      allocate(path_directive(nu*nv))
    ==</just_once>==

!debugp "calling mesh_edge.set_quarter"
    call this.mesh_edge.set_quarter( this.mesh_vert,  &
                                     this.val_vert,   &
                                     level )

!debugp "calling this.mesh_boundary.set_quarter"
    call this.mesh_boundary.set_quarter( this.mesh_vert,  &
                                         this.val_vert,   &
                                         level )
    call contour_curve.reset
!debugp "calling contour_curve.set_start_edge"
!debugp level
!debugp this.val_vert(1,1)
!debugp this.val_vert(2,1)
!debugp this.val_vert(3,1)
!debugp this.val_vert(4,1)
!debugp this.val_vert(5,1)
!debugp this.val_vert(6,1)
!debugp this.val_vert(7,1)
!debugp this.val_vert(8,1)
    call contour_curve.set_start_edge( this.mesh_vert,     &
                                       this.mesh_edge,     &
                                       this.mesh_boundary, &
                                       status )
!debugp contour_curve.start.which_edge
!debugp contour_curve.start.cruising_lane
!debugp contour_curve.start.path_go_toward
!debugp contour_curve.start.i
!debugp contour_curve.start.j
    counter = 0
!debugp "calling do while"
    do while ( status == 'have found' )
      !!  Tring to find the 1st contour for this level.
      call contour_curve.trace_and_erase( this.mesh_vert,    &
                                          this.mesh_edge,    &
                                          this.mesh_boundary )
      call  ut__assert( contour_curve.num >= 2,  &
                        "__MODULE__(__LINE__): Path too short." )
        
      do i = 1, contour_curve.num
        counter += 1
        if ( i == 1 ) then
          SVG_directive = 'M' ! Move to 
        else if ( i == 2 ) then
          SVG_directive = 'L' ! Line to
        else
          SVG_directive = ' ' ! Line to (You can ommit this after 1st 'L'.)
        end if
        path_directive(counter) = SVG_directive 
        u_sim = contour_curve.list_u(i)
        v_sim = contour_curve.list_v(i)
        verts_sim(counter) = sketch__sim_pos_t(u_sim,v_sim)
      end do

      ! To close the path
      counter += 1
      path_directive(counter) = 'Z' ! Close the sub-path.
      dummy = 0.0  ! any number
      verts_sim(counter) = sketch__sim_pos_t( dummy, dummy )

      !!  Generally, more contours exist for this level.
      call contour_curve.reset
      call contour_curve.set_start_edge( this.mesh_vert,     &
                                         this.mesh_edge,     &
                                         this.mesh_boundary, &
                                         status )
    end do

    if ( counter > 1 ) then
      call sketch.path( counter,             &
                        path_directive,      &
                        verts_sim,           &
                        width_in_pixels,     &
                        line_color,          &
                        fill_color )      
    end if

  end subroutine slice__scalar_vis_contour


  subroutine slice__scalar_initialize_with_uvmax( this, nu, nv,  &
                                                  u_min, u_max,  &
                                                  v_min, v_max,  &
                                                  val )
    class(slice__scalar_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max
    real, dimension(nu,nv) <optin> :: val

    allocate(this.val_vert(nu,nv))

    call this.mesh_vert.initialize( nu, nv,        &
                                    u_min, u_max,  &
                                    v_min, v_max )
    call this.mesh_edge.initialize( this.mesh_vert )
    call this.mesh_boundary.initialize( this.mesh_vert,  &
                                        this.mesh_edge )

    if ( present(val) ) then
      this.val_vert(:,:) = val(:,:)
    else
      this.val_vert(:,:) = 0.0
    end if

  end subroutine slice__scalar_initialize_with_uvmax


  subroutine slice__scalar_initialize_with_grids( this,       &
                                                  nu, nv,     &
                                                  grid_pos_u, &
                                                  grid_pos_v, &
                                                  val )
    class(slice__scalar_t) <out> :: this
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    real, dimension(nu,nv) <optin> :: val

    allocate(this.val_vert(nu,nv))

    call ut__assert( size(grid_pos_u,dim=1) == nu .and. &
                     size(grid_pos_v,dim=1) == nv,      &
                     "__MODULE__(__LINE__): " //        &
                     "grid size inconsistent." )

    call this.mesh_vert.initialize( nu, nv,     &
                                    grid_pos_u, &
                                    grid_pos_v )
    call this.mesh_edge.initialize( this.mesh_vert )

    if ( present(val) ) then
      this.val_vert(:,:) = val(:,:)
    else
      this.val_vert(:,:) = 0.0
    end if

  end subroutine slice__scalar_initialize_with_grids



  subroutine slice__scalar_set_val( this, nu, nv, val )
    class(slice__scalar_t) <io> :: this
    integer <in> :: nu, nv
    real, dimension(nu,nv) <in> :: val

    this.val_vert(:,:) = val(:,:)
    this.val_vert_max = maxval(val)
    this.val_vert_min = minval(val)
  end subroutine slice__scalar_set_val


  subroutine slice__scalar_finalize( this )
    class(slice__scalar_t) <io> :: this

    deallocate(this.val_vert)
    call this.mesh_vert.finalize
    call this.mesh_edge.finalize
    call this.mesh_boundary.finalize
  end subroutine slice__scalar_finalize



  subroutine slice__vector_initialize( this,        &
                                       vert_nu,     &
                                       vert_nv,     &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       vect_u,      &
                                       vect_v )
    class(slice__vector_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) <optin> :: vect_u, vect_v

    real, dimension(vert_nu,vert_nv) :: amp_vect

    call this.mesh_vert.initialize( vert_nu,     &
                                    vert_nv,     &
                                    vert_u_min,  &
                                    vert_u_max,  &
                                    vert_v_min,  &
                                    vert_v_max )
    allocate(this.vect_u(vert_nu,vert_nv))
    allocate(this.vect_v(vert_nu,vert_nv))

    if ( present(vect_u) ) then
      this.vect_u(:,:) = vect_u(:,:)
    else
      this.vect_u(:,:) = 0.0
    end if

    if ( present(vect_v) ) then
      this.vect_v(:,:) = vect_v(:,:)
    else
      this.vect_v(:,:) = 0.0
    end if

    amp_vect = sqrt(vect_u**2+vect_v**2)

    this.amp_max = maxval(amp_vect)
    this.amp_min = minval(amp_vect)
  end subroutine slice__vector_initialize

  
  subroutine slice__vector_finalize( this )
    class(slice__vector_t) <io> :: this

    deallocate(this.vect_u)
    deallocate(this.vect_v)
    call this.mesh_vert.finalize
  end subroutine slice__vector_finalize


  subroutine slice__vector_set_val( this, vect_u, vect_v )
    class(slice__vector_t) <io> :: this
    real, dimension(this.mesh_vert.nu,this.mesh_vert.nv) <in> :: vect_u, vect_v

    this.vect_u(:,:) = vect_u(:,:)
    this.vect_v(:,:) = vect_v(:,:)
  end subroutine slice__vector_set_val


  subroutine slice__vector_vis_arrows( this, sketch )
    class(slice__vector_t) <io> :: this
    type(sketch_t) <io> :: sketch
    !!>
        o--o--o--o--o--o--o--o--o <== Original (=finest) grid
        |  |  |  |  |  |  |  |  |
        o-----o-----o-----o-----o <== Coarse grid (stride=2)
        |  |  |  |  |  |  |  |  |
        o-----------o-----------o <== Coarser grid (stride=4)
        |  |  |  |  |  |  |  |  |
        o-----------------------o <== Coarser2 grid (stride=8)
        |  |  |  |  |  |  |  |  |
        3  0  1  0  2  0  1  0  3 <====== "skip"    
    !!<
    integer :: i, j
    real :: u, v

    integer :: skip, stride
    char(len=11) :: tag_for_group
    logical, dimension(:,:), allocatable :: pass_to_sketch_flag

    allocate(pass_to_sketch_flag(this.mesh_vert.nu,this.mesh_vert.nv))

    pass_to_sketch_flag(:,:) = .false.

    do skip = 3, 0, -1
      stride = 2**skip
      write(tag_for_group,"(a,i1)") "arrow-skip", skip
        ! "arrow-skip4, arrow-skip3, ...
      call sketch.group_push( id=trim(tag_for_group),  &
                              visibility="visible" )
        do j = 1, this.mesh_vert.nv, stride
          do i = 1, this.mesh_vert.nu, stride
            if ( .not. pass_to_sketch_flag(i,j) ) then
              u = this.mesh_vert.pos_u(i)
              v = this.mesh_vert.pos_v(j)
              call sketch.arrow( u, v, &
                                 this.vect_u(i,j), &
                                 this.vect_v(i,j) )
              pass_to_sketch_flag(i,j) = .true.
            end if
          end do
        end do
      call sketch.group_pop()
    end do

    deallocate(pass_to_sketch_flag)
  end subroutine slice__vector_vis_arrows

end module slice_m

