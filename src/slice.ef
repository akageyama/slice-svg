  !!>
      In physical coordinate system.
  !!< 
module slice_m
  use ut_m
  use svglib_m
  implicit none
  private

  type :: slice_grid_t
    !!>  V: vertex, egy: edge_y
            .       .       .       .       . 
            y       y       y       y       y
       ...x V edgex V edgex V edgex V edgex V e...
            e       e       e       e       e    
            g  cell g  cell g  cell g  cell g  
            y       y       y       y       y
       ...x V edgex V edgex V edgex V edgex V e...
            y       y       y       y       y
            .       .       .       .       . 
    !!< 

    ! vertex
    integer :: vert_nu, vert_nv
    real, dimension(:), allocatable :: vert_pos_u
    real, dimension(:), allocatable :: vert_pos_v
    real, dimension(:,:), allocatable :: vert_val
    real :: vert_u_min, vert_u_max
    real :: vert_v_min, vert_v_max
    ! cell
    integer :: cell_nu, cell_nv
    real, dimension(:,:), allocatable :: cell_val
    ! edges (x and y directions)
    integer :: edgex_nu, edgex_nv
    integer :: edgey_nu, edgey_nv
    integer, dimension(:,:), allocatable :: edgex_ival
    integer, dimension(:,:), allocatable :: edgey_ival
  contains
    procedure :: initialize => slice_grid_initialize
    procedure :: finalize => slice_grid_finalize
    procedure :: reset_val => slice_grid_reset_val
  end type slice_grid_t

  type, public :: slice__scalar_t
    type(slice_grid_t) :: grid
    real :: val_max, val_min
  contains
    procedure :: initialize => slice__scalar_initialize
    procedure :: finalize => slice__scalar_finalize
    procedure :: replace_val => slice__scalar_replace_val
    procedure :: draw_contour => slice__scalar_draw_contour
  end type slice__scalar_t

  type, public :: slice__vector_t
    type(slice_grid_t) :: grid
    real, dimension(:,:), allocatable :: x
    real, dimension(:,:), allocatable :: y
    real :: amp_max, amp_min
  contains
    procedure :: initialize => slice__vector_initialize
    procedure :: finalize => slice__vector_finalize    
  end type slice__vector_t


contains


  recursive subroutine slice_grid_reset_val( this, which )
    class(slice_grid_t) <io> :: this
    char(len=*) <in> :: which

    select case ( which )
      case ('vert')
        this.vert_val(:,:) = 0.0
      case ('cell')
        this.cell_val(:,:) = 0.0
      case ('edges')
        this.edgex_ival(:,:) = 0
        this.edgey_ival(:,:) = 0
      case ('all')
        call slice_grid_reset_val( this, 'vert' )
        call slice_grid_reset_val( this, 'cell' )
        call slice_grid_reset_val( this, 'edges' )
      default
        call ut__fatal( 'invalid argument.' )
    end select
  end subroutine slice_grid_reset_val


  subroutine slice_grid_initialize( this, vert_nu, vert_nv,  &
                                    vert_u_min, vert_u_max,  &
                                    vert_v_min, vert_v_max )
    class(slice_grid_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max

    real :: du, dv
    integer :: i, j

    call ut__assert( (vert_nu > 1) .and.  &
                     (vert_nv > 1) .and.  &
                     (vert_u_max > vert_u_min) .and.  &
                     (vert_v_max > vert_v_min),  &
                    'Invalid coord-related arguments.' )
    call iVertex
    call iCell
    call iEdges

  contains

    subroutine iVertex
      this.vert_nu = vert_nu
      this.vert_nv = vert_nv
      this.vert_u_min = vert_u_min
      this.vert_v_min = vert_v_min
  
      allocate(this.vert_pos_u(vert_nu))
      allocate(this.vert_pos_v(vert_nv))
      allocate(this.vert_val(vert_nu,vert_nv))
  
      du = ( vert_u_max - vert_u_min ) / (vert_nu-1)
      dv = ( vert_v_max - vert_v_min ) / (vert_nv-1)
  
      do i = 1, vert_nu
        this.vert_pos_u(i) = vert_u_min + du*(i-1)
      end do
  
      do j = 1, vert_nv
        this.vert_pos_v(j) = vert_v_min + dv*(j-1)
      end do

      call slice_grid_reset_val( this, 'vert' )
    end subroutine iVertex

    subroutine iCell
      this.cell_nu = vert_nu - 1
      this.cell_nv = vert_nv - 1
      allocate(this.cell_val(this_cell_nu,this_cell_nv))
      call slice_grid_reset_val( this, 'cell' )
    end subroutine iCell

    subroutine iEdges
      this.edgex_nu = this.cell_nu
      this.edgex_nv = this.vert_nv
      this.edgey_nu = this.vert_nu
      this.edgey_nv = this.cell_nv
      allocate(this.edgex_ival(this.edgex_nu,this.edgex_nv))
      allocate(this.edgey_ival(this.edgey_nu,this.edgey_nv))
      call slice_grid_reset_val( this, 'edges' )
    end subroutine iEdges

  end subroutine slice_grid_initialize


  subroutine slice_grid_finalize( this )
    class(slice_grid_t) <io> :: this

    deallocate(this.vert_pos_u)
    deallocate(this.vert_pos_v)
    deallocate(this.vert_val)
    deallocate(this.cell_val)
    deallocate(this.edgex_ival)
    deallocate(this.edgey_ival)
  end subroutine slice_grid_finalize


  subroutine slice__scalar_initialize( this,        &
                                       vert_nu,     &
                                       vert_nv,     &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       val )
    class(slice__scalar_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) :: val

    call this.grid.initialize( vert_nu,     &
                               vert_nv,     &
                               vert_u_min,  &
                               vert_u_max,  &
                               vert_v_min,  &
                               vert_v_max )
    this.grid.vert_val(:,:) = val(:,:)
    this.val_max = maxval(val)
    this.val_min = minval(val)

  end subroutine slice__scalar_initialize


  subroutine slice__scalar_replace_val( this, &
                                        vert_nu, &
                                        vert_nv, &
                                        val )

    class(slice__scalar_t) <io> :: this
    real, dimension(vert_nu,vert_nv) <in> :: val

    this.grid.vert_val(:,:) = val(:,:)
  end subroutine slice__scalar_replace_val


  subroutine slice__scalar_finalize( this )
    class(slice__scalar_t) <io> :: this
    call this.grid.finalize
  end subroutine slice__scalar_finalize


  subroutine slice__scalar_draw_contour( this, level )
    class(slice__scalar_t) <in> :: this
    real <in> :: level

    !!>
        In the followings, "e" stands for "edge",
        and "c" stands for "cell". "i" is index
        in the u-direction and "j" is in v-direction.
        So, "ei" is edge-index in u and "cj" is 
        cell-index in v.

                    north              ei=1  2   3   4 
               edge_x(ei=1,ej=3)    ej=1 +---+---+---+
                +------------+ .         | 1 | 2 | 3 |
              w | cell(ci,cj)|e  .     2 +---+---+---+
              e |    with    |a    .     | 2 |   |   |
              s |  ci=1,cj=3 |s\     . 3 +---+---+---+
              t/|            |t \        | 3 |   |   |
              / +------------+ ..\.... 4 +---+---+---+
             / edge_x(ei=1,ej=4)  \            
            /       south          \
       edge_y(ei=1,ej=3)          edge_y(ei=2,ej=3)


       Stokes thereom

                <---               <---             
             +--------+	       +--------+   
           | |cell at | ^     | |cell at | ^  
           | |   ci=1 | |  +  | |   ci=2 | |  
           v |   cj=3 | |     v |   cj=3 | |  
             +--------+	       +--------+   
                --->	          --->            

                                 . . . "cancel out"
                               .
                         <---  .  <---
                      +--------+--------+
                    | |cell at |cell at | ^ 
                =>  | |   ci=1 |   ci=2 | | 
                    v |   cj=3 |   cj=3 | | 
                      +--------+--------+
                         --->     --->

    !!<

    integer :: i, j  ! cell and edge indexes

    call this.cell.edge.reset
    do j = 1, this.cell.vert_nv
      do i = 1, this.cell.vert_nu
        if ( this.cell.val(i,j) >= level ) then
          this.cell.edge_x(i  , j+1) = +1  ! south
          this.cell.edge_y(i+1, j  ) = +1  ! east
          this.cell.edge_x(i  , j  ) = -1  ! north
          this.cell.edge_y(i  , j  ) = -1  ! west
        end if
      end do
    end do
        
  end subroutine slice__scalar_draw_contour


  subroutine slice__vector_initialize( this, vert_nu, vert_nv, &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       x,     &
                                       y )
    class(slice__vector_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) <in> :: x, y

    real, dimension(vert_nu,vert_nv) :: amp_of_the_vector

    call this.grid.initialize( vert_nu, vert_nv,       &
                               vert_u_min,  &
                               vert_u_max,  &
                               vert_v_min,  &
                               vert_v_max )
    allocate(this.x(vert_nu,vert_nv))
    allocate(this.y(vert_nu,vert_nv))

    this.x = x
    this.y = y

    amp_of_the_vector = sqrt(x**2+y**2)

    this.amp_max = maxval(amp_of_the_vector)
    this.amp_min = minval(amp_of_the_vector)

  end subroutine slice__vector_initialize

  
  subroutine slice__vector_finalize( this )
    class(slice__vector_t) <out> :: this

    call this.grid.finalize
    deallocate(this.x)
    deallocate(this.y)
  end subroutine slice__vector_finalize

end module slice_m

