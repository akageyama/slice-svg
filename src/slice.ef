  !!>
      In physical coordinate system.
  !!< 
module slice_m
  use ut_m
  use svglib_m
  implicit none
  private

  type slice_grid_t
    !!>  
        V: vertex, egy: edge_y
            .       .       .       .       . 
            y       y       y       y       y
       ...x-V-edgex-V-edgex-V-edgex-V-edgex-V-e...
            e       e       e       e       e    
            g  cell g  cell g  cell g  cell g  
            y       y       y       y       y
       ...x-V-edgex-V-edgex-V-edgex-V-edgex-V-e...
            y       y       y       y       y
            .       .       .       .       . 
    !!< 

    ! vertex
    integer :: vert_nu, vert_nv
    real, dimension(:), allocatable :: vert_pos_u
    real, dimension(:), allocatable :: vert_pos_v
    real :: vert_u_min, vert_u_max
    real :: vert_v_min, vert_v_max
    ! cell
    integer :: cell_nu, cell_nv
    ! edges (x and y directions)
    integer :: edgex_nu, edgex_nv
    integer :: edgey_nu, edgey_nv
    integer, dimension(:,:), allocatable :: edgex_ternary
    integer, dimension(:,:), allocatable :: edgey_ternary
                                              ! {+1, 0, -1}
  contains
    procedure :: initialize => slice_grid_initialize
    procedure :: finalize => slice_grid_finalize
  end type slice_grid_t

  type, public :: slice__scalar_t
    type(slice_grid_t) :: grid
    real, dimension(:,:), allocatable :: val_vert
    real :: val_vert_max, val_vert_min
    real, dimension(:,:), allocatable :: val_cell
    real :: val_cell_max, val_cell_min
  contains
    procedure :: initialize => slice__scalar_initialize
    procedure :: finalize => slice__scalar_finalize
    procedure :: set_val => slice__scalar_set_val
    procedure :: vis_contour => slice__scalar_vis_contour
  end type slice__scalar_t

  type, public :: slice__vector_t
    type(slice_grid_t) :: grid
    real, dimension(:,:), allocatable :: vect_x
    real, dimension(:,:), allocatable :: vect_y
    real :: amp_max, amp_min
  contains
    procedure :: initialize => slice__vector_initialize
    procedure :: finalize => slice__vector_finalize    
    procedure :: set_val => slice__vector_set_val
  end type slice__vector_t


contains


  ! function neibhbor_edges_pattern( n, w, s, e ) result(pattern)
  !   integer <in> :: n, w, s, e  ! north, west, south, east
  !   char(len=4) :: pattern

  !   pattern(1:1) = iNorth(n)
  !   pattern(2:2) = iWest(w)
  !   pattern(3:3) = iSouth(s)
  !   pattern(4:4) = iEast(e)

  ! contains

  !   function iNorth(n) result(char)
  !     integer <in> :: n
  !     char(len=1) :: char
  !     !!>
  !          plus                  north
  !         v-direction              | 
  !           |                  ----*----
  !           +--- plus              |  
  !               u-direction    
  !     !!<
  !     if ( n==-1 ) then
  !       char = 'i' ! inward 
  !     else if ( n==+1 ) then
  !       char = 'o' ! outward
  !     else if ( n==NULL ) then
  !       char = 'b' ! boundary
  !     else if ( n==0 ) then
  !       char = ' '
  !     else
  !       call ut__assert( 'Something is wrong.' )
  !     end if
  !   end function iNorth

  !   function iWest(w) result(char)
  !     integer <in> :: w
  !     char(len=1) :: char
  !     !!>
  !          plus                  
  !         v-direction                 | 
  !           |                west ----*----
  !           +--- plus                 |  
  !               u-direction    
  !     !!<
  !     if ( w==+1 ) then
  !       char = 'i' ! inward
  !     else if ( w==-1 ) then
  !       char = 'o' ! outward
  !     else if ( w==NULL ) then
  !       char = 'b' ! boundary
  !     else if ( w==0 ) then
  !       char = ' '
  !     else
  !       call ut__assert( 'Something is wrong.' )
  !     end if
  !   end function iWest

  !   function iSouth(s) result(char)
  !     integer <in> :: s
  !     char(len=1) :: char

  !     if ( s==+1 ) then
  !       char = 'i'
  !     else if ( s==-1 ) then
  !       char = 'o' ! out
  !     else if ( s==NULL ) then
  !       char = 'b' ! boundary
  !     else if ( s==0 ) then
  !       char = ' '
  !     else
  !       call ut__assert( 'Something is wrong.' )
  !     end if
  !   end function iSouth

  !   function iEast(e) result(char)
  !     integer <in> :: e
  !     char(len=1) :: char
      
  !     if ( e==+1 ) then
  !       char = 'o'
  !     else if ( e==-1 ) then
  !       char = 'i' ! out
  !     else if ( e==NULL ) then
  !       char = 'b' ! boundary
  !     else if ( e==0 ) then
  !       char = ' '
  !     else
  !       call ut__assert( 'Something is wrong.' )
  !     end if
  !   end function iEast          

  ! end function neibhbor_edges_pattern


  subroutine path_vert_explore( this )
    class(path_vert_t) <io> :: this

    integer :: head_i, head_j
    integer :: step_forward_i, step_forward_j
    integer :: step_turn_left_i, step_turn_left_j
    integer :: step_turn_right_i, step_turn_right_j

    !!>
        edge direction from foot-vert to head-vert
                            .
           f-->h   (1,0)    .     f
       ......................     |  (0,-1)
                            .     h   
             h              ...................  
             |     (0,1)    .   
             f              .  h<--f (-1,0)
    !!<

    head_i = this.i(this.num)
    head_j = this.j(this.num)
    foot_i = this.i(this.num-1)
    foot_j = this.j(this.num-1)
    step_forward_i = head_i - foot_i
    step_forward_j = head_j - foot_j
    step_turn_left_i =  -step_forward_j ! Vector
    step_turn_left_j =  +step_forward_i !  outer
    step_turn_right_i = +step_forward_j !   product
    step_turn_right_j = -step_forward_i !    with unit-z.

    if ( step_forward_i==1 ) then
      direct = 'E'
    else if ( step_foward_j==1 ) then
      direct = 'N'
    else if ( step_foward_i==-1) then
      direct = 'W'
    else if ( step_foward_j=-1 )
      direct = 'S'
    else 
      call ut__fatal( 'Something is strange.' )
    end if

    select case (direct)
      case ('E')
        !!>
                             i=hi
                     -o-------o-------o j=hj-1
                      |       |       |
                      |       |<--edgey(hi,hj-1)
                      |       |       |
                     -f======>h-------o j=hj
                              |       |
                              |<--edgey(hi,hj)

        !!<
         
        if ( this.edgey_ternary(head_i,head_j-1) == 1 ) then
          ! turn left


        
  end subroutine path_vert_explore


  subroutine slice_grid_initialize( this, vert_nu, vert_nv,  &
                                    vert_u_min, vert_u_max,  &
                                    vert_v_min, vert_v_max )
    class(slice_grid_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max

    call ut__assert( (vert_nu > 1) .and.              &
                     (vert_nv > 1) .and.              &
                     (vert_u_max > vert_u_min) .and.  &
                     (vert_v_max > vert_v_min),       &
                    'Invalid coord-related arguments.' )
    call iVertex
    call iCell
    call iEdges

  contains

    subroutine iVertex
      real :: du, dv
      integer :: i, j

      this.vert_nu = vert_nu
      this.vert_nv = vert_nv
      this.vert_u_min = vert_u_min
      this.vert_u_max = vert_u_max
      this.vert_v_min = vert_v_min
      this.vert_v_max = vert_v_max
  
      allocate(this.vert_pos_u(vert_nu))
      allocate(this.vert_pos_v(vert_nv))
  
      du = ( vert_u_max - vert_u_min ) / (vert_nu-1)
      dv = ( vert_v_max - vert_v_min ) / (vert_nv-1)
  
      do i = 1, vert_nu
        this.vert_pos_u(i) = vert_u_min + du*(i-1)
!debugp i, this.vert_pos_u(i)        
      end do
  
      do j = 1, vert_nv
        this.vert_pos_v(j) = vert_v_min + dv*(j-1)
!debugp j, this.vert_pos_v(j)        
      end do
    end subroutine iVertex

    subroutine iCell
      this.cell_nu = vert_nu - 1
      this.cell_nv = vert_nv - 1
    end subroutine iCell

    subroutine iEdges
      this.edgex_nu = this.cell_nu
      this.edgex_nv = this.vert_nv
      this.edgey_nu = this.vert_nu
      this.edgey_nv = this.cell_nv
      allocate(this.edgex_ternary(this.edgex_nu,  &
                                  this.edgex_nv))
      allocate(this.edgey_ternary(this.edgey_nu,  &
                                  this.edgey_nv))
    end subroutine iEdges

  end subroutine slice_grid_initialize


  subroutine slice_grid_finalize( this )
    class(slice_grid_t) <io> :: this

    deallocate(this.vert_pos_u)
    deallocate(this.vert_pos_v)
    deallocate(this.edgex_ternary)
    deallocate(this.edgey_ternary)
  end subroutine slice_grid_finalize


  subroutine slice_scalar_val_vert_to_val_cell( scal )
    type(slice__scalar_t) <io> :: scal

    integer :: i, j

    ! average
    do j = 1, this.grid.cell_nv
      do i = 1, this.grid.cell_nu
        scal.val_cell(i,j) = (  scal.val_vert(i,    j)   &
                              + scal.val_vert(i+1,  j)   &
                              + scal.val_vert(i,  j+1)   &
                              + scal.val_vert(i+1,j+1) ) / 4
      end do
    end do
    scal.cell_val_max = maxval(scal.val_cell)
    scal.cell_val_min = minval(scal.val_cell)
  end subroutine slice_scalar_val_vert_to_val_cell


  subroutine slice__scalar_initialize( this,        &
                                       vert_nu,     &
                                       vert_nv,     &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       val )
    class(slice__scalar_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) <optin> :: val

    call this.grid.initialize( vert_nu,     &
                               vert_nv,     &
                               vert_u_min,  &
                               vert_u_max,  &
                               vert_v_min,  &
                               vert_v_max )

    allocate(this.val_vert(this.grid.vert_nu,  &
                           this.grid.vert_nv))

    if ( present(val) ) then
      this.grid.vert_val(:,:) = val(:,:)
    else
      this.grid.vert_val(:,:) = 0.0
    end if

    allocate(this.val_cell(this.grid.cell_nu,  &
                           this.grid.cell_nv))
    call slice_scalar_val_vert_to_val_cell( this )
  end subroutine slice__scalar_initialize


  subroutine slice__scalar_set_val( this, &
                                    vert_nu, &
                                    vert_nv, &
                                    val )
    class(slice__scalar_t) <io> :: this
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val

    this.val_vert(:,:) = val(:,:)
    this.val_vert_max = maxval(val)
    this.val_vert_min = minval(val)
    call slice_scalar_val_vert_to_val_cell( this )
  end subroutine slice__scalar_set_val


  subroutine slice__scalar_finalize( this )
    class(slice__scalar_t) <io> :: this

    deallocate(this.val_vert)
    deallocate(this.val_cell)
    call this.grid.finalize
  end subroutine slice__scalar_finalize


  subroutine slice__scalar_vis_contour( this, level )
    class(slice__scalar_t) <in> :: this
    real <in> :: level

    !!>
        In the followings, "e" stands for "edge",
        and "c" stands for "cell". "i" is index
        in the u-direction and "j" is in v-direction.
        So, "ei" is edge-index in u and "cj" is 
        cell-index in v.

                    north               
               edge_x(ei=1,ej=4)       +---+---+---+ ej=4
                +------------+ .       | 3 |   |   |
              w | cell(ci,cj)|e  .     +---+---+---+ ej=3
              e |    with    |a    .   | 2 |   |   |
              s |  ci=1,cj=3 |s\     . +---+---+---+ ej=2
              t/|            |t \      | 1 | 2 | 3 |
              / +------------+ ..\.... +---+---+---+ ej=1
             /      / south       \   ei=1 2   3   4 
            / edge_x(ei=1,ej=3)    \            
           /                        \
       edge_y(ei=1,ej=3)          edge_y(ei=2,ej=3)

    !!<

    call iSet_edges
!    call iCalc_path_turns_from_edges
    call iExtract_boundary_curve

  contains

    subroutine iSet_edges
      !!>
          Applying Stokes thereom, we get the boundary curve 
          of cells that has larger value than "level".

               <---               <---             
            +--------+	       +--------+   
          | |cell at | ^     | |cell at | ^  
          | |   ci=1 | |  +  | |   ci=2 | |  
          v |   cj=3 | |     v |   cj=3 | |  
            +--------+	       +--------+   
               --->	          --->         "cancel out" 
                                           /
                                   <---   / <---
                                +--------+--------+
                              | |cell at |cell at | ^ 
                           =  | |   ci=1 |   ci=2 | | 
                              v |   cj=3 |   cj=3 | | 
                                +--------+--------+
                                   --->     --->
      !!<
      integer :: i, j  ! cell indexes
  
      this.grid.edgex_ternary(:,:) = 0  ! reset
      this.grid.edgey_ternary(:,:) = 0
      do j = 1, this.cell.vert_nv
        do i = 1, this.cell.vert_nu
          if ( this.val_cell(i,j) >= level ) then
            this.grid.edgex_ternary(i  , j+1) += 1  ! right-in-south
            this.grid.edgey_ternary(i+1, j  ) += 1  !    up-in-east
            this.grid.edgex_ternary(i  , j  ) -= 1  !  left-in-north
            this.grid.edgey_ternary(i  , j  ) -= 1  !  down-in-west
          end if
        end do
      end do
    end subroutine iSet_edges

    subroutine iCalc_path_turns_from_edges
  !!>
        P: positive edge (eastward for edgex and
                          northward for edgey)
        M: negative edge (westward for edgex and
                          southward for edgey) 
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
  !!<    
      integer :: i, j
      char(len=4) :: pattern

      do j = 1, this.vert_nv
        do i = 1, this.vert_nu
          if ( i == this.vert_nu ) then
            east_edge = NULL
          else 
            east_edge = this.edgex_ternary(i,j)
          end if
          if ( i == 1 ) then
            west_edge = NULL
          else 
            west_edge = this.edgex_ternary(i-1,j)
          end if
          if ( j == vert_nv ) then
            north_edge = NULL
          else 
            north_edge = this.edgey_ternary(i,j)
          end if 
          if ( j == 1 ) then
            south_edge = NULL
          else
            south_edge = this.edgey_ternary(i,j-1)
          end if

          pattern = neibhbor_edges_pattern( north_edge, &
                                            west_edge,  &
                                            south_edge, &
                                            east_edge )
          select case ( pattern )
                  !'NWSE'
            case ( 'io  ' )
              this.vert_turn(i,j) = 'R'
            case ( ' io ' )
              this.vert_turn(i,j) = 'R'
            case ( '  io' )
              this.vert_turn(i,j) = 'R'
            case ( 'o  i' )
              this.vert_turn(i,j) = 'R'
            case ( 'ioio' )
              this.vert_turn(i,j) = 'R'
            case ( 'ioio' )
              this.vert_turn(i,j) = 'R'

            pattern(1:4) = iChar(n)//iChar(w)//iChar(s)//iChar(e)

          contains 

            function iChar(i)
              integer <in> :: i

              select case(i)
                case ('+1')
                  iChar = 'i' ! inward

          end function neibhbor_edges_pattern

           lect case (west_edge)
            case (+1) ! coming from west
              if ( north_edge == +1 ) then
                this.vert_turn(i,j) = 'L'
              else if ( south_edge == -1 ) then
                this.vert_turn(i,j) = 'R'
              else if ( east_edge == +1 ) then
                this.vert_vect(i,j) = 'S'
              else
                call ut__assert( 'Something is wrong.' )
              end if
            case (-1) ! coming from east
              if ( north_edge == +1 ) then
                this.vert_turn(i,j) = 'R'
              else 
          
    end subroutine iCalc_path_turns_from_edges

    subroutine iExtract_boundary_curve
      integer :: i, j  ! edges indexes
      integer :: path_vert_i, path_vert_j
      integer :: path_vert_num

      type(contour_path_t) :: contour_path
      integer :: max_path_segment_num_overestimate
      logical :: just_once = .true.

      !!>
            Tring to find a "right-in-south" arrow AB.
                +---+---+---+
                |           |
                A==>B       +
                 /  |       |
                /   +---+---+
               /
             This.
      !!< 

      ==<just_once>==
        max_path_segment_num_overestimate = this.edge_nu*edge_nv
        call contour_path.initialize( max_path_segment_num_overestimate, &
                                      this.vert_nu,  &
                                      this.vert_nv )
      ==</just_once>==

      call contour_path.reset

integer :: ei, ej, v0i, v0j, v1i, v1j

      loops_to_find_the_starting_point_of_a_path : &
        do ej = 1, this.grid.edgex_nv
          do ei = 1, this.grid.edgex_nu
            if ( this.grid.edgex_ternary(ei,ej) == +1 ) then
              ! Found a boundary curve of 'E(astward)' direction.
              v0i = ei ! Vertex indexes of an left-end of
              v0j = ej ! an edge is the same as the edge indexes.
              v1i = v0i + 1
              v1j = v0j
              call contour_path.set_start_position( v0i, v0j )
              call path_vert.register( v1i, v1j ) ! Other end of edge.
              exit finding_loops
            end if
          end do
        end do &
      loops_to_find_the_starting_point_of_a_path

!      if ( contour_path.num == 0 ) return  ! No contour

      loops_to_folow_the_path : &
        direct_now = 'E'
        
        do ej = 1, this.grid.edgex_nv
          do ei = 1, this.grid.edgex_nu
            if ( this.grid.edgex_ternary(ei,ej) == +1 ) then
              ! Found a boundary curve of 'E(astward)' direction.
              v0i = ei ! Vertex indexes of an left-end of
              v0j = ej ! an edge is the same as the edge indexes.
              v1i = v0i + 1
              v1j = v0j
              call contour_path.set_start_position( v0i, v0j )
              call path_vert.register( v1i, v1j ) ! Other end of edge.
              exit finding_loops
            end if
          end do
        end do &
      loops_to_folow_the_path
      

  integer :: p 

      direct = 'E'

      do p = 1, contour_path.num_max-2 ! segment count of the path.
        call turn_left( 'just_check', path,  &
                        edgex_ternary, edgey_ternary,  &
                        direct_now, i_now, j_now, ans  )
          
        if ( contour_path.turn_left( direct, v1i, v1j ) ) then
          call path_vert.register( v1i, v1j )

          call path_vert.turn_left( vtip_direct, vtip_i, vtip_j )
          vtip_direct -= 1 ! Turn left.
          if ( vtip_direct < 0 ) vtip_direct += 4
          vtip_shift_from_start_j += 1
        else if ( can_turn_right( vtip_direct, vtip_i, vtip_j ) ) then
          call path_vert.register( vtip_i, vtip_j )
          vtip_direct += 1 ! Turn right.
          if ( vtip_direct > 4 ) vtip_direct -= 4 
          vtip_shift_from_start_j += 1


      call path_vert.follow( )

      select case (vtip_direct)
        case '+x'
          !!>
                          edgex(ei=3,ej=8)
            vert(vi=3,vj=8)   .
                         \    .      
                          o------o  
            edgey(3,7)....|      |....edgey(4,7)
                          |      |
                          o------o
                         /   .    \
            vert(vi=3,vj=7)  .     vert(vi=4,vj=7)
                           edgex(ei=3,ej=7)
          !!<
          if ( this.grid_edgey_tenary(ei+1,ej) == +1 ) then
            ! turn to "up"
            call path_vert.register( vtip_i, vtip_j )
            vtip_direct = '+y'
            exit
          else if ( this.grid_edgey_tenary(ei+1,ej-1) == -1 ) then
            ! turn ton "down"
            call path_vert.register( vtip_i, vtip_j )
            vtip_direct = '-y'
            exit
          else 
            call ut__assert( this.grid_edgex_ternary(ei+1,ej) == +1,  &
                            'Something is strange.' )
            
          end if
          
          next_ej = ej - 1
          next_left_i = vtip_i
          next_left_j = vtip_j-1
          if ( this.grid.edgey_ternary( 'vtip_i,vtip_j))
          

      if ( step_forward_i==1 ) then
        direct = 'E'
      else if ( step_foward_j==1 ) then
        direct = 'N'
      else if ( step_foward_i==-1) then
        direct = 'W'
      else if ( step_foward_j=-1 )
        direct = 'S'
      else 
        call ut__fatal( 'Something is strange.' )
      end if



      call path_vert.set_tip( 'x', )  !   B of A===>B
      j = path_vert_j       !       
      do while ( i /= path_vert_i .and.  &
                 j /= path_vert_j )
        call path.vert_add( i, j )
        path_vert_num += 1
        path_vert_i(path_vert_num) = i
        patH-vert_j(path_vert_num) = j


            

    end subroutine iExtract_boundary_curve

  end subroutine slice__scalar_draw_contour


  subroutine slice__vector_initialize( this,        &
                                       vert_nu,     &
                                       vert_nv,     &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       vect_x,      &
                                       vect_y )
    class(slice__vector_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) <optin> :: vect_x, vect_y

    real, dimension(vert_nu,vert_nv) :: amp_vect

    call this.grid.initialize( vert_nu,     &
                               vert_nv,     &
                               vert_u_min,  &
                               vert_u_max,  &
                               vert_v_min,  &
                               vert_v_max )
    allocate(this.vect_x(vert_nu,vert_nv))
    allocate(this.vect_y(vert_nu,vert_nv))

    if ( present(vect_x) ) then
      this.vect_x(:,:) = vect_x(:,:)
    else
      this.vect_x(:,:) = 0.0
    end if

    if ( present(vect_y) ) then
      this.vect_y(:,:) = vect_y(:,:)
    else
      this.vect_y(:,:) = 0.0
    end if

    amp_vect = sqrt(vect_x**2+vect_y**2)

    this.amp_max = maxval(amp_vect)
    this.amp_min = minval(amp_vect)
  end subroutine slice__vector_initialize

  
  subroutine slice__vector_finalize( this )
    class(slice__vector_t) <out> :: this

    deallocate(this.vect_x)
    deallocate(this.vect_y)
    call this.grid.finalize
  end subroutine slice__vector_finalize


  subroutine slice__vector_set_val( this, vect_x, vect_y )
    class(slice__vector_t) <io> :: this
    real, dimension(vert_nu,vert_nv) <in> :: vect_x, vect_y

    this.vect_x(:,:) = vect_x(:,:)
    this.vect_y(:,:) = vect_y(:,:)
  end subroutine slice__vector_set_val

end module slice_m

