  !!>
      In physical coordinate system.
  !!< 
module slice_m
  use ut_m
  use slice_mesh_m
  use contour_path_m
  implicit none
  private


  type, public :: slice__scalar_t
    type(slice_mesh_vert_t) :: mesh_vert
    type(slice_mesh_cell_t) :: mesh_cell
    type(slice_mesh_edge_t) :: mesh_edge
    real, dimension(:,:), allocatable :: val_vert
    real :: val_vert_max, val_vert_min
  contains
    procedure :: initialize => slice__scalar_initialize
    procedure :: finalize => slice__scalar_finalize
    procedure :: set_val => slice__scalar_set_val
    procedure :: vis_contour => slice__scalar_vis_contour
  end type slice__scalar_t

  type, public :: slice__vector_t
    type(slice_mesh_vert_t) :: mesh_vert
    real, dimension(:,:), allocatable :: vect_x
    real, dimension(:,:), allocatable :: vect_y
    real :: amp_max, amp_min
  contains
    procedure :: initialize => slice__vector_initialize
    procedure :: finalize => slice__vector_finalize    
    procedure :: set_val => slice__vector_set_val
  end type slice__vector_t


contains


  subroutine slice__scalar_initialize( this, nu, nv,  &
                                       u_min, u_max,  &
                                       v_min, v_max,  &
                                       val )
    class(slice__scalar_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max
    real, dimension(vert_nu,vert_nv) <optin> :: val

    call this.mesh_vert.initialize( nu, nv,        &
                                    u_min, u_max,  &
                                    v_min, v_max )

    call this.mesh_cell_initialize( this.mesh_vert )
    call this.mesh_edge_initialize( this.mesh_vert )

    if ( present(val) ) then
      this.val_vert(:,:) = val(:,:)
    else
      this.val_vert(:,:) = 0.0
    end if

    call this.mesh_cell.set_meanval( this.mesh_vert,  &
                                     this.val_vert )
  end subroutine slice__scalar_initialize


  subroutine slice__scalar_set_val( this, nu, nv, val )
    class(slice__scalar_t) <io> :: this
    integer <in> :: nu, nv
    real, dimension(nu,nv) <in> :: val

    this.val_vert(:,:) = val(:,:)
    this.val_vert_max = maxval(val)
    this.val_vert_min = minval(val)
    call this.mesh_cell.set_meanval( this.mesh_vert,  &
                                     this.val_vert )
  end subroutine slice__scalar_set_val


  subroutine slice__scalar_finalize( this )
    class(slice__scalar_t) <io> :: this

    deallocate(this.val_vert)
    call this.mesh_vert.finalize
    call this.mesh_cell.finalize
    call this.mesh_edge.finalize
  end subroutine slice__scalar_finalize


  subroutine slice__scalar_vis_contour( this, level )
    class(slice__scalar_t) <in> :: this
    real <in> :: level
    
    !!>
        In the followings, "e" stands for "edge",
        and "c" stands for "cell". "i" is index
        in the u-direction and "j" is in v-direction.
        So, "ei" is edge-index in u and "cj" is 
        cell-index in v.

                    north               
                edgeu(ei=1,ej=4)       +---+---+---+ ej=4
                +------------+ .       | 3 |   |   |
              w | cell(ci,cj)|e  .     +---+---+---+ ej=3
              e |    with    |a    .   | 2 |   |   |
              s |  ci=1,cj=3 |s\     . +---+---+---+ ej=2
              t/|            |t \      | 1 | 2 | 3 |
              / +------------+ ..\.... +---+---+---+ ej=1
             /      / south       \   ei=1 2   3   4 
            /  edgeu(ei=1,ej=3)    \            
           /                        \
        edgev(ei=1,ej=3)           edgev(ei=2,ej=3)

                              edgeu(ei=3,ej=8)
            vert(vi=3,vj=8)   .    vert(vi=4,vj=8)
                         \    .   / 
                          o------o  
            edgev(3,7)....|      |....edgev(ei=4,ej=7)
                          |      |
                          o=====>V
                         /|  .   | \ vert(vi=4,vj=7)
           vert(vi=3,vj=7)|  .   |..............edgev(ei=4,ej=6)   
                             .   o 
              edgeu(ei=3,ej=7)    \
                                   vert(vi=4,vj=6)

        P: positive edge, eastward edgeu / northward edgev
        M: negative edge, westward edgeu / southward edgev
        1: vertex on which paths run straight forward.
        2: vertex on which paths turn left.
        3: vertex on which paths turn right.

       +---+---+---+---+---2=M=1=M=2
       |   |   |   |   |   M       P
       +---+---+---2=M=1=M=3=P=1=P=2
       |   |   |   M       P   |   |
       2=M=1=M=2---2=P=1=P=2---+---+
       M       P   |   |   |   |   |
       2=P=1=P=2=M=1=M=1=M=1=M=2---+
       |   |   M               P
       +---+---1           3=P=2
       |   |   M           P   |
       +---+---2=P=1=P=1=P=2---+
    !!<
    logical :: just_once = .true.
    type(contour_path_t), save :: contour_path

    ==<just_once>==
      call contour_path.initialize( this.mesh_vert.nu,  &
                                    this.mesh_vert.nv )
    ==</just_once>==

    call contour_path.reset
    call this.mesh_edge.apply_stokes( this.mesh_cell, level )

    do while ( this.mesh_edge.contour_path_exist() ) 
      call iFind_start_edge( 'E', i_now, j_now )
      call iTrace_path_and_erase_footprint( 'E', i_now, j_now, closed )


    end do

    call iExtract_boundary_curve

  contains


    subroutine iFind_start_edge( direct_now, i_now, j_now )
      char(len=1) :: direct_now
      integer <out> :: i_now, j_now
      !!>
            Tring to find a eastward arrow AB.
                +---+---+---+
                |           |
                A==>B       +
                 /  |       |
                /   +---+---+
               /
             This.
      !!< 
      integer :: ei, ej, v0i, v0j

      call ut__assert( direct_now=='E',  &
                      'We assume start edge is E(astward).' )
      do ej = 1, this.mesh_edge.u_nv
        do ei = 1, this.mesh_edge.u_nu
          if ( this.mesh_edge.u_ternary(ei,ej) == +1 ) then
            ! Found a boundary curve of 'E(astward)' direction.
            v0i = ei ! Vertex indexes of an left-end of
            v0j = ej ! an edge is the same as the edge indexes.
            i_now = v0i + 1
            j_now = v0j
            call contour_path.set_start_position( v0i, v0j )
            call contour_path.register( i_now, j_now ) ! Other end of edge.
            return
          end if
        end do
      end do 
      call ut__fatal( 'Cound not find a start edge.' )
    end subroutine iFind_start_edge

    subroutine iTrace_path_and_erase_footprint( direct_now,  &
                                                i_now,       &
                                                j_now,       &
                                                path_closed )
      char(len=1) <io> :: direct_now  ! E(ast)/N(orth)/W(est)/S(outh)-ward
      integer <io> :: i_now, j_now
      logical <out> :: path_closed

      logical :: path_closed
      integer :: i_now_before, j_now_before

      do 
        i_now_before = i_now
        j_now_before = j_now
        !
        ! left
        !
        call contour_path.turn_left( this.mesh_edge,     &
                                     this.mesh_vert.nu,  &
                                     this.mesh_vert.nv,  &
                                     direct_now,         &
                                     i_now, j_now,       &
                                     path_closed )
        if ( path_closed ) then
          return
        else
          call contour_path.register( i_now, j_now )
        end if

        !
        ! right
        !
        call contour_path.turn_right( this.mesh_edge,     &
                                      this.mesh_vert.nu,  &
                                      this.mesh_vert.nv,  &
                                      direct_now,         &
                                      i_now, j_now,       &
                                      path_closed )
        if ( path_closed ) then
          return
        else
          call contour_path.register( i_now, j_now )
        end if

        !
        ! straight
        !
        call contour_path.go_foward( this.mesh_edge,     &
                                     this.mesh_vert.nu,  &
                                     this.mesh_vert.nv,  &
                                     direct_now,         &
                                     i_now, j_now,       &
                                     path_closed )
        if ( path_closed ) then
          return
        else
        !!>
            We do not need to register the forward-stepped point,
            because the path
                     1---2---3
                             |          
                             4---5---6---7
            is the same as
                     1-------2
                             |          
                             3-----------4
        !!<
          ! call contour_path.register( i_now, j_now )
          ! So, we do nothing here.
        end if
        call ut__assert( i_now /= i_now_before .and.  &
                         j_now /= j_now_before,       &
                         'Failed to follow the path.' )
      end do

    end subroutine iTrace_path_and_erase_footprint


    subroutine iExtract_boundary_curve
      integer :: i, j  ! edges indexes
      integer :: path_vert_i, path_vert_j
      integer :: path_vert_num

      type(contour_path_t) :: contour_path
      integer :: max_path_segment_num_overestimate
      logical :: just_once = .true.



      ==<just_once>==
        max_path_segment_num_overestimate = this.edge_nu*edge_nv
        call contour_path.initialize( max_path_segment_num_overestimate, &
                                      this.vert_nu,  &
                                      this.vert_nv )
      ==</just_once>==

      call contour_path.reset


!      if ( contour_path.num == 0 ) return  ! No contour

      loops_to_folow_the_path : &
        direct_now = 'E'
        
        do ej = 1, this.grid.edgex_nv
          do ei = 1, this.grid.edgex_nu
            if ( this.grid.edgex_ternary(ei,ej) == +1 ) then
              ! Found a boundary curve of 'E(astward)' direction.
              v0i = ei ! Vertex indexes of an left-end of
              v0j = ej ! an edge is the same as the edge indexes.
              v1i = v0i + 1
              v1j = v0j
              call contour_path.set_start_position( v0i, v0j )
              call path_vert.register( v1i, v1j ) ! Other end of edge.
              exit finding_loops
            end if
          end do
        end do &
      loops_to_folow_the_path
      


      call path_vert.follow( )

      select case (vtip_direct)
        case '+x'
          !!>
                          edgex(ei=3,ej=8)
            vert(vi=3,vj=8)   .
                         \    .      
                          o------o  
            edgey(3,7)....|      |....edgey(4,7)
                          |      |
                          o------o
                         /   .    \
            vert(vi=3,vj=7)  .     vert(vi=4,vj=7)
                           edgex(ei=3,ej=7)
          !!<
          if ( this.grid_edgey_tenary(ei+1,ej) == +1 ) then
            ! turn to "up"
            call path_vert.register( vtip_i, vtip_j )
            vtip_direct = '+y'
            exit
          else if ( this.grid_edgey_tenary(ei+1,ej-1) == -1 ) then
            ! turn ton "down"
            call path_vert.register( vtip_i, vtip_j )
            vtip_direct = '-y'
            exit
          else 
            call ut__assert( this.grid_edgex_ternary(ei+1,ej) == +1,  &
                            'Something is strange.' )
            
          end if
          
          next_ej = ej - 1
          next_left_i = vtip_i
          next_left_j = vtip_j-1
          if ( this.grid.edgey_ternary( 'vtip_i,vtip_j))
          

      if ( step_forward_i==1 ) then
        direct = 'E'
      else if ( step_foward_j==1 ) then
        direct = 'N'
      else if ( step_foward_i==-1) then
        direct = 'W'
      else if ( step_foward_j=-1 )
        direct = 'S'
      else 
        call ut__fatal( 'Something is strange.' )
      end if



      call path_vert.set_tip( 'x', )  !   B of A===>B
      j = path_vert_j       !       
      do while ( i /= path_vert_i .and.  &
                 j /= path_vert_j )
        call path.vert_add( i, j )
        path_vert_num += 1
        path_vert_i(path_vert_num) = i
        patH-vert_j(path_vert_num) = j


            

    end subroutine iExtract_boundary_curve

  end subroutine slice__scalar_draw_contour


  subroutine slice__vector_initialize( this,        &
                                       vert_nu,     &
                                       vert_nv,     &
                                       vert_u_min,  &
                                       vert_u_max,  &
                                       vert_v_min,  &
                                       vert_v_max,  &
                                       vect_x,      &
                                       vect_y )
    class(slice__vector_t) <out> :: this
    integer <in> :: vert_nu, vert_nv
    real <in> :: vert_u_min, vert_u_max
    real <in> :: vert_v_min, vert_v_max
    real, dimension(vert_nu,vert_nv) <optin> :: vect_x, vect_y

    real, dimension(vert_nu,vert_nv) :: amp_vect

    call this.grid.initialize( vert_nu,     &
                               vert_nv,     &
                               vert_u_min,  &
                               vert_u_max,  &
                               vert_v_min,  &
                               vert_v_max )
    allocate(this.vect_x(vert_nu,vert_nv))
    allocate(this.vect_y(vert_nu,vert_nv))

    if ( present(vect_x) ) then
      this.vect_x(:,:) = vect_x(:,:)
    else
      this.vect_x(:,:) = 0.0
    end if

    if ( present(vect_y) ) then
      this.vect_y(:,:) = vect_y(:,:)
    else
      this.vect_y(:,:) = 0.0
    end if

    amp_vect = sqrt(vect_x**2+vect_y**2)

    this.amp_max = maxval(amp_vect)
    this.amp_min = minval(amp_vect)
  end subroutine slice__vector_initialize

  
  subroutine slice__vector_finalize( this )
    class(slice__vector_t) <out> :: this

    deallocate(this.vect_x)
    deallocate(this.vect_y)
    call this.grid.finalize
  end subroutine slice__vector_finalize


  subroutine slice__vector_set_val( this, vect_x, vect_y )
    class(slice__vector_t) <io> :: this
    real, dimension(vert_nu,vert_nv) <in> :: vect_x, vect_y

    this.vect_x(:,:) = vect_x(:,:)
    this.vect_y(:,:) = vect_y(:,:)
  end subroutine slice__vector_set_val

end module slice_m

