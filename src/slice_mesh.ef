module slice_mesh_m
  use const_base_m
  use ut_m
  implicit none
  private
  public :: SLICE_MESH__EDGE_MM,  &
            SLICE_MESH__EDGE_PP,  &
            SLICE_MESH__EDGE_MP,  &
            SLICE_MESH__EDGE_PM

  integer <const> :: SLICE_MESH__EDGE_MM = 0  ! --m===m-- 
  integer <const> :: SLICE_MESH__EDGE_MP = 1  ! --m===p-- 
  integer <const> :: SLICE_MESH__EDGE_PM = 2  ! --p===m-- 
  integer <const> :: SLICE_MESH__EDGE_PP = 3  ! --p===p-- 
    !!>
        When you change values of SLICE_MESH__EDGE_*,
        note that their positiveness is assumed in some checks.
    !!<

  type, public :: slice_mesh__vert_border_list_t
    integer :: num ! number of border vertex
    char(len=1), dimension(:,:), allocatable :: dir  ! N/S/W/E
    integer, dimension(:), allocatable :: vi
    integer, dimension(:), allocatable :: vj
  contains
    procedure : initialize => slice_mesh__vert_border_list_init
  end type slice_mesh__vert_border_list_t

  !!>
       in
       out
       border:
                N
                S
                E
                W
                NE
                NW
                SE
                SW
          N
        d   a   
      W   +   E
        c   b
          S
  !!<

  type, public :: slice_mesh__vert_dborder_list_t
    integer :: num ! number of diagnoal border vertex
    char(len=2), dimension(:), allocatable :: dir  ! NE/NW/SW/SE
    integer, dimension(:), allocatable :: vi
    integer, dimension(:), allocatable :: vj
  contains
    procedure : initialize => slice_mesh__vert_dborder_list_init
  end type slice_mesh__vert_dborder_list_t  

  type, public :: slice_mesh__vert_t
    !!>  
        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
    !!< 
    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
    char(len=1), dimension(:,:), allocatable :: grid_type ! 'i' / 'b' / 'o'
                                                          !  in / border / out
    type(slice_mesh__vert_border_list_t) :: border_list
    type(slice_mesh__vert_dborder_list_t) :: dborder_list
  contains
    procedure, private :: slice_mesh__vert_initialize_with_grids
    procedure, private :: slice_mesh__vert_initialize_with_uvmaxmin
    generic :: initialize => slice_mesh__vert_initialize_with_grids,  &
                             slice_mesh__vert_initialize_with_uvmaxmin
  end type slice_mesh__vert_t  

  type, public :: slice_mesh__edge_t
    !!>                            
        + vertex            v     d                                 
        u edge_u            |   /
        v edge_v            | /
        d edge_d            +---- u
                                    
            | \   / | \   / | \   / | \   / | 
            v   d   v   d   v   d   v   d   v
            | /   \ | /   \ | /   \ | /   \ |
           -+---u---+---u---+---u---+---u---+-
            | \   / | \   / | \   / | \   / |
            v   d   v   d   v   d   v   d   v
            | /   \ | /   \ | /   \ | /   \ |
           -+---u---+---u---+---u---+---u---+-
            | \   / | \   / | \   / | \   / |
            v   d   v   d   v   d   v   d   v
            | /   \ | /   \ | /   \ | /   \ |
    !!< 
    integer :: u_nu, u_nv
    integer :: v_nu, v_nv
    integer, dimension(:,:), allocatable :: u_quarter   ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: v_quarter   ! {0,1,2,3}

    integer, dimension(:), allocatable :: d_quarter   ! {0,1,2,3}
      !!>
          Take an edge V1-V2. 
                    V1--edge--V2  
          Denote "p" when V1 or V2 > level (of the contour),
          and "m" when V1 or V2 < level. For example, when
          V1 > level and V2 < level, 
                     p--edge--m
             There are four possibilities.

          Combination | quarter
          ------------+--------
             m - - m  |  0
             m - - p  |  1
             p - - m  |  2
             p - - p  |  3 (Special quarter for border edges)
      !!<
    real, dimension(:,:), allocatable :: u_cross_coord
    real, dimension(:,:), allocatable :: v_cross_coord
    real, dimension(:), allocatable :: u_cross_coord_on_diag_edge
    real, dimension(:), allocatable :: v_cross_coord_on_diag_edge
                                            
  contains
    procedure :: initialize => slice_mesh__edge_initialize
    procedure :: finalize => slice_mesh__edge_finalize
    procedure :: set_quarter => slice_mesh__edge_set_quarter
    procedure, private :: slice_mesh_edge__erase_uv_edge
    procedure, private :: slice_mesh_edge__erase_d_edge
    general :: erase => slice_mesh_edge__erase_uv_edge,  &
                        slice_mesh_edge__erase_d_edge
  end type slice_mesh__edge_t    


contains


  subroutine slice_mesh__vert_dborder_list_init( this, nu, nv )
    class(slice_mesh__vert_dborder_list_t) <out> :: this
    integer <in> :: nu, nv

    integer :: max_num_overestimate 

    max_num_overestimate = 20*(nu+nv)
       ! A rough (over) estimate. Increase it, if necessary.

    this.num = 0
    allocate(this.dborder_list_dir(nu,nv))
    allocate(this.dborder_list.vi(max_num_overestimate))
    allocate(this.dborder_list.vj(max_num_overestimate))
  end subroutine slice_mesh__vert_dborder_list_init


  subroutine slice_mesh__vert_border_list_init( this, nu, nv )
    class(slice_mesh__vert_border_list_t) <out> :: this
    integer <in> :: nu, nv

    integer :: max_num_overestimate 

    max_num_overestimate = 20*(nu+nv)
       ! A rough (over) estimate. Increase it, if necessary.

    this.num = 0
    allocate(this.border_list_dir(nu,nv))
    allocate(this.border_list.vi(max_num_overestimate))
    allocate(this.border_list.vj(max_num_overestimate))
  end subroutine slice_mesh__vert_border_list_init  


  subroutine set_default_grid_type( nu, nv,  &
                                    grid_type )
    integer <in> :: nu, nv
    char(len=1) <out> :: grid_type
    !!>
                  b b b b b b b b b 
                  b i i i i i i i b
                  b i i i i i i i b
                  b i i i i i i i b
                  b b b b b b b b b 
    !!<                  
    integer :: i, j

    do j = 1, nv
      do i = 1, nu
        if ( i==1 .or. i==nu .or.  &
             j==1 .or. j==nv ) then
          grid_type(i,j) = 'b'
        else
          grid_type(i,j) = 'i'
        end if
      end do
    end do
  end subroutine set_default_grid_type


  subroutine classify_grid_type( nu, nv,       &
                                 grid_type,    &
                                 border_list,  &
                                 dborder_list )
    integer <in> :: nu, nv
    char(len=1) <in> :: grid_type
    type(slice_mesh__vert_border_list_t) <io> :: border_list
    type(slice_mesh__vert_dborder_list_t) <io> :: dborder_list

    integer :: head_i, head_j, head_i_start, head_j_start
    char(len=1) :: t
    integer, dimension(4) :: counts  ! counts(1) 'b'
                                     ! counts(2) 'd'
                                     ! counts(3) 'o'
                                     ! counts(4) 'i'    

    call iCount_grid_type( nu, nv, grid_type, counts )
    call iFind_a_point_in_border_for_start( nu, nv,    &
                                            head_i_start, head_j_start )

    i = head_i_start
    j = head_j_start
    do 
      

  
  contains

    subroutine iFind_a_point_in_border_for_start( nu, nv,           &
                                                  grid_type,        &
                                                  head_i, head_j )
      integer <in> :: nu, nv
      char(len=1), dimension(nu,nv) <in> :: grid_type
      integer <out> :: head_i, head_j
      integer :: i, j

      do j = 1, nv
        do i = 1, nu
          t = grid_type(i,j)
          if ( t == 'b' .or. t == 'd' ) then
            head_i = i
            head_j = j
            return
          end if
        end do
      end do

      call ut__fatal( "__MODULE__(__LINE__): " //  &
                      "Failed to find a start point on border." )
    end subroutine iFind_a_point_in_border_for_start

    subroutine iCount_grid_type( nu, nv, grid_type, counts )
      integer <in> :: nu, nv
      char(len=1), dimension(nu,nv) <in> :: grid_type
      integer, dimension(4) <out> :: counts

      integer :: i, j

      counts(:) = 0
      do j = 1, nv
        do i = 1, nu
          t = grid_type(i,j)
          if ( t == 'b' ) then
            counts(1) += 1
          else if ( t == 'd' ) then
            counts(2) += 1
          else if ( t = 'o' ) then
            counts(3) += 1
          else if ( t = 'i' ) then
            counts(4) += 1
          else
            call ut__fatal( "__MODULE__(__LINE__): "  & 
                            "Border type error." )
          end if
        end do
      end do
  
      call ut__assert( sum(counts) == nu*nv,            &
                        "__MODULE__(__LINE__): " //     &
                        "Grid type sum check error." )
    end subroutine iCount_grid_type

  end subroutine classify_grid_type


  function linear_interpol( x1, x2, diff1, diff2 ) result( xi )
    real <in> :: x1, x2, diff1, diff2
    real :: xi
    !!>   
        Diff1 and diff2 can be negative but they 
        must have the same sign.

         \
          \ - - - - - - - - -  val(x1)
          .\                 |
          . \      x=x2      | diff1 > 0.0
          .  \     |         |
      ----o===+====o-------------- level 
          |   .\   .         |
       x=x1   . \  .         | diff2 > 0.0
              .  \ .         |
              .   \ - - - - -  val(x2)
            x=xi   \

    !!<
    real :: weight1, weight2

    call ut__assert( x1 < x2,  &
                     "__MODULE__(__LINE__): Bad grids order." )
    call ut__assert( diff1*diff2 >= 0.0,  &
                     "__MODULE__(__LINE__): Cannot interpolate." )

    if ( diff1+diff2 == 0.0  ) then
      ! which means diff1 = 0.0 & diff2 = 0.0
      xi = (x1+x2)/2 ! Take the middle point
                     ! I'm not very sure if this is OK.
    else
      ! The following applies in either cases of
      !  (1) diff1 > 0 & diff2 > 0
      !  (2) diff1 < 0 & diff2 < 0
      weight1 = diff2 / (diff1 + diff2)
      weight2 = 1.0 - weight1
      xi = weight1 * x1 + weight2 * x2
      call ut__assert( xi >= x1 .and. xi <= x2,  &
                       "__MODULE__(__LINE__): Weight is out of range." )
    end if
  end function linear_interpol


  function quarter_of_edge_ends( v1, v2, val ) result(ans)
    if ( v1 < level .and. v2 < level ) then
      ans = SLICE_MESH__EDGE_MM
    else if ( v1 > level .and. v2 > level ) then
      ans = SLICE_MESH__EDGE_PP
    else if ( v1 >= level .and. v2 < level ) then          
      ans = SLICE_MESH__EDGE_PM
    else if ( v1 < level .and. v2 >= level ) then
      ans = SLICE_MESH__EDGE_MP  
    else
      call ut__fatal( "__MODULE__(__LINE__): " //  &
                      "case error." )
    end if
  end function quarter_of_edge_ends


  subroutine slice_mesh_edge__erase_uv_edge( this, which_edge, ei, ej )
    class(slice_mesh__edge_t) <io> :: this
    char(len=1) <in> :: which_edge
    integer <in> :: ei, ej
    
    if ( which_edge == 'u' ) then
      this.u_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else if ( which_edge == 'v' ) then
      this.v_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else 
      call ut__fatal( '__MODULE__(__LINE__): argument error.' )
    end if
  end subroutine slice_mesh_edge__erase_uv_edge


  subroutine slice_mesh_edge__erase_d_edge( this, vert, nth )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    integer <in> :: nth

    call ut__assert( nth >= 1 .and.                     &
                     nth <= vert.dborder_list.num,  &
                     "__MODULE__(__LINE__): " //        &
                     "over the range." )
    this.d_quarter(nth) = SLICE_MESH__EDGE_MM
  end subroutine slice_mesh_edge__erase_d_edge


  subroutine slice_mesh__vert_initialize_with_grids( this,          &
                                                     nu, nv,        &
                                                     grid_pos_u,    &
                                                     grid_pos_v,    &
                                                     grid_type )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    char(len=1), dimension(nu,nv) <optin> :: grid_type ! 'i'(nside of border)
                                                       ! 'b'(border itself)
                                                       ! 'o'(utside of border)
    !!>
        case 1  境界上の値がカドの点も含めて設定されている場合

                  b b b b b b b b b 
                  b i i i i i i i b
                  b i i i i i i i b
                  b i i i i i i i b
                  b b b b b b b b b 

        case 2  境界上のカドの点には値が設定されていない場合

            カドの点はo (outer)点とする。全ての境界格子点を一周、反時計回りに
            回る。次の格子点が水平あるいは垂直方向にある場合は、b (border) 点とする。
            次の境界格子点が斜め方向にある場合は、それをd (diagonal) 点とする。
            シミュレーション領域の内部は i (inner) 点とする。
                        <--- 
                  o d b b b b b b o
              |   b i i i i i i i d  ^
              |   b i i i i i i i b  |
              v   d i i i i i i i b  |
                  o b b b b b b d o 
                        --->

        case 3a  境界が長方形でなく、d点が存在しない場合
        
                  o o o b b b b b o
                  b b b b i i i b o
                  b i i i i i i b o
                  b b b b i i i b o
                  o o o b b b b b o
        

        case 3b  境界が長方形でなく、d点が存在する場合

                  o o o o d o o o o
                  o o o d i d o o o
                  o o d i i i d o o
                  o d i i i i b o o
                  o o b b b b b o o
    !!<
    real :: u_min, u_max
    real :: v_min, v_max
    integer :: max_num_border_verts

    u_min = grid_pos_u(1)
    u_max = grid_pos_u(nu)
    v_min = grid_pos_v(1)
    v_max = grid_pos_v(nv)

    call ut__assert( u_max > u_min,       &
                    '__MODULE__(__LINE__): Invalid coords u.' )
    call ut__assert( v_max > v_min,       &
                    '__MODULE__(__LINE__): Invalid coords v.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))
    allocate(this.grid_type(nu,nv))
    call this.border_list.init( nu,nv )
    call this.dborder_list.init( nu, nv )

    this.pos_u(:) = grid_pos_u(:)
    this.pos_v(:) = grid_pos_v(:)

    if ( present(grid_type) ) then
      this.grid_type(:,:) = grid_type(:,:)
    else
      call set_default_grid_type( nu, nv, this.grid_type )      
    end if

    call classify_grid_type( nu, nv,            &
                             this.grid_type,    &
                             this.border_list,  &
                             tthis.dborder_list )

  end subroutine slice_mesh__vert_initialize_with_grids


  subroutine slice_mesh__vert_initialize_with_uvmaxmin( this, nu, nv,  &
                                                        u_min, u_max,  &
                                                        v_min, v_max )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max

    real :: du, dv
    integer :: i, j
    integer :: max_num_border_verts

    call ut__assert( (nu > 1) .and.         &
                     (nv > 1) .and.         &
                     (u_max > u_min) .and.  &
                     (v_max > v_min),       &
                    '__MODULE__(__LINE__): Invalid arguments.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))
    allocate(this.grid_type(nu,nv))
    call this.border_list.init( nu,nv )
    call this.dborder_list.init( nu, nv )

    du = ( u_max - u_min ) / (nu-1)
    dv = ( v_max - v_min ) / (nv-1)

    do i = 1, nu
      this.pos_u(i) = u_min + du*(i-1)
    end do

    do j = 1, nv
      this.pos_v(j) = v_min + dv*(j-1)
    end do

    call set_default_grid_type( nu, nv, this.grid_type )

    call classify_grid_type( nu, nv,            &
                             this.grid_type,    &
                             this.border_list,  &
                             tthis.dborder_list )
  
  end subroutine slice_mesh__vert_initialize_with_uvmaxmin


  subroutine make_border_list( vert, edge )
    type(slice_mesh__vert_t) <io> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: ei, ej  ! e stands for edge
    integer :: b ! border count
    integer :: head_vi, head_vj ! head vertex
    char(len=1) :: dir  ! direction
    integer :: vcounter ! border vertex counter
    integer, dimension(4) :: check

    call iFind_1st_border_u_edge( ei, ej )

    !          edge_u(i,j)
    !         /
    !    o - - - o
    !     \       \
    !      v(i,j)  v(i+1,j)

    vcounter = 1
    head_vi = ei
    head_vj = ej
    dir = 'E' ! u-edge, goint eastward, as a starter.

    vert.border_list_dir(head_vi,head_vj) = dir
    vert.border_list_vi(vcounter) = head_vi  ! left vert
    vert.border_list_vj(vcounter) = head_vj  ! of u-edge

    head_vi += 1  ! shift eastward.
    vcounter += 1 ! right vert of the u-edge
    vert.border_list_vi(vcounter) = head_vi
    vert.border_list_vj(vcounter) = head_vj

    do b = 1, size(vert.border_list_vi,dim=1) 
      ! will exit in the middle of this do-loop
      check(1) = iShould_go_northward( dir, head_vi, head_vj )
      check(2) = iShould_go_southward( dir, head_vi, head_vj )
      check(3) = iShould_go_eastward ( dir, head_vi, head_vj )
      check(4) = iShould_go_westward ( dir, head_vi, head_vj )

      call ut__assert( sum(check(1:4)) == 1,        &
                       "__MODULE__(__LINE__): " //  &
                       "Should be just one border for next." )

      if ( check(1) == 1 ) then
        dir = 'N'
        vert.border_list_dir(head_vi,head_vj) = dir
        head_vj += 1
      else if ( check(2) == 1 ) then
        dir = 'S'
        vert.border_list_dir(head_vi,head_vj) = dir
        head_vj -= 1
      else if ( check(3) == 1 ) then
        dir = 'E'
        vert.border_list_dir(head_vi,head_vj) = dir
        head_vi += 1
      else if ( check(4) == 1 ) then
        dir = 'W'
        vert.border_list_dir(head_vi,head_vj) = dir
        head_vi -= 1
      else
        call ut__fatal( "__MODULE__(__LINE__): " //  &
                        "Check num error." )
      end if

      if ( head_vi == vert.border_list_vi(1) .and.  &
           head_vj == vert.border_list_vj(1) ) then
        ! returned to the starter u-edge.
        vert.border_list_num = vcounter
        return
      end if

      vcounter += 1
      vert.border_list_vi(vcounter) = head_vi
      vert.border_list_vj(vcounter) = head_vj
    end do

    call ut__fatal( "__MODULE__(__LINE__): " //  &
                    "Failed to close the border_list." )

  contains
    
    subroutine iFind_1st_border_u_edge( ei, ej )
      integer <out> :: ei, ej

      integer :: i, j
      do j = 1, edge.u_nv
        do i = 1, edge.u_nu
          if ( edge.is_border_u(i,j) ) then
            ! Have found a border u-edge.
            ei = i
            ej = j
            return
          end if
        end do
      end do
      call ut__fatal( "__MODULE__(__LINE__): " // &
                      "Failed to find the first border_u edge." )
    end subroutine iFind_1st_border_u_edge

    function iShould_go_northward( dir, vi, vj ) result(ans)
      char(len=1) <io> :: dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( dir == 'S' ) return ! You came from there.
      if ( vj >= vert.nv ) return ! there is no north v-edge
      if ( edge.is_border_v(vi,vj) ) ans = 1
    end function iShould_go_northward

    function iShould_go_southward( dir, vi, vj ) result(ans)
      char(len=1) <io> :: dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( dir == 'N' ) return ! You came from there.
      if ( vj <= 1 ) return ! there is no south v-edge
      if ( edge.is_border_v(vi,vj-1) ) ans = 1
    end function iShould_go_southward

    function iShould_go_eastward( dir, vi, vj ) result(ans)
      char(len=1) <io> :: dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( dir == 'W' ) return ! You came from there.
      if ( vi >= vert.nu ) return ! there is no east v-edge
      if ( edge.is_border_u(vi,vj) ) ans = 1
    end function iShould_go_eastward    

    function iShould_go_westward( dir, vi, vj ) result(ans)
      char(len=1) <io> :: dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( dir == 'E' ) return ! You came from there.
      if ( vi <= 1 ) return ! there is no west v-edge
      if ( edge.is_border_u(vi-1,vj) ) ans = 1
    end function iShould_go_westward      
    
  end subroutine make_border_list


  subroutine slice_mesh__edge_initialize( this,         &
                                          mesh_vert,    &
                                          is_border_u,  &
                                          is_border_v )
    class(slice_mesh__edge_t) <out> :: this
    class(slice_mesh__vert_t) <io> :: mesh_vert
    logical, dimension(:,:) <optin> :: is_border_u
    logical, dimension(:,:) <optin> :: is_border_v
    !!>
                            edgev                                    
                              |
                              |
                              +---- edgeu

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
    !!<

    this.u_nu = mesh_vert.nu - 1
    this.u_nv = mesh_vert.nv
    this.v_nu = mesh_vert.nu
    this.v_nv = mesh_vert.nv - 1
    this.a_nu = mesh_vert.nu - 1
    this.a_nv = mesh_vert.nv - 1
    this.d_nu = mesh_vert.nu - 1
    this.d_nv = mesh_vert.nv - 1

    allocate(this.u_cross_coord(this.u_nu,  &
                                this.u_nv))
    allocate(this.v_cross_coord(this.v_nu,  &
                                this.v_nv))
    allocate(this.u_quarter(this.u_nu,  &
                            this.u_nv))
    allocate(this.v_quarter(this.v_nu,  &
                            this.v_nv))
    allocate(this.a_quarter(this.a_nu,  &
                            this.a_nv))
    allocate(this.d_quarter(this.d_nu,  &
                            this.d_nv))
    allocate(this.is_border_u(this.v_nu,  &
                              this.v_nv))
    allocate(this.is_border_v(this.v_nu,  &
                              this.v_nv))

    call iBorder_set

    call make_border_list( mesh_vert, this )    

  contains

    subroutine iBorder_set
      integer :: u_nu_, u_nv_, v_nu_, v_nv_

      this.is_border_u(:,:) = .false.  ! default bulk edges
      this.is_border_v(:,:) = .false.

      if ( present(is_border_v) ) then
        call ut__assert( present(is_border_u),              &
                         "__MODULE__(__LINE__): "           &
                         // "Needs both border_u and _v." )
        u_nu_ = size(is_border_u,dim=1)
        u_nv_ = size(is_border_u,dim=2)
        v_nu_ = size(is_border_v,dim=1)
        v_nv_ = size(is_border_v,dim=2)
        call ut__assert( u_nu_ == this.u_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of border_u and mesh_edge." )
        call ut__assert( u_nv_ == this.u_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of border_u and mesh_edge." )
        call ut__assert( v_nu_ == this.v_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of border_u and mesh_edge." )
        call ut__assert( v_nv_ == this.v_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of border_v and mesh_edge." )
        this.is_border_u(:,:) = is_border_u(:,:)
        this.is_border_v(:,:) = is_border_v(:,:)
      else 
        ! the case of usual (rectangular) border
        this.is_border_u(:,        1) = .true. ! south bourder
        this.is_border_u(:,this.u_nv) = .true. ! north bourder
        this.is_border_v(        1,:) = .true. ! west bourder
        this.is_border_v(this.v_nu,:) = .true. ! east bourder
      end if
    end subroutine iBorder_set

  end subroutine slice_mesh__edge_initialize


  subroutine slice_mesh__edge_finalize( this )
    class(slice_mesh__edge_t) <io> :: this

    deallocate(this.u_quarter)
    deallocate(this.v_quarter)
    deallocate(this.a_quarter)
    deallocate(this.d_quarter)
  end subroutine slice_mesh__edge_finalize  


  function edge_level_check_set_u_quarter( edge_u_nu,  &
                                           edge_u_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(u_quarter) 

    integer <in> :: edge_u_nu, edge_u_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_u_nu,edge_u_nv)  :: u_quarter
    !!>
        Here we compare the scalar field value "vert_val" 
        on each vertex at (i,j) 

                  val_vert(i,j)

        with "level" of the target contour. The comparison
        is applied through edges. 

        There are two kinds of edges, vertical edges (edgve_v)
        and horizontal edges (edge_u).

                         v ("vertical")
                         |
                         |
                         +----- u ("horizontal")

              edge_u
            o--------o
            |        |
     edge_v |        | edge_v
            |        |
            o--------o
              edge_u

        Every edge is labeled by a pair of indeces
        in u and v directions, (ei,ej), while every
        vertex is also labeled by a pair of indeces.

        The two kinds of indexes are related by the
        following figure.

                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)

        Now we denote a vertex binary label
        p (plus) or m (minus); "p" when
                  val_vert(i,j) > level,
        and "m" when 
                  val_vert(i,j) < level.

        And we assign a quarter (four) label
        for every edge as

              Edge    | quarter
          ------------+--------
             m----m   |  0
             m----p   |  1
             p----m   |  2
             p----p   |  3

        For example,
                    MM
                m--------m
                |        |
             PM |        | MM
                |        |
                p--------m
                    PM

        =====
              Case MM

                The path does not cross this edge.
                         ei   ei+1
                          |    |      .      
                      ----M====M---.---- level
                          |    |._______ val_vert(ei+1,ej)
                          |  . |
                          .----|-------- val_vert(ei,ej)
                       .  |    |

              Case PP

                The path does not cross this edge.
                But special care would be taken when
                this edge is on the border (ej=1 or u_nv).
                          .
                          |    . 
                      ----P====P----.------ level
                         ei   ei+1       .

              Case PM

                The path goes through the edge.
                     .
                       .       u2
                       | .     |
                   ----p===.===m----
                       |   | . |
                      u1   |   .
                           |     .
                          u=ui

              Case MP

                The path goes through the edge, too.
                                 .
                       u1      . 
                       |     . |
                   ----m===.===p----
                       | . |   |
                       .   |   u2
                     .     |     
                          u=ui
        =====
    !!<

    integer :: ei, ej  ! edge indexes. They 
                       ! are simply converted
                       ! to vertex indexes
    real :: val1, val2

    ! edge_u
    do ej = 1, edge_u_nv  
      do ei = 1, edge_u_nu
        val1 = val_vert(ei,  ej)
        val2 = val_vert(ei+1,ej)
        u_quarter(ei,ej) = quarter_of_edge_ends( val1, val2, level )
      end do
    end do
  end function edge_level_check_set_u_quarter


  function edge_level_check_set_v_quarter( edge_v_nu,  &
                                           edge_v_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(v_quarter)

    integer <in> :: edge_v_nu, edge_v_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_v_nu,edge_v_nv) :: v_quarter

    !!>
        See comments in "edge_level_check_set_u_quarter".
    !!<

    integer :: ei, ej  ! edge indexes
    real :: val1, val2

    do ej = 1, edge_v_nv  
      do ei = 1, edge_v_nu
        val1 = val_vert(ei,ej  )
        val2 = val_vert(ei,ej+1)
        u_quarter(ei,ej) = quarter_of_edge_ends( val1, val2, level )
      end do
    end do

  end function edge_level_check_set_v_quarter  


  function edge_level_check_set_a_quarter( ei, ej,     &
                                           edge_a_nu,  &
                                           edge_a_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(a_quarter)

    integer <in> :: ei, ej
    integer <in> :: edge_a_nu, edge_a_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_a_nu,edge_a_nv) :: a_quarter

    !!>
        See comments in "edge_level_check_set_u_quarter".
    !!<

    if ( val_vert(ei,  ej  ) < level .and. &
         val_vert(ei+1,ej+1) < level ) then
      a_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else if ( val_vert(ei,  ej  ) > level .and. &
              val_vert(ei+1,ej+1) > level ) then
      a_quarter(ei,ej) = SLICE_MESH__EDGE_PP
    else if ( val_vert(ei,  ej  ) >= level .and. &
              val_vert(ei+1,ej+1) <  level ) then          
      a_quarter(ei,ej) = SLICE_MESH__EDGE_PM
    else if ( val_vert(ei,  ej  ) <  level .and. &
              val_vert(ei+1,ej+1) >= level ) then
      a_quarter(ei,ej) = SLICE_MESH__EDGE_MP
    else
      call ut__fatal( "__MODULE__(__LINE__): case error." )
    end if

  end function edge_level_check_set_a_quarter    


  function edge_level_check_set_d_quarter( ei, ej,     &
                                           edge_d_nu,  &
                                           edge_d_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(d_quarter)

    integer <in> :: ei, ej
    integer <in> :: edge_d_nu, edge_d_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_d_nu,edge_d_nv) :: d_quarter

    !!>
        See comments in "edge_level_check_set_u_quarter".
    !!<

    if ( val_vert(ei,  ej  ) < level .and. &
         val_vert(ei+1,ej-1) < level ) then
      d_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else if ( val_vert(ei,  ej  ) > level .and. &
              val_vert(ei+1,ej-1) > level ) then
      d_quarter(ei,ej) = SLICE_MESH__EDGE_PP
    else if ( val_vert(ei,  ej  ) >= level .and. &
              val_vert(ei+1,ej-1) <  level ) then          
      d_quarter(ei,ej) = SLICE_MESH__EDGE_PM
    else if ( val_vert(ei,  ej  ) <  level .and. &
              val_vert(ei+1,ej-1) >= level ) then
      d_quarter(ei,ej) = SLICE_MESH__EDGE_MP
    else
      call ut__fatal( "__MODULE__(__LINE__): case error." )
    end if

  end function edge_level_check_set_d_quarter   


  subroutine slice_mesh__edge_set_quarter( this,       &
                                           mesh_vert,  &
                                           val_vert,   &
                                           level )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    real, dimension(mesh_vert.nu,  &
                    mesh_vert.nv) <in> :: val_vert
    real <in> :: level

    this.u_quarter(:,:) = -999  ! Any negative. Used later to
    this.v_quarter(:,:) = -999  ! check if all edges are set,
                                ! using ...QUATER_MM, MP, PM, 
                                ! PP are all non-negative.
    this.u_cross_coord(:,:) = NAN ! Reset
    this.v_cross_coord(:,:) = NAN

    this.u_quarter = edge_level_check_set_u_quarter(      &
                                         this.u_nu,       &
                                         this.u_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )

    this.v_quarter = edge_level_check_set_v_quarter(      &
                                         this.v_nu,       &
                                         this.v_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )


    call iInterpol_cross_point_edge_u
    call iInterpol_cross_point_edge_v

    call ut__assert( minval(this.u_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_u." )
    call ut__assert( minval(this.v_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_v." )

    call iSet_diagonal_border

  contains

    subroutine iSet_diagonal_border( level )
      real <in> :: level

      !!>
          注意。このdiagnonal edgeにおける4値（quarter）の定義は
          u_edge/v_edge と異なる。 u_edgeの場合は
              val(vi,vj) - level > 0 .and. val(vi+1,vj) - level < 0
          の場合に
              quarter(ei,ej) = PM
          としていた。vi=ei, vj=ej の場合、つまり現在注目している頂点 {i,j} が
          このu_edgeの左端である場合は特に問題ない。自分が M で右隣がPである。

            自分 {i,j}    {i+1,j}
               \         /
                P - - - M
          
          だが、vi=ei+1, vj=ej つまりこのu_edgeの右端に注目している
          頂点 {i,j} がある場合は、おなじ
              quarter(ei,ej) = PM
          の値は、自分 {i,j} が P で左隣の頂点が M である。

            {i-1,j}     自分 {i,j}
               \         /
                P - - - M
          つまりこの場合は PM を右から左に読む必要がある。

          一方、d_edgeの場合は、自分から右斜め上方向に行く次のような
          d_edgeの場合も、

                    + - - - - M
                    |       d |
                    |    d    |
                    | d       |
                    P - - - - +
                     \
                   自分 {i,j}

          左斜め上に行く次のような場合も、

                    M - - - - M
                    | d       |
                    |    d    |
                    |       d |
                    + - - - - P
                               \
                                自分 {i,j}
          どちらも d_edge = PM とする。つまり常に左から右に読む。
          
      !!<
      integer :: b, vi, vj
      char(len=2) :: dir
      real :: val1, u1, v1
      real :: val2, u2, v2
      integer :: quarter

      do b = 1, mesh_vert.diagonal_border_num
!debugp "__FUNC__", b
        vi = mesh_vert.diagonal_border_list_vi(b)
        vj = mesh_vert.diagonal_border_list_vj(b)
        dir = mesh_vert.diagonal_border_list_dir(b)
!debugp "__FUNC__", vi, vj
!debugp "__FUNC__", dir
  
        this.u_cross_coord_on_diagonal_edge(b) = NAN  ! reset
        this.v_cross_coord_on_diagonal_edge(b) = NAN

        val1 = val_vert(vi,vj)
        u1 = mesh_vert.pos_u(vi)
        v1 = mesh_vert.pos_v(vj)

        select case (dir)
          case ('NE')
            val2 = val_vert(vi+1,vj+1)
            u2 = mesh_vert.pos_u(vi+1)
            v2 = mesh_vert.pos_v(vj+1)
          case ('NW')
            val2 = val_vert(vi-1,vj+1)
            u2 = mesh_vert.pos_u(vi-1)
            v2 = mesh_vert.pos_v(vj+1)
          case ('SE')
            val2 = val_vert(vi+1,vj-1)
            u2 = mesh_vert.pos_u(vi+1)
            v2 = mesh_vert.pos_v(vj-1)
          case ('SW')
            val2 = val_vert(vi-1,vj-1)
            u2 = mesh_vert.pos_u(vi-1)
            v2 = mesh_vert.pos_v(vj-1)
          case default
            call ut__fatal( "__MODULE__(__LINE__): " //  &
                            "case error." )
        end select

        quarter = quarter_of_edge_ends( val1, val2, level )
        this.d_quarter(b) = quarter
!debugp "__FUNC__", quarter

        if ( quarter == SLICE_MESH__EDGE_MP  .or.                                   &
             quarter == SLICE_MESH__EDGE_PM ) then
          diff1 = val1 - level
          diff2 = level - val2
          this.u_cross_coord_on_diagonal_edge(b) = linear_interpol( u1, u2, diff1, diff2 )
          this.v_cross_coord_on_diagonal_edge(b) = linear_interpol( v1, v2, diff1, diff2 )
!debugp this.u_cross_coord_on_diagonal_edge(b)
!debugp this.v_cross_coord_on_diagonal_edge(b)
        end if
      end do    
    end subroutine iSet_diagonal_border

    subroutine iInterpol_cross_point_edge_u
      real :: u1, u2, diff1, diff2
      integer :: ei, ej, quarter
      !!> 
              .                                 .
                .       u2            u1      . 
                | .     |             |     . |
            ----p===.===m----     ----m===.===p----
                |   | . |             | . |   |
               u1   |   .             .   |   u2
                    |     .         .     |  
                   u=ui                  u=ui
      !!<

      do ej = 1, this.u_nv
        do ei = 1, this.u_nu
          quarter = this.u_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_vert.pos_u(ei+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei+1,ej)
            this.u_cross_coord(ei,ej) = linear_interpol( u1, u2, diff1, diff2 )
              ! For both MP and PM cases.
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_u

    subroutine iInterpol_cross_point_edge_v
      real :: v1, v2, diff1, diff2
      integer :: ei, ej, quarter
      ! edge_v
      do ej = 1, this.v_nv
        do ei = 1, this.v_nu
          quarter = this.v_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            v1 = mesh_vert.pos_v(ej)
            v2 = mesh_vert.pos_v(ej+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei,ej+1)
            this.v_cross_coord(ei,ej) = linear_interpol( v1, v2, diff1, diff2 )
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_v    

  end subroutine slice_mesh__edge_set_quarter  

end module slice_mesh_m
