!!>

    # Module slice_mesh

    ## Two kinds of grid mesh info; vert(ex) and edge

    ### Vertex


        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |


    ### Edge
                            v     __a                                 
        u edge_u            |   /         +----- u
        v edge_v            | /           | \
        a edge_ascend       +----- u      |   \   
        d edge_descend                    v     \ __d
                                    
            |     / | \     |     / | \     | 
            v   a   v   d   v   a   v   d   v
            | /     |     \ | /     |     \ |
           -+---u---+---u---+---u---+---u---+-
            | \     |     / | \     |     / |
            v   d   v   a   v   d   v   a   v
            |     \ | /     |     \ | /     |
           -+---u---+---u---+---u---+---u---+-
            |     / | \     |     / | \     | 
            v   a   v   d   v   a   v   d   v
            | /     |     \ | /     |     \ |


     ## Quarter integer for edge
     
       Each edge has one of four integers (0-3) for a given
       value of contour level.

          Take an edge V1-V2. 
                    V1--edge--V2  
          Denote "p" when V1 or V2 > level (of the contour),
          and "m" when V1 or V2 < level. For example, when
          V1 > level and V2 < level, 
                     p--edge--m
             There are four possibilities.

          Combination | quarter
          ------------+--------
             m - - m  |  0
             m - - p  |  1
             p - - m  |  2
             p - - p  |  3 (Special quarter for boundary edges)


     ## boundary path

        When NU=9, NV=5, the common data assignment for
        each vertex is 

                5    b b b b b b b b b 
                4    b i i i i i i i b
                3    b i i i i i i i b
                2    b i i i i i i i b
                1    b b b b b b b b b 
                     
                     1 2 3 4 5 6 7 8 9

        where 'b' stands for the boundary data and
        'i' stands for the bulk data of the simulation.

        We define the boundary path, a closed line, by connecting 
        the consequtive 'b' points in the counter-clockwise direction.

                     <--- this way ---  
                                        \   
                5    * * * * * * * * *   \
                4    * . . . . . . . *    |  this way
                3    * . . . . . . . *    |   
                2    * . . . . . . . *    |  (counter-clockwise)
                1    * * * * * * * * *    |
                     
                     1 2 3 4 5 6 7 8 9


        The boundary path can have more complex shape than a rectangle,
        for example,

                     <--- this way ---  
                                        \   
                5    * * * * * * . . .   \
                4    * . . . . * * * *    |  this way
                3    * * * . . . . . *    |   
                2    . . * . . . . . *    |  (counter-clockwise)
                1    . . * * * * * * *    |
                     
                     1 2 3 4 5 6 7 8 9

        To denote a boundary path, we define boundary_list array that
        holds vertex position and direction. Here direction is
        defined by two consective verts of the path. In the above
        case, denoting N/E/S/W for North/East/South/West.
          
                     S W W W W W . . .   
                     S . . . . N W W W   
                     E E S . . . . . N   
                     . . S . . . . . N   
                     . . E E E E E E N   

     ## octa_direct

        We use octal integer (octa_direct) from 0 to 7 to indicate 
        the direction of the path segment.

        0 for North, 2 for East, 4 for South, and 6 for West.

                     4 6 6 6 6 6 . . .   
                     4 . . . . 0 6 6 6  
                     2 2 4 . . . . . 0   
                     . . 4 . . . . . 0   
                     . . 2 2 2 2 2 2 0   

        boundary path may have diagonal edge like

                     . * * * * * . . .
                     * . . . . . * . .
                     . * . . . . * . .
                     . . * . . . * . .  
                     . . . * * * . . .  

        We assign integers from 0 to 7 to the 8 directions as 

                           North : 0                
                      North-East : 1                0  
                            East : 2            7       1  
                      South-East : 3                |            
                           South : 4           6  --+--  2
                      South-West : 5                |	          
                            West : 6            5       3
                      North-West : 7                4	  

        The above path is written as

                     . 5 6 6 6 6 . . .
                     3 . . . . . 7 . .
                     . 3 . . . . 0 . .
                     . . 3 . . . 0 . .  
                     . . . 2 2 1 . . .  

     ## Flag integer for vert
     
        In addition to boundary verts, we assign 'i' or 'o'
        letters to inside or outside verts of the boundary path.

                     o 5 6 6 6 6 o o o
                     3 i i i i i 7 o o
                     o 3 i i i i i 7 o   
                     o o 3 i i i 1 o o   
                     o o o 2 2 1 o o o  
     
     ## Turn letters

        Instead of the direction, such N/E/S/W or octa_direct 0-7,
        we can describe a closed path by consective turn directions.
        Denoting 
               'R' for the right (90-degree) turn,
               'r' for the right (45-degree) turn,
               'L' for the left (90-degree) turn,
               'l' for the left (45-degree) turn,
           and 'f' for no turn,

        the above path can be written as

                     . l f f f l . . .
                     L . . . . . l . .
                     . f . . . . f . .
                     . . f . . . l . .  
                     . . . 2 f l . . .  
                     
        In this turn-letter expression, we need at least one 
        vert that is assigned the octa_direct integer or 'R/E/S/W'.
!!<

module slice_mesh_m
  use const_base_m
  use ut_m
  implicit none
  private
  public :: SLICE_MESH__EDGE_MM,  &
            SLICE_MESH__EDGE_PP,  &
            SLICE_MESH__EDGE_MP,  &
            SLICE_MESH__EDGE_PM

  integer <const> :: SLICE_MESH__EDGE_MM = 0  ! --m---m-- 
  integer <const> :: SLICE_MESH__EDGE_MP = 1  ! --m---p-- 
  integer <const> :: SLICE_MESH__EDGE_PM = 2  ! --p---m-- 
  integer <const> :: SLICE_MESH__EDGE_PP = 3  ! --p---p-- 

  type, public :: slice_mesh__vert_t
    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
    character, dimension(:,:), allocatable :: flag 
                       !        'i' : inside the boundary
                       !        'o' : outside the boundary
                       ! 'N' or '0' : boundary of path direct North
                       !        '1' : boundary of path direct Nourth-East
                       ! 'E' or '2' : boundary of path direct East
                       !        '3' : boundary of path direct South-Wast
                       ! 'S' or '4' : boundary of path direct South
                       !        '5' : boundary of path direct South-West
                       ! 'W' or '6' : boundary of path direct West
                       !        '7' : boundary of path direct Nourth-West
  contains
    procedure, private :: slice_mesh__vert_initialize_with_grids
    procedure, private :: slice_mesh__vert_initialize_with_uvmaxmin
    generic :: initialize => slice_mesh__vert_initialize_with_grids,  &
                             slice_mesh__vert_initialize_without_grids
    procedure :: is_boundary => slice_mesh__vert_is_boundary
  end type slice_mesh__vert_t  

  type, public :: slice_mesh__edge_t
    integer :: u_nu, u_nv
    integer :: v_nu, v_nv
    integer, dimension(:,:), allocatable :: u_quarter   ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: v_quarter   ! {0,1,2,3}
    real, dimension(:,:), allocatable :: u_cross_coord
    real, dimension(:,:), allocatable :: v_cross_coord
  contains
    procedure :: initialize => slice_mesh__edge_initialize
    procedure :: set_quarter => slice_mesh__edge_set_quarter
    procedure :: erase => slice_mesh_edge__erase_uv_edge
  end type slice_mesh__edge_t    

  type, public :: slice_mesh__boundary_vert_t
    integer :: num ! number of boundary verts
    integer, dimension(:), allocatable :: octa_direct
    integer, dimension(:), allocatable :: vi  ! vert
    integer, dimension(:), allocatable :: vj
  contains
    procedure : initialize => slice_mesh__boundary_vert_init   
    procedure :: get_nth => slice_mesh__boundary_vert_get_nth
  end type slice_mesh__boundary_vert_t

  type, public :: slice_mesh__boundary_edge_t
    integer :: num ! number of boundary edges
    character, dimension(:), allocatable :: edge_type  ! 'u'/'v'/'a'/'d'
    integer, dimension(:), allocatable :: ei  ! edge index
    integer, dimension(:), allocatable :: ej
    integer, dimension(:), allocatable :: b_quarter   ! {0,1,2,3}
    real, dimension(:), allocatable :: u_cross_coord
    real, dimension(:), allocatable :: v_cross_coord
  contains
    procedure :: initialize => slice_mesh__boundary_edge_initialize   
    procedure :: erase => slice_mesh__boundary_edge_erase
  end type slice_mesh__boundary_edge_t

  type, public :: slice_mesh__boundary_t
    type(slice_mesh__boundary_vert_t) :: vert
    type(slice_mesh__boundary_edge_t) :: edge
  contains
    procedure :: initialize => slice_mesh__boundary_initialize
    procedure :: make_list => slice_mesh__boundary_make_list
  end type slice_mesh__boundary_t


contains


  subroutine slice_mesh__boundary_initialize( this, vert. edge )
    class(slice_mesh__boundary_t) <out> :: this

    call this.vert.initialize
    call this.edge.initialize
    call this.make_list( vert, edge )
  end subroutine slice_mesh__boundary_initialize


  subroutine slice_mesh__boundary_edge_erase( this,        &
                                              which_edge,  &
                                              ei,          &
                                              ej )
    class(slice_mesh__boundary_vert_t) <io> :: this
    character <in> :: which_edge ! 'u' / 'v' / 'a' / 'd'
    integer <in> :: ei, ej

    integer :: n, i, j

    do n = 1, this.num
      i = this.ei(n)
      j = this.ej(n)
      if ( i == ei .and. j == ej ) then
        this.b_quarter(n) = SLICE_MESH__EDGE_MM
        return
      end if
    end do

  end subroutine slice_mesh__boundary_edge_erase

  function slice_mesh__vert_is_boundary( this, vi, vj ) result(ans)
    class(slice_mesh__vert_t) <in> :: this
    integer <in> :: vi, vj
    logical :: ans

    if ( this.flag(vi,vj) == 'i' .or  &
         this.flag(vi,vj) == 'o' ) then
      ans = .false.
    else
      ans = .true.
    end if
  end function slice_mesh__vert_is_boundary

  function slice_mesh__boundary_vert_get_nth( this, vi, vj ) result(nth)
    class(slice_mesh__boundary_vert_t) <in> :: this
    integer <in> :: vi, vj
    integer :: nth

    integer :: i, j, n

    do n = 1, this.num
      i = this.vi(n)
      j = this.vj(n)
      if ( i == vi .and. j == vj ) then
        nth = n
        return
      end if
    end do
    call ut__fatal( "__MODULE__(__LINE__): Not a boundary vert." )
  end function slice_mesh__boundary_vert_get_nth


  subroutine slice_mesh__boundary_vert_init( this, nu, nv, vert_flag )
    class(slice_mesh__boundary_vert_t) <out> :: this
    integer <in> :: nu, nv
    character, dimension(nu,nv) <in> :: vert_flag

    integer :: boundary_vert_num

    boundary_vert_num = iCount_boundary_vert( nu, nv, vert_flag )
    this.num = boundary_vert_num
!debugp "__FUNC__", boundary_vert_num  

    allocate(this.octa_direct(boundary_vert_num))
    allocate(         this.vi(boundary_vert_num))
    allocate(         this.vj(boundary_vert_num))

  contains

    function iCount_boundary_vert( nu, nv, vert_flag ) result(num)
      integer <in> :: nu, nv
      character, dimension(nu,nv) <in> :: vert_flag
      integer :: num

      integer :: i, j
      character :: flag

      num = 0
      do j = 1, nv
        do i = 1, nu
          flag = vert_flag(i,j)
          if ( flag == 'N' .or.  &
               flag == 'E' .or.  &
               flag == 'S' .or.  &
               flag == 'W' .or.  &
               flag == '0' .or.  &
               flag == '1' .or.  &
               flag == '2' .or.  &
               flag == '3' .or.  &
               flag == '4' .or.  &
               flag == '5' .or.  &
               flag == '6' .or.  &
               flag == '7' .or.  &
               flag == 'f' .or.  &
               flag == 'r' .or.  &
               flag == 'R' .or.  &
               flag == 'l' .or.  &
               flag == 'L' ) then
            num += 1
          end if
        end do
      end do
    end subroutine iCount_boundary_vert

  end subroutine slice_mesh__boundary_vert_init  


  function flag_to_octa_direct( flag ) result(octa_direct)
    character <in> :: flag
    integer :: nocta_direct

    select case (flag)
      case ('N')
        octa_direct = 0
      case ('E')
        octa_direct = 2
      case ('S')
        octa_direct = 4
      case ('W')
        octa_direct = 6
      case ('0')
        octa_direct = 0
      case ('1')
        octa_direct = 1
      case ('2')
        octa_direct = 2
      case ('3')
        octa_direct = 3
      case ('4')
        octa_direct = 4
      case ('5')
        octa_direct = 5
      case ('6')
        octa_direct = 6
      case ('7')
        octa_direct = 7 
      case default
        octa_direct = -1 ! any negative number
    end select

  end function flag_to_octa_direct


  subroutine get_next_octa_direct_and_vert( nu, nv,       &
                                            i, j,         &
                                            flag,         &
                                            octa_direct )
    integer <in> :: nu, nv
    integer <io> :: i, j
    character <in> :: flag       ! N/S/E/W/[0-7]/f/r/R/l/L
    integer <out> :: octa_direct ! 0 (North), 1 (North-East),
                                 ! 2 (East) , 3 (South-East), 
                                 ! 4 (South), 5 (South-West), 
                                 ! 6 (West),  7 (North-West)

    select case (flag)
      case ('N', 'E', 'S', 'W',  &
            '0', '1', '2', '3',  &
            '4', '5', '6', '7')
        octa_direct = flag_to_octa_direct( flag )
        call ut__assert( octa_direct >= 0 .and.  &
                         octa_direct <= 7,       &
                         "__MODULE__(__LINE__): case error." )
      case ('f')
       ! do nothing. keep the current octa_direct
      case ('r')
        octa_direct = mod(octa_direct+1,8)
      case ('R')
        octa_direct = mod(octa_direct+2,8)
      case ('l')
        octa_direct = mod(octa_direct+7,8)
      case ('L')
        octa_direct = mod(octa_direct+6,8)
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

    select case (octa_direct)
      case (0) ! North
        j += 1
      case (1) ! North-East
        i += 1
        j += 1
      case (2) ! East
        i += 1
      case (3) ! South-East
        i += 1
        j -= 1
      case (4) ! South
        j -= 1
      case (5) ! South-West
        i -= 1
        j -= 1
      case (6) ! West
        i -= 1
      case (7) ! North-West
        i -= 1
        j += 1
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

    call assert( next_i >= 1 .and. next_i <= nu,  &
                 "__MODULE__(__LINE__): i-range error." )
    call assert( next_j >= 1 .and. next_j <= nv,  &
                 "__MODULE__(__LINE__): j-range error." )
  end subroutine get_next_octa_direct_and_vert


  subroutine set_default_vert_flag( nu, nv, vert_flag )
    integer <in> :: nu, nv
    character, dimension(nu,nv) <out> :: vert_flag
    !!>
                  L W W W W W W W L 
                  S i i i i i i i N
                  S i i i i i i i N
                  S i i i i i i i N
                  L E E E E E E E L
    !!<
    vert_flag(2:nu-1,2:nv-1) = 'i'
    vert_flag(     1,     1) = 'L'
    vert_flag(2:nu-1,     1) = 'E'
    vert_flag(   nu,      1) = 'L'
    vert_flag(    nu,2:nv-1) = 'N'
    vert_flag(    nu,    nv) = 'L'
    vert_flag(2:nu-1,    nv) = 'W'
    vert_flag(     1,    nv) = 'L'
    vert_flag(     1,2:nv-1) = 'S'
  end subroutine set_default_vert_flag


  subroutine get_edge_id( vi, vj, octa_direct, ei, ej, edge_type )
    integer <in> :: vi, vj     ! id of vertex
    integer <in> :: octa_direct  ! from 0 (north) to 7 (north-west)
    integer <out> :: ei, ej    ! id of edge
    character :: edge_type ! 'u' / 'v' / 'a' / 'd'
    !!>
                   edge_u(ei,ej)            edge_v(ei,ej)
       (vi,vj+1)--> + - - - +                + - - - +
                    |       |                v       | \__ (vi+1,vj+1)
                    |       |                v       |
                    |       |                v       |
        (vi,vj) --> + u u u +    (vi,vj) --> + - - - +
                           /          
                     (vi+1,vj)   


                   edge_a(ei,ej)            edge_d(ei,ej)
       (vi,vj+1)--> + - - - a                + - - - +
                    |     a |                | d     |
                    |   a   |                |   d   |
                    | a     |                |     d |
        (vi,vj) --> + - - - +    (vi,vj) --> + - - - +
    !!<

    select case (octa_direct)
      case (0) 
        ei = vi             !    *
        ej = vj             !    *
        edge_type = 'v'     !    * . . .
      case (1)
        ei = vi             !    .   * 
        ej = vj             !    . *
        edge_type = 'a'     !    * . . .
      case (2)
        ei = vi             !    .
        ej = vj             !    .
        edge_type = 'u'     !    * * * *
      case (3)
        ei = vi             !    * . . .
        ej = vj - 1         !    . *
        edge_type = 'd'     !    .   *
      case (4) 
        ei = vi             !    * . . .
        ej = vj - 1         !    *
        edge_type = 'v'     !    *
      case (5) 
        ei = vi - 1         !    . . . *
        ej = vj - 1         !        * .
        edge_type = 'a'     !      *   .
      case (6) 
        ei = vi - 1         !          .
        ej = vj             !          .
        edge_type = 'u'     !    * * * *
      case (7) 
        ei = vi - 1         !      *   .
        ej = vj + 1         !        * .
        edge_type = 'd'     !    . . . *
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

  end function get_edge_id


  subroutine set_b_edge_quarter_and_cross_coord( vert, level, boundary_edge )
    type(slice_mesh__vert_t) <in> :: vert
    real <in> :: level
    type(slice_mesh__boundary_edge_t) <io> :: boundary_edge

    !!>
        注意。b_edge (boundary edge)における4値（quarter）の定義は
        u_edge や v_edge と異なる。 たとえば u_edge の場合、
            val(vi,vj) - level > 0 .and. val(vi+1,vj) - level < 0
        のとき
            quarter(ei,ej) = PM
        としていた。vi=ei, vj=ej の場合、つまり現在注目している頂点 {i,j} が
        このu_edgeの左端である場合は自分が M で右隣がPである。

          自分 {i,j}    {i+1,j}
              \         /
              P - - - M
        
        だが、vi=ei+1, vj=ej つまりこのu_edgeの右端に注目している
        頂点 {i,j} がある場合は、おなじ
            quarter(ei,ej) = PM
        の値は、自分 {i,j} が P で左隣の頂点が M である。

          {i-1,j}     自分 {i,j}
              \         /
              P - - - M
        つまりこの場合は "PM" を右から左に読む必要がある。

        一方、b_edgeの場合は、u-, v-, a-, d-方向のいずれも常に左から右に読む。
        たとえば、num番目の境界点の座標が (vi,vj)=(10,NV) だとすると、
            u_quarter(10,NV) = MP
        のとき
            b_quarter(num) = PM
        である。

        d_edgeの場合も、

                  + - - - - M
                  |       d |
                  |    d    |
                  | d       |
                  P - - - - +
                    \
                  自分 {i,j}

        左斜め上に行く次のような場合も、

                  M - - - - M
                  | d       |
                  |    d    |
                  |       d |
                  + - - - - P
                              \
                              自分 {i,j}
        どちらも d_edge = PM とする。
        
    !!<
    integer :: index_v, index_v2 ! verts index for both ends
    integer :: index_e           ! edge index
    integer :: vi, vj, ei, ej, vi2, vj2
    real :: val1, u1, v1, diff1
    real :: val2, u2, v2, diff2
    integer :: quarter, vbnum
    real :: interpol_u, interpol_v

    boundary_edge.u_cross_coord(:) = NAN 
    boundary_edge.v_cross_coord(:) = NAN
      !!> 
           To catch errornous cases in which a contour
           path tries to cross a non PM or MP edge.
      !!<
    boundary_edge.b_quarter(:) = -999 ! Any negative (anormaly) number.

    !!>
               v1--[e2]--v2--[e3]--v3
              /                    /
            [e7]                 [e4]
            /                    /
           v6--[e6]--v5--[e5]--v4
    !!<

    vbnum = boundary_vert.num ! just to shorten
    do index_v = 1, vbnum
      vi = boundary_vert.vi(index_v)
      vj = boundary_vert.vj(index_v)

      val1 = val_vert(vi,vj)
      u1 = vert.pos_u(vi)
      v1 = vert.pos_v(vj)

      index_v2 = index_v1 + 1
      if ( index_v2 > vbnum ) index_v2 -= vbnum

      vi2 = boundary_vert.vi(index_v2)
      vj2 = boundary_vert.vj(index_v2)
      val2 = val_vert(vi2,vj2)
      u2 = vert.pos_u(vi2)
      v2 = vert.pos_v(vj2)

      quarter = quarter_of_edge_ends( val1, val2, level )

      index_e = index_v
      call ut__assert( index_e <= boundary_edge.num, &
                       "__MODULE__(__LINE__): " //      &
                       "index_e out of range." )

      boundary_edge.b_quarter(index_e) = quarter

      if ( quarter == SLICE_MESH__EDGE_MP  .or.  &
           quarter == SLICE_MESH__EDGE_PM ) then
        diff1 = val1 - level
        diff2 = level - val2
        interpol_u = linear_interpol( u1, u2, diff1, diff2 )
        interpol_v = linear_interpol( v1, v2, diff1, diff2 )
        boundary_edge.u_cross_coord(index_e) = interpol_u
        boundary_edge.v_cross_coord(index_e) = interpol_v
      end if        
    end do    

  end subroutine set_b_edge_quarter_and_cross_coord


  subroutine slice_mesh__boundary_make_list( this, vert, edge )
    class(slice_mesh__boundary_t) <io> :: this
    type(slice_mesh__vert_t) <io> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: vi, vj, start_vi, start_vj
    integer :: num_of_boundary_vert
    integer :: counter

    num_of_boundary_vert = this.vert.num

    call iFind_a_boundary_vert_with_octa_direct( nu, nv,        &
                                               vert.flag,     &
                                               vi, vj,        &
                                               octa_direct )
    start_vi = vi
    start_vj = vj
    counter = 1
    this.vert.octa_direct(counter) = octa_direct
    this.vert.vi(counter) = vi
    this.vert.vj(counter) = vj

    call get_edge_id( i, j, octa_direct, ei, ej, edge_type )
    
    this.edge.ei(counter) = ei
    this.edge.ej(counter) = ej
    this.edge.edge_type(counter) = edge_type

    do counter = 2, num_of_boundary_vert 
      call get_next_octa_direct_and_vert( nu, nv,           &
                                          i, j,             &
                                          vert_flag(i,j),   &
                                          octa_direct )
      if ( i == head_i .and. j == head_j ) then
        ! have come back to the start point
        return
      end if
      counter += 1
      this.edge.octa_direct(counter) = octa_direct
      this.vert.vi(counter) = i
      this.vert.vj(counter) = j
      call get_edge_id( i, j, octa_direct, ei, ej, edge_type )
      this.edge.ei(counter) = ei
      this.edge.ej(counter) = ej
      this.edge.edge_type(counter) = edge_type
    end do

    call ut__fatal( "__MODULE__(__LINE__): Failed to close boundary." )
  
  contains

    subroutine iFind_a_boundary_vert_with_octa_direct( nu, nv,           &
                                                     vert_flag,        &
                                                     head_i, head_j,   &
                                                     head_octa_direct )
      integer <in> :: nu, nv
      character, dimension(nu,nv) <in> :: vert_flag
      integer <out> :: head_i, head_j
      integer <out> :: head_octa_direct

      integer :: i, j
      character :: flag

      do j = 1, nv
        do i = 1, nu
          flag = vert_flag(i,j)
          octa_direct = flag_to_octa_direct( flag )
          if ( octa_direct > 0 ) then
            head_i = i
            head_j = j
            head_octa_direct = octa_direct
            return
          end if
        end do
      end do

      call ut__fatal( "__MODULE__(__LINE__): " //  &
                      "Failed to find a start point on boundary." )
    end subroutine iFind_a_boundary_vert_with_octa_direct

  end subroutine slice_mesh__boundary_make_list


  function linear_interpol( x1, x2, diff1, diff2 ) result( xi )
    real <in> :: x1, x2, diff1, diff2
    real :: xi
    !!>   
        Diff1 and diff2 can be negative but they 
        must have the same sign.

         \
          \ - - - - - - - - -  val(x1)
          .\                 |
          . \      x=x2      | diff1 > 0.0
          .  \     |         |
      ----o===+====o-------------- level 
          |   .\   .         |
       x=x1   . \  .         | diff2 > 0.0
              .  \ .         |
              .   \ - - - - -  val(x2)
            x=xi   \

    !!<
    real :: weight1, weight2

    call ut__assert( x1 < x2,  &
                     "__MODULE__(__LINE__): Bad grids order." )
    call ut__assert( diff1*diff2 >= 0.0,  &
                     "__MODULE__(__LINE__): Cannot interpolate." )

    if ( diff1+diff2 == 0.0  ) then
      ! which means diff1 = 0.0 & diff2 = 0.0
      xi = (x1+x2)/2 ! Take the middle point
                     ! I'm not very sure if this is OK.
    else
      ! The following applies in either cases of
      !  (1) diff1 > 0 & diff2 > 0
      !  (2) diff1 < 0 & diff2 < 0
      weight1 = diff2 / (diff1 + diff2)
      weight2 = 1.0 - weight1
      xi = weight1 * x1 + weight2 * x2
      call ut__assert( xi >= x1 .and. xi <= x2,  &
                       "__MODULE__(__LINE__): Weight is out of range." )
    end if
  end function linear_interpol


  function quarter_of_edge_ends( v1, v2, val ) result(ans)
    if ( v1 < level .and. v2 < level ) then
      ans = SLICE_MESH__EDGE_MM
    else if ( v1 > level .and. v2 > level ) then
      ans = SLICE_MESH__EDGE_PP
    else if ( v1 >= level .and. v2 < level ) then          
      ans = SLICE_MESH__EDGE_PM
    else if ( v1 < level .and. v2 >= level ) then
      ans = SLICE_MESH__EDGE_MP  
    else
      call ut__fatal( "__MODULE__(__LINE__): " //  &
                      "case error." )
    end if
  end function quarter_of_edge_ends


  subroutine slice_mesh_edge__erase_uv_edge( this, which_edge, ei, ej )
    class(slice_mesh__edge_t) <io> :: this
    char(len=1) <in> :: which_edge
    integer <in> :: ei, ej
    
    if ( which_edge == 'u' ) then
      this.u_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else if ( which_edge == 'v' ) then
      this.v_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else 
      call ut__fatal( '__MODULE__(__LINE__): argument error.' )
    end if
  end subroutine slice_mesh_edge__erase_uv_edge


  subroutine slice_mesh_edge__erase_d_edge( this, vert, nth )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    integer <in> :: nth

    call ut__assert( nth >= 1 .and.                     &
                     nth <= vert.dboundary_list.num,  &
                     "__MODULE__(__LINE__): " //        &
                     "over the range." )
    this.d_quarter(nth) = SLICE_MESH__EDGE_MM
  end subroutine slice_mesh_edge__erase_d_edge


  subroutine slice_mesh__vert_initialize_with_grids( this,          &
                                                     nu, nv,        &
                                                     grid_pos_u,    &
                                                     grid_pos_v,    &
                                                     vert_flag )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    character, dimension(nu,nv) <optin> :: vert_flag
                       ! 'i' : inside the boundary
                       ! 'o' : outside the boundary
                       ! 'N' or '0' : boundary of path direct North
                       !        '1' : boundary of path direct Nourth-East
                       ! 'E' or '2' : boundary of path direct East
                       !        '3' : boundary of path direct South-Wast
                       ! 'S' or '4' : boundary of path direct South
                       !        '5' : boundary of path direct South-West
                       ! 'W' or '6' : boundary of path direct West
                       !        '7' : boundary of path direct Nourth-West
    !!>
        case 1  境界上の値がカドの点も含めて設定されている場合

                  b b b b b b b b b 
                  b i i i i i i i b
                  b i i i i i i i b
                  b i i i i i i i b
                  b b b b b b b b b 

        case 2  境界上のカドの点には値が設定されていない場合

            カドの点はo (outer)点とする。全ての境界格子点を一周、反時計回りに
            回る。次の格子点が水平あるいは垂直方向にある場合は、b (boundary) 点とする。
            次の境界格子点が斜め方向にある場合は、それをd (diagonal) 点とする。
            シミュレーション領域の内部は i (inner) 点とする。
                        <--- 
                  o d b b b b b b o
              |   b i i i i i i i d  ^
              |   b i i i i i i i b  |
              v   d i i i i i i i b  |
                  o b b b b b b d o 
                        --->

        case 3a  境界が長方形でなく、d点が存在しない場合
        
                  o o o b b b b b o
                  b b b b i i i b o
                  b i i i i i i b o
                  b b b b i i i b o
                  o o o b b b b b o
        

        case 3b  境界が長方形でなく、d点が存在する場合

                  o o o o d o o o o
                  o o o d i d o o o
                  o o d i i i d o o
                  o d i i i i b o o
                  o o b b b b b o o
    !!<
    real :: u_min, u_max
    real :: v_min, v_max
    integer :: max_num_boundary_verts

    u_min = grid_pos_u(1)
    u_max = grid_pos_u(nu)
    v_min = grid_pos_v(1)
    v_max = grid_pos_v(nv)

    call ut__assert( u_max > u_min,       &
                    '__MODULE__(__LINE__): Invalid coords u.' )
    call ut__assert( v_max > v_min,       &
                    '__MODULE__(__LINE__): Invalid coords v.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))
    allocate(this.flag(nu,nv))

    this.pos_u(:) = grid_pos_u(:)
    this.pos_v(:) = grid_pos_v(:)

    if ( present(vert_flag) ) then
      this.flag(:,:) = vert_flag(:,:)
    else
      call set_default_vert_flag( nu, nv, this.flag )      
    end if

    call boundary.vert.initialize( nu, nv, this.flag )

  end subroutine slice_mesh__vert_initialize_with_grids


  subroutine slice_mesh__vert_initialize_without_grids( this, nu, nv,  &
                                                        u_min, u_max,  &
                                                        v_min, v_max )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max

    real :: du, dv
    integer :: i, j
    integer :: max_num_boundary_verts

    call ut__assert( (nu > 1) .and.         &
                     (nv > 1) .and.         &
                     (u_max > u_min) .and.  &
                     (v_max > v_min),       &
                    '__MODULE__(__LINE__): Invalid arguments.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))
    allocate(this.flag(nu,nv))

    du = ( u_max - u_min ) / (nu-1)
    dv = ( v_max - v_min ) / (nv-1)

    do i = 1, nu
      this.pos_u(i) = u_min + du*(i-1)
    end do

    do j = 1, nv
      this.pos_v(j) = v_min + dv*(j-1)
    end do

    call set_default_grid_type( nu, nv, this.flag )

    call boundary.vert.initialize( nu, nv, this.flag )
  
  end subroutine slice_mesh__vert_initialize_without_grids


  subroutine slice_mesh__edge_initialize( this, vert )
    class(slice_mesh__edge_t) <out> :: this
    type(slice_mesh__vert_t) <io> :: vert
    !!>
                            edgev                                    
                              |
                              |
                              +---- edgeu

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
    !!<
  
    integer :: u_nu, u_nv, v_nu, v_nv

    u_nu = vert.nu - 1
    u_nv = vert.nv
    v_nu = vert.nu
    v_nv = vert.nv - 1

    this.u_nu = u_nu
    this.u_nv = u_nv
    this.v_nu = v_nu
    this.v_nv = v_nv

    allocate(this.u_quarter(u_nu,u_nv))
    allocate(this.v_quarter(v_nu,v_nv))
    allocate(this.u_cross_coord(u_nu,u_nv))
    allocate(this.v_cross_coord(v_nu,v_nv))

  contains

    subroutine iboundary_set
      integer :: u_nu_, u_nv_, v_nu_, v_nv_

      this.is_boundary_u(:,:) = .false.  ! default bulk edges
      this.is_boundary_v(:,:) = .false.

      if ( present(is_boundary_v) ) then
        call ut__assert( present(is_boundary_u),              &
                         "__MODULE__(__LINE__): "           &
                         // "Needs both boundary_u and _v." )
        u_nu_ = size(is_boundary_u,dim=1)
        u_nv_ = size(is_boundary_u,dim=2)
        v_nu_ = size(is_boundary_v,dim=1)
        v_nv_ = size(is_boundary_v,dim=2)
        call ut__assert( u_nu_ == this.u_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of boundary_u and mesh_edge." )
        call ut__assert( u_nv_ == this.u_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of boundary_u and mesh_edge." )
        call ut__assert( v_nu_ == this.v_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of boundary_u and mesh_edge." )
        call ut__assert( v_nv_ == this.v_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of boundary_v and mesh_edge." )
        this.is_boundary_u(:,:) = is_boundary_u(:,:)
        this.is_boundary_v(:,:) = is_boundary_v(:,:)
      else 
        ! the case of usual (rectangular) boundary
        this.is_boundary_u(:,        1) = .true. ! south bourder
        this.is_boundary_u(:,this.u_nv) = .true. ! north bourder
        this.is_boundary_v(        1,:) = .true. ! west bourder
        this.is_boundary_v(this.v_nu,:) = .true. ! east bourder
      end if
    end subroutine iboundary_set

  end subroutine slice_mesh__edge_initialize


  subroutine slice_mesh__boundary_edge_initialize( this, vert_boundary_num )
    class(slice_mesh__boundary_edge_t) <out> :: this
    integer <in> :: vert_boundary_num

    this.num = vert_boundary_num

    allocate(    this.edge_type(this.num))
    allocate(           this.ei(this.num))
    allocate(           this.ej(this.num))
    allocate(    this.b_quarter(this.num))
    allocate(this.u_cross_coord(this.num))
    allocate(this.v_cross_coord(this.num))
  end subroutine slice_mesh__boundary_edge_initialize


  subroutine set_uv_edge_quarter( vert,       &
                                  val_vert,   &
                                  level,      &
                                  edge )
    type(slice_mesh__vert_t) <in> :: vert
    real, dimension(vert.nu,vert.nv) <in> :: val_vert
    real <in> :: level
    type(slice_mesh__edge_t) <io> :: edge
    !!>
        Here we compare the scalar field value "vert_val" 
        on each vertex at (i,j) 

                  val_vert(i,j)

        with "level" of the target contour. The comparison
        is applied on every edge. 

        There are two kinds of edges, vertical edges (edgve_v)
        and horizontal edges (edge_u).

                         v ("vertical")
                         |
                         |
                         +----- u ("horizontal")

              edge_u
            o--------o
            |        |
     edge_v |        | edge_v
            |        |
            o--------o
              edge_u

        Every edge is labeled by a pair of indeces
        in u and v directions, (ei,ej), while every
        vertex is also labeled by a pair of indeces.

        The two kinds of indexes are related by the
        following figure.

                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)

        Now we denote a vertex binary label
        p (plus) or m (minus); "p" when
                  val_vert(i,j) > level,
        and "m" when 
                  val_vert(i,j) < level.

        And we assign a quarter (four) label
        for every edge as

              Edge    | quarter
          ------------+--------
             m----m   |  0
             m----p   |  1
             p----m   |  2
             p----p   |  3

        For example,
                    MM
                m--------m
                |        |
             PM |        | MM
                |        |
                p--------m
                    PM

        =====
              Case MM

                The path does not cross this edge.
                         ei   ei+1
                          |    |      .      
                      ----M====M---.---- level
                          |    |._______ val_vert(ei+1,ej)
                          |  . |
                          .----|-------- val_vert(ei,ej)
                       .  |    |

              Case PP

                The path does not cross this edge.
                But special care would be taken when
                this edge is on the boundary (ej=1 or u_nv).
                          .
                          |    . 
                      ----P====P----.------ level
                         ei   ei+1       .

              Case PM

                The path goes through the edge.
                     .
                       .       u2
                       | .     |
                   ----p===.===m----
                       |   | . |
                      u1   |   .
                           |     .
                          u=ui

              Case MP

                The path goes through the edge, too.
                                 .
                       u1      . 
                       |     . |
                   ----m===.===p----
                       | . |   |
                       .   |   u2
                     .     |     
                          u=ui
        =====
    !!<

    integer :: ei, ej  ! edge indexes.
    real :: val_left, val_right
    real :: val_lower, val_upper
    integer :: vi, vi_left, vi_right
    integer :: vj, vj_lower, vj_upper

    ! edge_u
    do ej = 1, edge.u_nv  
      do ei = 1, edge.u_nu
        vi_left  = ei
        vi_right = ei + 1
        vj = ej
        val_left  = val_vert(vi_left,  vj)  ! left vert
        val_right = val_vert(vi_right, vj)  ! right vert
        edge.u_quarter(ei,ej) = quarter_of_edge_ends( val_left,   &
                                                      val_right,  &
                                                      level )
      end do
    end do

    ! edge_v
    do ej = 1, edge.v_nv  
      do ei = 1, edge.v_nu
        vi = ei
        vj_lower = ej
        vj_upper = ej + 1
        val_lower = val_vert(vi,vj_lower)  ! lower vert
        val_upper = val_vert(vi,vj_upper)  ! upper vert
        edge.u_quarter(ei,ej) = quarter_of_edge_ends( val_lower,  &
                                                      val_upper,  &
                                                      level )
      end do
    end do    

  end subroutine set_uv_edge_quarter


  subroutine slice_mesh__edge_set_quarter( this,       &
                                           vert,       &
                                           val_vert,   &
                                           level )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    real, dimension(vert.nu,vert.nv) <in> :: val_vert
    real <in> :: level

    this.u_quarter(:,:) = -999  ! Any negative. Note that
    this.v_quarter(:,:) = -999  ! QUATER_MM, MP, PM, PP are
                                ! all positive.

    call set_uv_edge_quarter( vert, val_vert, level, edge )
    call set_uv_edge_cross_coord( vert, val_vert, level, edge )
    call set_b_edge_quarter_and_cross_coord( vert, level, boundary.edge )

    call ut__assert( minval(this.u_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_u.quarter" )
    call ut__assert( minval(this.v_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_v.quarter" )
    call ut__assert( minval(boundary.edge.b_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_b.quarter" )
  end subroutine slice_mesh__edge_set_quarter  


  subroutine set_uv_edge_cross_coord( vert, val_vert, level, edge )
    type(slice_mesh__vert_t) <in> :: vert
    real, dimension(vert.nu,vert.nv) <in> :: val_vert
    real <in> :: level
    type(slice_mesh__edge_t) <io> :: edge
    !!> 
            .                                 .
              .       u2            u1      . 
              | .     |             |     . |
          ----p===.===m----     ----m===.===p----
              |   | . |             | . |   |
              u1  |   .             .   |   u2
                  |     .         .     |  
                  u=ui                  u=ui
    !!<
    real :: u_left, u_right
    real :: v_lower, v_upper
    real :: diff_left, diff_right
    real :: diff_lower, diff_upper
    integer :: ei, ej, quarter
    integer :: vi, vi_left,  vi_right
    integer :: vj, vj_lower, vj_upper


    edge.u_cross_coord(:,:) = NAN 
    edge.v_cross_coord(:,:) = NAN 
      !!> 
           To catch errornous cases in which a contour
           path tries to cross a non PM or MP edge.
      !!<

    ! edge_u
    do ej = 1, edge.u_nv
      do ei = 1, edge.u_nu
        vi_left  = ei
        vi_right = ei + 1
        vj = ej
        quarter = edge.u_quarter(ei,ej)
        if ( quarter == SLICE_MESH__EDGE_MP .or.  &
             quarter == SLICE_MESH__EDGE_PM ) then
          u_left  = vert.pos_u(vi_left)   ! left vert
          u_right = vert.pos_u(vi_right)  ! right vert
          diff_left  = val_vert(vi_left,vj) - level
          diff_right = level - val_vert(vi_right,vj)
          call ut__assert( diff_left * diff_right >= 0.0,   &
                           "__MODULE__(__LINE__): Not a PM/MP edge?" )
          ! The following linter interpol is valid both
          ! for diff_left > 0 and < 0 cases.
          edge.u_cross_coord(ei,ej) = linear_interpol( u_left,     &
                                                       u_right     &
                                                       diff_left,  &
                                                       diff_right )
        end if
      end do
    end do

    ! edge_v
    do ej = 1, this.v_nv
      do ei = 1, this.v_nu
        vi = ei
        vj_lower = ej
        vj_upper = ej + 1
        quarter = this.v_quarter(ei,ej)
        if ( quarter == SLICE_MESH__EDGE_MP  .or.  &
             quarter == SLICE_MESH__EDGE_PM ) then
          v_lower = mesh_vert.pos_v(vj_lower)  ! lower vert
          v_upper = mesh_vert.pos_v(vj_upper)  ! upper vert
          diff_lower = val_vert(vi,vj_lower) - level
          diff_upper = level - val_vert(vi,vj_upper)
          call ut__assert( diff_lower * diff_upper >= 0.0,   &
                           "__MODULE__(__LINE__): Not a PM/MP edge?" )
          this.v_cross_coord(ei,ej) = linear_interpol( v_lower,    &
                                                       v_upper,    &
                                                       diff_lower, &
                                                       diff_upper )
        end if
      end do
    end do    

  end subroutine set_uv_edge_cross_coord

end module slice_mesh_m
