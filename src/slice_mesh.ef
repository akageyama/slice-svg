!!>

    # Module slice_mesh

    ## Two kinds of grid mesh info; vert(ex) and edge

    ### Vertex


        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |


    ### Edge
                            v     __a                                 
        u edge_u            |   /         +----- u
        v edge_v            | /           | \
        a edge_ascend       +----- u      |   \   
        d edge_descend                    v     \ __d
                                    
            |     / | \     |     / | \     | 
            v   a   v   d   v   a   v   d   v
            | /     |     \ | /     |     \ |
           -+---u---+---u---+---u---+---u---+-
            | \     |     / | \     |     / |
            v   d   v   a   v   d   v   a   v
            |     \ | /     |     \ | /     |
           -+---u---+---u---+---u---+---u---+-
            |     / | \     |     / | \     | 
            v   a   v   d   v   a   v   d   v
            | /     |     \ | /     |     \ |


     ## Quarter integer for edge
     
       Each edge has one of four integers (0-3) for a given
       value of contour level.

          Take an edge V1-V2. 
                    V1--edge--V2  
          Denote "p" when V1 or V2 > level (of the contour),
          and "m" when V1 or V2 < level. For example, when
          V1 > level and V2 < level, 
                     p--edge--m
             There are four possibilities.

          Combination | quarter
          ------------+--------
             m - - m  |  0
             m - - p  |  1
             p - - m  |  2
             p - - p  |  3 (Special quarter for border edges)


     ## Border path

        When NU=9, NV=5, the common data assignment for
        each vertex is 

                5    b b b b b b b b b 
                4    b i i i i i i i b
                3    b i i i i i i i b
                2    b i i i i i i i b
                1    b b b b b b b b b 
                     
                     1 2 3 4 5 6 7 8 9

        where 'b' stands for the boundary data and
        'i' stands for the bulk data of the simulation.

        We define the border path, a closed line, by connecting 
        the consequtive 'b' points in the counter-clockwise direction.

                     <--- this way ---  
                                        \   
                5    * * * * * * * * *   \
                4    * . . . . . . . *    |  this way
                3    * . . . . . . . *    |   
                2    * . . . . . . . *    |  (counter-clockwise)
                1    * * * * * * * * *    |
                     
                     1 2 3 4 5 6 7 8 9


        The border path can have more complex shape than a rectangle,
        for example,

                     <--- this way ---  
                                        \   
                5    * * * * * * . . .   \
                4    * . . . . * * * *    |  this way
                3    * * * . . . . . *    |   
                2    . . * . . . . . *    |  (counter-clockwise)
                1    . . * * * * * * *    |
                     
                     1 2 3 4 5 6 7 8 9

        To denote a border path, we define border_list array that
        holds vertex position and direction of each edge of the 
        border path. N/E/S/W for North/East/South/West.
          
                     S W W W W W . . .   
                     S . . . . N W W W   
                     E E S . . . . . N   
                     . . S . . . . . N   
                     . . E E E E E E N   

     ## octa_direct

        We use octal integer (octa_direct) to indicate the direction.
           0 for North, 2 for East, 4 for South, and 6 for West.

                     4 6 6 6 6 6 . . .   
                     4 . . . . 0 6 6 6  
                     2 2 4 . . . . . 0   
                     . . 4 . . . . . 0   
                     . . 2 2 2 2 2 2 0   

                     
        To indicate inner or outer grid point of the bourder, 
        we use 'i' and 'o' characters.        

                     * * * * * * o o o
                     * i i i i * * * *   
                     * * * i i i i i *   
                     o o * i i i i i *   
                     o o * * * * * * *   

     ## Flag integer for vert
     
        

!!<

module slice_mesh_m
  use const_base_m
  use ut_m
  implicit none
  private
  public :: SLICE_MESH__EDGE_MM,  &
            SLICE_MESH__EDGE_PP,  &
            SLICE_MESH__EDGE_MP,  &
            SLICE_MESH__EDGE_PM

  integer <const> :: SLICE_MESH__EDGE_MM = 0  ! --m---m-- 
  integer <const> :: SLICE_MESH__EDGE_MP = 1  ! --m---p-- 
  integer <const> :: SLICE_MESH__EDGE_PM = 2  ! --p---m-- 
  integer <const> :: SLICE_MESH__EDGE_PP = 3  ! --p---p-- 

  type, public :: slice_mesh__vert_border_list_t
    integer :: num ! number of border vertex
    integer, dimension(:), allocatable :: octa_direct
    integer, dimension(:), allocatable :: vi  ! vert
    integer, dimension(:), allocatable :: vj
  contains
    procedure : initialize => slice_mesh__vert_border_list_init
  end type slice_mesh__vert_border_list_t

  type, public :: slice_mesh__vert_t

    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
    character, dimension(:,:), allocatable :: flag 
                       ! 'i' : inside the border
                       ! 'o' : outside the border
                       ! 'N' or '0' : border of path direct North
                       !        '1' : border of path direct Nourth-East
                       ! 'E' or '2' : border of path direct East
                       !        '3' : border of path direct South-Wast
                       ! 'S' or '4' : border of path direct South
                       !        '5' : border of path direct South-West
                       ! 'W' or '6' : border of path direct West
                       !        '7' : border of path direct Nourth-West
    type(slice_mesh__vert_border_list_t) :: border_list
  contains
    procedure, private :: slice_mesh__vert_initialize_with_grids
    procedure, private :: slice_mesh__vert_initialize_with_uvmaxmin
    generic :: initialize => slice_mesh__vert_initialize_with_grids,  &
                             slice_mesh__vert_initialize_without_grids
  end type slice_mesh__vert_t  


  type, public :: slice_mesh__edge_border_list_t
    integer :: num ! number of border vertex
    character, dimension(:), allocatable :: edge_type  ! 'u'/v/a/d
    integer, dimension(:), allocatable :: ei  ! edge index
    integer, dimension(:), allocatable :: ej
    integer, dimension(:), allocatable :: b_quarter   ! {0,1,2,3}
    real, dimension(:), allocatable :: u_cross_coord
    real, dimension(:), allocatable :: v_cross_coord
  contains
    procedure : initialize => slice_mesh__edge_border_list_init
  end type slice_mesh__edge_border_list_t

  type, public :: slice_mesh__edge_t

    integer :: u_nu, u_nv
    integer :: v_nu, v_nv

    integer, dimension(:,:), allocatable :: u_quarter   ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: v_quarter   ! {0,1,2,3}
    real, dimension(:,:), allocatable :: u_cross_coord
    real, dimension(:,:), allocatable :: v_cross_coord
    type(slice_mesh__edge_border_list_t) border_list
  contains
    procedure :: initialize => slice_mesh__edge_initialize
    procedure :: set_quarter => slice_mesh__edge_set_quarter
    procedure, private :: slice_mesh_edge__erase_uv_edge
    procedure, private :: slice_mesh_edge__erase_border_edge
    general :: erase => slice_mesh_edge__erase_uv_edge,       &
                        slice_mesh_edge__erase_border_edge
  end type slice_mesh__edge_t    


contains


  subroutine slice_mesh__vert_border_list_init( this, nu, nv, vert_flag )
    class(slice_mesh__vert_border_list_t) <out> :: this
    integer <in> :: nu, nv
    character, dimension(nu,nv) <in> :: vert_flag

    integer :: border_grid_num

    border_grid_num = iCount_border_grid( nu, nv, vert_flag )
    this.num = border_grid_num

    allocate(this.octa_direct(border_grid_num))
    allocate(         this.vi(border_grid_num))
    allocate(         this.vj(border_grid_num))

  contains

    function iCount_border_grid( nu, nv, vert_flag ) result(num)
      integer <in> :: nu, nv
      character, dimension(nu,nv) <in> :: vert_flag
      integer :: num

      integer :: i, j
      character :: flag

      num = 0
      do j = 1, nv
        do i = 1, nu
          flag = vert_flag(i,j)
          if ( flag == 'N' .or.  &
               flag == 'E' .or.  &
               flag == 'S' .or.  &
               flag == 'W' .or.  &
               flag == '0' .or.  &
               flag == '1' .or.  &
               flag == '2' .or.  &
               flag == '3' .or.  &
               flag == '4' .or.  &
               flag == '5' .or.  &
               flag == '6' .or.  &
               flag == '7' .or.  &
               flag == 'f' .or.  &
               flag == 'r' .or.  &
               flag == 'R' .or.  &
               flag == 'l' .or.  &
               flag == 'L' ) then
            num += 1
          end if
        end do
      end do
    end subroutine iCount_border_grid

  end subroutine slice_mesh__vert_border_list_init  


  function flag_to_octa_direct( flag ) result(octa_direct)
    character <in> :: flag
    integer :: anocta_direct

    select case (flag)
      case ('N')
        octa_direct = 0
      case ('E')
        octa_direct = 2
      case ('S')
        octa_direct = 4
      case ('W')
        octa_direct = 6
      case ('0')
        octa_direct = 0
      case ('1')
        octa_direct = 1
      case ('2')
        octa_direct = 2
      case ('3')
        octa_direct = 3
      case ('4')
        octa_direct = 4
      case ('5')
        octa_direct = 5
      case ('6')
        octa_direct = 6
      case ('7')
        octa_direct = 7 
      case default
        octa_direct = -1 ! any negative number
    end select

  end function flag_to_octa_direct


  subroutine get_next_octa_direct_and_vert( nu, nv,       &
                                            i, j,         &
                                            flag,         &
                                            octa_direct )
    integer <in> :: nu, nv
    integer <io> :: i, j
    character <in> :: flag       ! N/S/E/W/[0-7]/f/r/R/l/L
    integer <out> :: octa_direct ! 0 (North), 1 (North-East),
                                 ! 2 (East) , 3 (South-East), 
                                 ! 4 (South), 5 (South-West), 
                                 ! 6 (West),  7 (North-West)

    select case (flag)
      case ('N', 'E', 'S', 'W',  &
            '0', '1', '2', '3',  &
            '4', '5', '6', '7')
        octa_direct = flag_to_octa_direct( flag )
        call ut__assert( octa_direct >= 0 .and.  &
                         octa_direct <= 7,       &
                         "__MODULE__(__LINE__): case error." )
      case ('f')
       ! do nothing. keep the current octa_direct
      case ('r')
        octa_direct = mod(octa_direct+1,8)
      case ('R')
        octa_direct = mod(octa_direct+2,8)
      case ('l')
        octa_direct = mod(octa_direct+7,8)
      case ('L')
        octa_direct = mod(octa_direct+6,8)
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

    select case (octa_direct)
      case (0) ! North
        j += 1
      case (1) ! North-East
        i += 1
        j += 1
      case (2) ! East
        i += 1
      case (3) ! South-East
        i += 1
        j -= 1
      case (4) ! South
        j -= 1
      case (5) ! South-West
        i -= 1
        j -= 1
      case (6) ! West
        i -= 1
      case (7) ! North-West
        i -= 1
        j += 1
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

    call assert( next_i >= 1 .and. next_i <= nu,  &
                 "__MODULE__(__LINE__): i-range error." )
    call assert( next_j >= 1 .and. next_j <= nv,  &
                 "__MODULE__(__LINE__): j-range error." )
  end subroutine get_next_octa_direct_and_vert


  subroutine set_default_vert_flag( nu, nv, vert_flag )
    integer <in> :: nu, nv
    character, dimension(nu,nv) <out> :: vert_flag
    !!>
                  L W W W W W W W L 
                  S i i i i i i i N
                  S i i i i i i i N
                  S i i i i i i i N
                  L E E E E E E E L
    !!<
    vert_flag(2:nu-1,2:nv-1) = 'i'
    vert_flag(     1,     1) = 'L'
    vert_flag(2:nu-1,     1) = 'E'
    vert_flag(   nu,      1) = 'L'
    vert_flag(    nu,2:nv-1) = 'N'
    vert_flag(    nu,    nv) = 'L'
    vert_flag(2:nu-1,    nv) = 'W'
    vert_flag(     1,    nv) = 'L'
    vert_flag(     1,2:nv-1) = 'S'
  end subroutine set_default_vert_flag


  subroutine get_edge_id( vi, vj, octa_direct, ei, ej, edge_type )
    integer <in> :: vi, vj     ! id of vertex
    integer <in> :: octa_direct  ! from 0 (north) to 7 (north-west)
    integer <out> :: ei, ej    ! id of edge
    character :: edge_type ! 'u' / 'v' / 'a' / 'd'
    !!>
                   edge_u(ei,ej)            edge_v(ei,ej)
       (vi,vj+1)--> + - - - +                + - - - +
                    |       |                v       | \__ (vi+1,vj+1)
                    |       |                v       |
                    |       |                v       |
        (vi,vj) --> + u u u +    (vi,vj) --> + - - - +
                           /          
                     (vi+1,vj)   


                   edge_a(ei,ej)            edge_d(ei,ej)
       (vi,vj+1)--> + - - - a                + - - - +
                    |     a |                | d     |
                    |   a   |                |   d   |
                    | a     |                |     d |
        (vi,vj) --> + - - - +    (vi,vj) --> + - - - +
    !!<

    select case (octa_direct)
      case (0) 
        ei = vi             !    *
        ej = vj             !    *
        edge_type = 'v'     !    * . . .
      case (1)
        ei = vi             !    .   * 
        ej = vj             !    . *
        edge_type = 'a'     !    * . . .
      case (2)
        ei = vi             !    .
        ej = vj             !    .
        edge_type = 'u'     !    * * * *
      case (3)
        ei = vi             !    * . . .
        ej = vj - 1         !    . *
        edge_type = 'd'     !    .   *
      case (4) 
        ei = vi             !    * . . .
        ej = vj - 1         !    *
        edge_type = 'v'     !    *
      case (5) 
        ei = vi - 1         !    . . . *
        ej = vj - 1         !        * .
        edge_type = 'a'     !      *   .
      case (6) 
        ei = vi - 1         !          .
        ej = vj             !          .
        edge_type = 'u'     !    * * * *
      case (7) 
        ei = vi - 1         !      *   .
        ej = vj + 1         !        * .
        edge_type = 'd'     !    . . . *
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

  end function get_edge_id


  subroutine set_b_edge_quarter_and_cross_point( vert,             &
                                                 eblist, &
                                                 level )
    type(slice_mesh__vert_t) <io> :: vert
    type(slice_mesh__edge_border_list_t) <out> :: eblist
    real <in> :: level

    !!>
        注意。b_edge (border edge)における4値（quarter）の定義は
        u_edge や v_edge と異なる。 たとえば u_edge の場合、
            val(vi,vj) - level > 0 .and. val(vi+1,vj) - level < 0
        のとき
            quarter(ei,ej) = PM
        としていた。vi=ei, vj=ej の場合、つまり現在注目している頂点 {i,j} が
        このu_edgeの左端である場合は特に問題ない。自分が M で右隣がPである。

          自分 {i,j}    {i+1,j}
              \         /
              P - - - M
        
        だが、vi=ei+1, vj=ej つまりこのu_edgeの右端に注目している
        頂点 {i,j} がある場合は、おなじ
            quarter(ei,ej) = PM
        の値は、自分 {i,j} が P で左隣の頂点が M である。

          {i-1,j}     自分 {i,j}
              \         /
              P - - - M
        つまりこの場合は PM を右から左に読む必要がある。

        一方、b_edgeの場合は、u-, v-, a-, d-方向のいずれも常に左から右に読む。
        たとえば、num番目の境界点の座標が (vi,vj)=(10,NV) だとすると、
            u_quarter(10,NV) = MP
        のとき
            b_quarter(num) = PM
        である。

        d_edgeの場合も、

                  + - - - - M
                  |       d |
                  |    d    |
                  | d       |
                  P - - - - +
                    \
                  自分 {i,j}

        左斜め上に行く次のような場合も、

                  M - - - - M
                  | d       |
                  |    d    |
                  |       d |
                  + - - - - P
                              \
                              自分 {i,j}
        どちらも d_edge = PM とする。
        
    !!<
    integer :: b, vi, vj, ei, ej, vi2, vj2
    ! integer :: odir, etype
    real :: val1, u1, v1
    real :: val2, u2, v2
    integer :: quarter

    eblist.u_cross_coord(:) = NAN
    eblist.v_cross_coord(:) = NAN

    do b = 1, vert.border_list.num
      vi = vert.border_list.vi(b)
      vj = vert.border_list.vj(b)

      val1 = val_vert(vi,vj)
      u1 = vert.pos_u(vi)
      v1 = vert.pos_v(vj)

      if ( b < vert.border_list.num ) then
        vi2 = vert.border_list.vi(b+1)
        vj2 = vert.border_list.vj(b+1)
      else 
        vi2 = vert.border_list.vi(1)
        vj2 = vert.border_list.vj(1)
      end if

      val2 = val_vert(vi2,vj2)
      u2 = vert.pos_u(vi2)
      v2 = vert.pos_v(vj2)

      quarter = quarter_of_edge_ends( val1, val2, level )
      eblist.b_quarter(b) = quarter

      if ( quarter == SLICE_MESH__EDGE_MP  .or.  &
           quarter == SLICE_MESH__EDGE_PM ) then
        diff1 = val1 - level
        diff2 = level - val2
        eblist.u_cross_coord(b) = linear_interpol( u1, u2, diff1, diff2 )
        eblist.v_cross_coord(b) = linear_interpol( v1, v2, diff1, diff2 )
      end if
    end do    

  end subroutine set_b_edge_quarter_and_cross_point


  subroutine make_border_list( vert, edge )

    type(slice_mesh__vert_t) <io> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: vi, vj, start_vi, start_vj
    integer :: num_of_border_vert
    integer :: counter

    num_of_border_vert = vert.border_list.num

    call iFind_a_border_vert_with_octa_direct( nu, nv,        &
                                               vert_flag,     &
                                               vi, vj,        &
                                               octa_direct )

    start_vi = vi
    start_vj = vj
    counter = 1
    vert.border_list.octa_direct(counter) = octa_direct
    vert.border_list.vi(counter) = vi
    vert.border_list.vj(counter) = vj

    call get_edge_id( i, j, octa_direct, ei, ej, edge_type )
    
    edge.border_list.ei(counter) = ei
    edge.border_list.ej(counter) = ej
    edge.border_list.edge_type(counter) = edge_type

    do counter = 2, num_of_border_grid 
      call get_next_octa_direct_and_vert( nu, nv,           &
                                          i, j,             &
                                          vert_flag(i,j),   &
                                          octa_direct )
      if ( i == head_i .and. j == head_j ) then
        ! have come back to the start point
        return
      end if
      counter += 1
      edge.border_list.octa_direct(counter) = octa_direct
      vert.border_list.vi(counter) = i
      vert.border_list.vj(counter) = j
      call get_edge_id( i, j, octa_direct, ei, ej, edge_type )
      edge.border_list.ei(counter) = ei
      edge.border_list.ej(counter) = ej
      edge.border_list.edge_type(counter) = edge_type
    end do

    call ut__fatal( "__MODULE__(__LINE__): Failed to close border." )
  
  contains

    subroutine iFind_a_border_vert_with_octa_direct( nu, nv,           &
                                                     vert_flag,        &
                                                     head_i, head_j,   &
                                                     head_octa_direct )
      integer <in> :: nu, nv
      character, dimension(nu,nv) <in> :: vert_flag
      integer <out> :: head_i, head_j
      integer <out> :: head_octa_direct

      integer :: i, j
      character :: flag

      do j = 1, nv
        do i = 1, nu
          flag = vert_flag(i,j)
          octa_direct = flag_to_octa_direct( flag )
          if ( octa_direct > 0 ) then
            head_i = i
            head_j = j
            head_octa_direct = octa_direct
            return
          end if
        end do
      end do

      call ut__fatal( "__MODULE__(__LINE__): " //  &
                      "Failed to find a start point on border." )
    end subroutine iFind_a_border_vert_with_octa_direct

  end subroutine make_border_list


  function linear_interpol( x1, x2, diff1, diff2 ) result( xi )
    real <in> :: x1, x2, diff1, diff2
    real :: xi
    !!>   
        Diff1 and diff2 can be negative but they 
        must have the same sign.

         \
          \ - - - - - - - - -  val(x1)
          .\                 |
          . \      x=x2      | diff1 > 0.0
          .  \     |         |
      ----o===+====o-------------- level 
          |   .\   .         |
       x=x1   . \  .         | diff2 > 0.0
              .  \ .         |
              .   \ - - - - -  val(x2)
            x=xi   \

    !!<
    real :: weight1, weight2

    call ut__assert( x1 < x2,  &
                     "__MODULE__(__LINE__): Bad grids order." )
    call ut__assert( diff1*diff2 >= 0.0,  &
                     "__MODULE__(__LINE__): Cannot interpolate." )

    if ( diff1+diff2 == 0.0  ) then
      ! which means diff1 = 0.0 & diff2 = 0.0
      xi = (x1+x2)/2 ! Take the middle point
                     ! I'm not very sure if this is OK.
    else
      ! The following applies in either cases of
      !  (1) diff1 > 0 & diff2 > 0
      !  (2) diff1 < 0 & diff2 < 0
      weight1 = diff2 / (diff1 + diff2)
      weight2 = 1.0 - weight1
      xi = weight1 * x1 + weight2 * x2
      call ut__assert( xi >= x1 .and. xi <= x2,  &
                       "__MODULE__(__LINE__): Weight is out of range." )
    end if
  end function linear_interpol


  function quarter_of_edge_ends( v1, v2, val ) result(ans)
    if ( v1 < level .and. v2 < level ) then
      ans = SLICE_MESH__EDGE_MM
    else if ( v1 > level .and. v2 > level ) then
      ans = SLICE_MESH__EDGE_PP
    else if ( v1 >= level .and. v2 < level ) then          
      ans = SLICE_MESH__EDGE_PM
    else if ( v1 < level .and. v2 >= level ) then
      ans = SLICE_MESH__EDGE_MP  
    else
      call ut__fatal( "__MODULE__(__LINE__): " //  &
                      "case error." )
    end if
  end function quarter_of_edge_ends


  subroutine slice_mesh_edge__erase_uv_edge( this, which_edge, ei, ej )
    class(slice_mesh__edge_t) <io> :: this
    char(len=1) <in> :: which_edge
    integer <in> :: ei, ej
    
    if ( which_edge == 'u' ) then
      this.u_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else if ( which_edge == 'v' ) then
      this.v_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else 
      call ut__fatal( '__MODULE__(__LINE__): argument error.' )
    end if
  end subroutine slice_mesh_edge__erase_uv_edge


  subroutine slice_mesh_edge__erase_d_edge( this, vert, nth )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    integer <in> :: nth

    call ut__assert( nth >= 1 .and.                     &
                     nth <= vert.dborder_list.num,  &
                     "__MODULE__(__LINE__): " //        &
                     "over the range." )
    this.d_quarter(nth) = SLICE_MESH__EDGE_MM
  end subroutine slice_mesh_edge__erase_d_edge


  subroutine slice_mesh__vert_initialize_with_grids( this,          &
                                                     nu, nv,        &
                                                     grid_pos_u,    &
                                                     grid_pos_v,    &
                                                     vert_flag )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real, dimension(nu) <in> :: grid_pos_u
    real, dimension(nv) <in> :: grid_pos_v
    character, dimension(nu,nv) <optin> :: vert_flag
                       ! 'i' : inside the border
                       ! 'o' : outside the border
                       ! 'N' or '0' : border of path direct North
                       !        '1' : border of path direct Nourth-East
                       ! 'E' or '2' : border of path direct East
                       !        '3' : border of path direct South-Wast
                       ! 'S' or '4' : border of path direct South
                       !        '5' : border of path direct South-West
                       ! 'W' or '6' : border of path direct West
                       !        '7' : border of path direct Nourth-West
    !!>
        case 1  境界上の値がカドの点も含めて設定されている場合

                  b b b b b b b b b 
                  b i i i i i i i b
                  b i i i i i i i b
                  b i i i i i i i b
                  b b b b b b b b b 

        case 2  境界上のカドの点には値が設定されていない場合

            カドの点はo (outer)点とする。全ての境界格子点を一周、反時計回りに
            回る。次の格子点が水平あるいは垂直方向にある場合は、b (border) 点とする。
            次の境界格子点が斜め方向にある場合は、それをd (diagonal) 点とする。
            シミュレーション領域の内部は i (inner) 点とする。
                        <--- 
                  o d b b b b b b o
              |   b i i i i i i i d  ^
              |   b i i i i i i i b  |
              v   d i i i i i i i b  |
                  o b b b b b b d o 
                        --->

        case 3a  境界が長方形でなく、d点が存在しない場合
        
                  o o o b b b b b o
                  b b b b i i i b o
                  b i i i i i i b o
                  b b b b i i i b o
                  o o o b b b b b o
        

        case 3b  境界が長方形でなく、d点が存在する場合

                  o o o o d o o o o
                  o o o d i d o o o
                  o o d i i i d o o
                  o d i i i i b o o
                  o o b b b b b o o
    !!<
    real :: u_min, u_max
    real :: v_min, v_max
    integer :: max_num_border_verts

    u_min = grid_pos_u(1)
    u_max = grid_pos_u(nu)
    v_min = grid_pos_v(1)
    v_max = grid_pos_v(nv)

    call ut__assert( u_max > u_min,       &
                    '__MODULE__(__LINE__): Invalid coords u.' )
    call ut__assert( v_max > v_min,       &
                    '__MODULE__(__LINE__): Invalid coords v.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))
    allocate(this.flag(nu,nv))

    this.pos_u(:) = grid_pos_u(:)
    this.pos_v(:) = grid_pos_v(:)
    this.flag(:,:) = vert_flag(:,:)

    if ( present(vert_flag) ) then
      this.flag(:,:) = vert_flag(:,:)
    else
      call set_default_vert_flag( nu, nv, this.flag )      
    end if

    call this.border_list.initialize( nu, nv, this.flag )

  end subroutine slice_mesh__vert_initialize_with_grids


  subroutine slice_mesh__vert_initialize_without_grids( this, nu, nv,  &
                                                        u_min, u_max,  &
                                                        v_min, v_max )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max

    real :: du, dv
    integer :: i, j
    integer :: max_num_border_verts

    call ut__assert( (nu > 1) .and.         &
                     (nv > 1) .and.         &
                     (u_max > u_min) .and.  &
                     (v_max > v_min),       &
                    '__MODULE__(__LINE__): Invalid arguments.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))
    allocate(this.flag(nu,nv))

    du = ( u_max - u_min ) / (nu-1)
    dv = ( v_max - v_min ) / (nv-1)

    do i = 1, nu
      this.pos_u(i) = u_min + du*(i-1)
    end do

    do j = 1, nv
      this.pos_v(j) = v_min + dv*(j-1)
    end do

    call set_default_grid_type( nu, nv, this.flag )

    call this.border_list.initialize( nu, nv, this.flag )
  
  end subroutine slice_mesh__vert_initialize_without_grids


  subroutine slice_mesh__edge_initialize( this,  &
                                          vert )
    class(slice_mesh__edge_t) <out> :: this
    type(slice_mesh__vert_t) <io> :: vert
    !!>
                            edgev                                    
                              |
                              |
                              +---- edgeu

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
    !!<
  
    integer :: u_nu, u_nv, v_nu, v_nv

    u_nu = vert.nu - 1
    u_nv = vert.nv
    v_nu = vert.nu
    v_nv = vert.nv - 1

    this.u_nu = u_nu
    this.u_nv = u_nv
    this.v_nu = v_nu
    this.v_nv = v_nv

    allocate(this.u_quarter(u_nu,u_nv))
    allocate(this.v_quarter(v_nu,v_nv))
    allocate(this.u_cross_coord(u_nu,u_nv))
    allocate(this.v_cross_coord(v_nu,v_nv))

    call this.border_list.initialize( vert.border.num )

    call make_border_list( vert, this )    

  contains

    subroutine iBorder_set
      integer :: u_nu_, u_nv_, v_nu_, v_nv_

      this.is_border_u(:,:) = .false.  ! default bulk edges
      this.is_border_v(:,:) = .false.

      if ( present(is_border_v) ) then
        call ut__assert( present(is_border_u),              &
                         "__MODULE__(__LINE__): "           &
                         // "Needs both border_u and _v." )
        u_nu_ = size(is_border_u,dim=1)
        u_nv_ = size(is_border_u,dim=2)
        v_nu_ = size(is_border_v,dim=1)
        v_nv_ = size(is_border_v,dim=2)
        call ut__assert( u_nu_ == this.u_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of border_u and mesh_edge." )
        call ut__assert( u_nv_ == this.u_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of border_u and mesh_edge." )
        call ut__assert( v_nu_ == this.v_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of border_u and mesh_edge." )
        call ut__assert( v_nv_ == this.v_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of border_v and mesh_edge." )
        this.is_border_u(:,:) = is_border_u(:,:)
        this.is_border_v(:,:) = is_border_v(:,:)
      else 
        ! the case of usual (rectangular) border
        this.is_border_u(:,        1) = .true. ! south bourder
        this.is_border_u(:,this.u_nv) = .true. ! north bourder
        this.is_border_v(        1,:) = .true. ! west bourder
        this.is_border_v(this.v_nu,:) = .true. ! east bourder
      end if
    end subroutine iBorder_set

  end subroutine slice_mesh__edge_initialize


  subroutine slice_mesh__edge_border_list_init( this, vert_border_num )
    class(slice_mesh__edge_border_list_init_t) <out> :: this
    integer <in> :: vert_border_num

    allocate(    this.edge_type(vert_border_num))
    allocate(           this.ei(vert_border_num))
    allocate(           this.ej(vert_border_num))
    allocate(    this.b_quarter(vert_border_num))
    allocate(this.u_cross_coord(vert_border_num))
    allocate(this.v_cross_coord(vert_border_num))
  end subroutine slice_mesh__edge_border_list_init


  function edge_level_check_set_u_quarter( edge_u_nu,  &
                                           edge_u_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(u_quarter) 

    integer <in> :: edge_u_nu, edge_u_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_u_nu,edge_u_nv)  :: u_quarter
    !!>
        Here we compare the scalar field value "vert_val" 
        on each vertex at (i,j) 

                  val_vert(i,j)

        with "level" of the target contour. The comparison
        is applied through edges. 

        There are two kinds of edges, vertical edges (edgve_v)
        and horizontal edges (edge_u).

                         v ("vertical")
                         |
                         |
                         +----- u ("horizontal")

              edge_u
            o--------o
            |        |
     edge_v |        | edge_v
            |        |
            o--------o
              edge_u

        Every edge is labeled by a pair of indeces
        in u and v directions, (ei,ej), while every
        vertex is also labeled by a pair of indeces.

        The two kinds of indexes are related by the
        following figure.

                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)

        Now we denote a vertex binary label
        p (plus) or m (minus); "p" when
                  val_vert(i,j) > level,
        and "m" when 
                  val_vert(i,j) < level.

        And we assign a quarter (four) label
        for every edge as

              Edge    | quarter
          ------------+--------
             m----m   |  0
             m----p   |  1
             p----m   |  2
             p----p   |  3

        For example,
                    MM
                m--------m
                |        |
             PM |        | MM
                |        |
                p--------m
                    PM

        =====
              Case MM

                The path does not cross this edge.
                         ei   ei+1
                          |    |      .      
                      ----M====M---.---- level
                          |    |._______ val_vert(ei+1,ej)
                          |  . |
                          .----|-------- val_vert(ei,ej)
                       .  |    |

              Case PP

                The path does not cross this edge.
                But special care would be taken when
                this edge is on the border (ej=1 or u_nv).
                          .
                          |    . 
                      ----P====P----.------ level
                         ei   ei+1       .

              Case PM

                The path goes through the edge.
                     .
                       .       u2
                       | .     |
                   ----p===.===m----
                       |   | . |
                      u1   |   .
                           |     .
                          u=ui

              Case MP

                The path goes through the edge, too.
                                 .
                       u1      . 
                       |     . |
                   ----m===.===p----
                       | . |   |
                       .   |   u2
                     .     |     
                          u=ui
        =====
    !!<

    integer :: ei, ej  ! edge indexes. They 
                       ! are simply converted
                       ! to vertex indexes
    real :: val1, val2

    ! edge_u
    do ej = 1, edge_u_nv  
      do ei = 1, edge_u_nu
        val1 = val_vert(ei,  ej)
        val2 = val_vert(ei+1,ej)
        u_quarter(ei,ej) = quarter_of_edge_ends( val1, val2, level )
      end do
    end do
  end function edge_level_check_set_u_quarter


  function edge_level_check_set_v_quarter( edge_v_nu,  &
                                           edge_v_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(v_quarter)

    integer <in> :: edge_v_nu, edge_v_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_v_nu,edge_v_nv) :: v_quarter

    !!>
        See comments in "edge_level_check_set_u_quarter".
    !!<

    integer :: ei, ej  ! edge indexes
    real :: val1, val2

    do ej = 1, edge_v_nv  
      do ei = 1, edge_v_nu
        val1 = val_vert(ei,ej  )
        val2 = val_vert(ei,ej+1)
        u_quarter(ei,ej) = quarter_of_edge_ends( val1, val2, level )
      end do
    end do

  end function edge_level_check_set_v_quarter  


  subroutine slice_mesh__edge_set_quarter( this,       &
                                           vert,       &
                                           val_vert,   &
                                           level )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    real, dimension(vert.nu,vert.nv) <in> :: val_vert
    real <in> :: level

    this.u_quarter(:,:) = -999  ! Any negative. Used later to
    this.v_quarter(:,:) = -999  ! check if all edges are set,
                                ! using ...QUATER_MM, MP, PM, 
                                ! PP are all non-negative.
    this.u_cross_coord(:,:) = NAN ! Reset
    this.v_cross_coord(:,:) = NAN

    this.u_quarter = edge_level_check_set_u_quarter(      &
                                         this.u_nu,       &
                                         this.u_nv,       &
                                         vert.nu,         &
                                         vert.nv,         &
                                         val_vert,        &
                                         level )

    this.v_quarter = edge_level_check_set_v_quarter(      &
                                         this.v_nu,       &
                                         this.v_nv,       &
                                         vert.nu,         &
                                         vert.nv,         &
                                         val_vert,        &
                                         level )

    call iInterpol_cross_point_edge_u
    call iInterpol_cross_point_edge_v

    ! call ut__assert( minval(this.u_quarter) >= 0,  &
    !                  "__MODULE__(__LINE__): You missed some edge_u." )
    ! call ut__assert( minval(this.v_quarter) >= 0,  &
    !                  "__MODULE__(__LINE__): You missed some edge_v." )

    call set_b_edge_quarter_and_cross_point( vert, this, level )

  contains

    subroutine iInterpol_cross_point_edge_u
      real :: u1, u2, diff1, diff2
      integer :: ei, ej, quarter
      !!> 
              .                                 .
                .       u2            u1      . 
                | .     |             |     . |
            ----p===.===m----     ----m===.===p----
                |   | . |             | . |   |
               u1   |   .             .   |   u2
                    |     .         .     |  
                   u=ui                  u=ui
      !!<

      do ej = 1, this.u_nv
        do ei = 1, this.u_nu
          quarter = this.u_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_vert.pos_u(ei+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei+1,ej)
            this.u_cross_coord(ei,ej) = linear_interpol( u1, u2, diff1, diff2 )
              ! For both MP and PM cases.
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_u

    subroutine iInterpol_cross_point_edge_v
      real :: v1, v2, diff1, diff2
      integer :: ei, ej, quarter
      ! edge_v
      do ej = 1, this.v_nv
        do ei = 1, this.v_nu
          quarter = this.v_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            v1 = mesh_vert.pos_v(ej)
            v2 = mesh_vert.pos_v(ej+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei,ej+1)
            this.v_cross_coord(ei,ej) = linear_interpol( v1, v2, diff1, diff2 )
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_v    

  end subroutine slice_mesh__edge_set_quarter  

end module slice_mesh_m
