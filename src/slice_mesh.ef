module slice_mesh_m
  use const_base_m
  use ut_m
  implicit none
  private
  public :: SLICE_MESH__EDGE_MM,  &
            SLICE_MESH__EDGE_PP,  &
            SLICE_MESH__EDGE_MP,  &
            SLICE_MESH__EDGE_PM

  integer <const> :: SLICE_MESH__EDGE_MM = 0  ! --m===m-- 
  integer <const> :: SLICE_MESH__EDGE_MP = 1  ! --m===p-- 
  integer <const> :: SLICE_MESH__EDGE_PM = 2  ! --p===m-- 
  integer <const> :: SLICE_MESH__EDGE_PP = 3  ! --p===p-- 
    !!>
        When you change values of SLICE_MESH__EDGE_*,
        note that their positiveness is assumed in some checks.
    !!<

  type, public :: slice_mesh__vert_t
    !!>  
        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
    !!< 
    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
    char(len=1), dimension(:,:), allocatable :: border_turn
  contains
    procedure :: initialize => slice_mesh__vert_initialize
    procedure :: finalize => slice_mesh__vert_finalize
  end type slice_mesh__vert_t  

  type, public :: slice_mesh__edge_t
    !!>                            
                                 edge_v                                    
                                    |
        v: vertex                   |
        e: edge_u or edge_v         +---- edge_u
                                    
            e       e       e       e       e
            e       e       e       e       e    
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
            e       e       e       e       e    
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
            e       e       e       e       e    
            e       e       e       e       e
    !!< 
    integer :: u_nu, u_nv
    integer :: v_nu, v_nv
    integer, dimension(:,:), allocatable :: u_quarter   ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: v_quarter   ! {0,1,2,3}
    logical, dimension(:,:), allocatable :: is_border_u ! T for border edges
    logical, dimension(:,:), allocatable :: is_border_v ! T for border edges
      !!>
          Take an edge V1-V2. 
                    V1--edge--V2  
          Denote "p" when V1 or V2 > level (of the contour),
          and "m" when V1 or V2 < level. For example, when
          V1 > level and V2 < level, 
                     p--edge--m
             There are four possibilities.

          Combination | quarter
          ------------+--------
             m - - m  |  0
             m - - p  |  1
             p - - m  |  2
             p - - p  |  3 (Special quarter for border edges)
      !!<
    real, dimension(:,:), allocatable :: u_cross_coord
    real, dimension(:,:), allocatable :: v_cross_coord
                                            
  contains
    procedure :: initialize => slice_mesh__edge_initialize
    procedure :: finalize => slice_mesh__edge_finalize
    procedure :: set_quarter => slice_mesh__edge_set_quarter
    procedure :: erase => slice_mesh_edge__erase
  end type slice_mesh__edge_t    


contains


  function linear_interpol( x1, x2, diff1, diff2 ) result( xi )
    real <in> :: x1, x2, diff1, diff2
    real :: xi
    !!>   
        Diff1 and diff2 can be negative but they 
        must have the same sign.

         \
          \ - - - - - - - - -  val(x1)
          .\                 |
          . \      x=x2      | diff1 > 0.0
          .  \     |         |
      ----o===+====o-------------- level 
          |   .\   .         |
       x=x1   . \  .         | diff2 > 0.0
              .  \ .         |
              .   \ - - - - -  val(x2)
            x=xi   \

    !!<
    real :: weight1, weight2

    call ut__assert( x1 < x2,  &
                     "__MODULE__(__LINE__): Bad grids order." )
    call ut__assert( diff1*diff2 >= 0.0,  &
                     "__MODULE__(__LINE__): Cannot interpolate." )

    if ( diff1+diff2 == 0.0  ) then
      ! which means diff1 = 0.0 & diff2 = 0.0
      xi = (x1+x2)/2 ! Take the middle point
                     ! I'm not very sure if this is OK.
    else
      ! The following applies in either cases of
      !  (1) diff1 > 0 & diff2 > 0
      !  (2) diff1 < 0 & diff2 < 0
      weight1 = diff2 / (diff1 + diff2)
      weight2 = 1.0 - weight1
      xi = weight1 * x1 + weight2 * x2
      call ut__assert( xi >= x1 .and. xi <= x2,  &
                       "__MODULE__(__LINE__): Weight is out of range." )
    end if
  end function linear_interpol


  subroutine slice_mesh_edge__erase( this, which_edge, ei, ej )
    class(slice_mesh__edge_t) <io> :: this
    char(len=1) <in> :: which_edge
    integer <in> :: ei, ej
    
    if ( which_edge == 'u' ) then
      this.u_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else if ( which_edge == 'v' ) then
      this.v_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else 
      call ut__fatal( '__MODULE__(__LINE__): argument error.' )
    end if
  end subroutine slice_mesh_edge__erase  


  subroutine slice_mesh__vert_initialize( this, nu, nv,  &
                                          u_min, u_max,  &
                                          v_min, v_max )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max

    real :: du, dv
    integer :: i, j

    call ut__assert( (nu > 1) .and.         &
                     (nv > 1) .and.         &
                     (u_max > u_min) .and.  &
                     (v_max > v_min),       &
                    '__MODULE__(__LINE__): Invalid arguments.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))
    allocate(this.border_turn(nu,nv))
    this.border_turn(:,:) = ' ' ! default.

    du = ( u_max - u_min ) / (nu-1)
    dv = ( v_max - v_min ) / (nv-1)

    do i = 1, nu
      this.pos_u(i) = u_min + du*(i-1)
    end do

    do j = 1, nv
      this.pos_v(j) = v_min + dv*(j-1)
    end do
  end subroutine slice_mesh__vert_initialize


  subroutine set_turn_direct_on_vert_on_border_turn( vert,  &
                                                     edge )
    type(slice_mesh__vert_t) <io> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: vi, vj  ! v stands for vertex
    integer :: vi_start, vj_start 
    char(len=1) :: current_dir
    integer :: safety_counter
    integer, dimension(4) :: check

    ! already set. ! vert.border_turn(:,:) = ' ' ! default 

    call iFind_a_border_u_edge( vi, vj )

    !          edge_u(i,j)
    !         /
    !    o - - - o
    !     \       \
    !      v(i,j)  v(i+1,j)

    current_dir = 'E'
    vi_start = vi
    vj_start = vj
    vi += 1  ! go eastward

    safety_counter = 0
    do while (vi /= vi_start .or. vj /= vj_start)  
      safety_counter += 1  
      check(1) = iCheck_north( current_dir, vi, vj )
      check(2) = iCheck_south( current_dir, vi, vj )
      check(3) = iCheck_east( current_dir, vi, vj )
      check(4) = iCheck_west( current_dir, vi, vj )

      select case (sum(check(1:4)))
        case (2:3)
          call ut__fatal( "__MODULE__(__LINE__): " //  &
                          "Three- or four-way intersection." )
        case (0)
          call ut__fatal( "__MODULE__(__LINE__): " //  &
                          "Deadend." )
        case (1)
          call iGo_one_step_set_border_turn( current_dir, vi, vj, check )
        case default
          call ut__fatal( "__MODULE__(__LINE__): " //  &
                          "Strange checksum." )
      end select

      if ( safety_counter > ( edge.u_nu*edge.u_nv  &
                            + edge.v_nu*edge.v_nv ) ) then
        call ut__fatal( "__MODULE__(__LINE__): " //  &
                        "Failed to close the border." )
      end if
    end do

  contains
    
    subroutine iFind_a_border_u_edge( vi, vj )
      integer <out> :: vi, vj

      integer :: i, j
      do j = 1, edge.u_nv
        do i = 1, edge.u_nu
          if ( edge.is_border_u(i,j) ) then
            ! Have found a border u-edge.
            vi = i
            vj = j
            return
          end if
        end do
      end do
      call ut__fatal( "__MODULE__(__LINE__): " // &
                      "Failed to find a border_u edge." )
    end subroutine iFind_a_border_u_edge

    function iCheck_north( current_dir, vi, vj ) result(ans)
      char(len=1) <in> :: current_dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( current_dir == 'S' ) return ! You came from there.
      if ( vj == vert.nv ) return ! there is no north v-edge
      if ( edge.is_border_v(vi,vj) ) ans = 1
    end function iCheck_north

    function iCheck_south( current_dir, vi, vj ) result(ans)
      char(len=1) <in> :: current_dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( current_dir == 'N' ) return ! You came from there.
      if ( vj == 1 ) return ! there is no south v-edge
      if ( edge.is_border_v(vi,vj-1) ) ans = 1
    end function iCheck_south

    function iCheck_east( current_dir, vi, vj ) result(ans)
      char(len=1) <in> :: current_dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( current_dir == 'W' ) return ! You came from there.
      if ( vi == vert.nu ) return ! there is no east v-edge
      if ( edge.is_border_u(vi,vj) ) ans = 1
    end function iCheck_east    

    function iCheck_west( current_dir, vi, vj ) result(ans)
      char(len=1) <in> :: current_dir
      integer <in> :: vi, vj
      integer :: ans

      ans = 0 ! default
      if ( current_dir == 'E' ) return ! You came from there.
      if ( vi == 1 ) return ! there is no west v-edge
      if ( edge.is_border_u(vi-1,vj) ) ans = 1
    end function iCheck_west      

    subroutine iGo_one_step_set_border_turn( current_dir, vi, vj, check )
      char(len=1) <io> :: current_dir
      integer <io> :: vi, vj
      integer, dimension(4) <in> :: check

      if ( check(1) == 1 ) then
        if ( current_dir /= 'N' ) vert.border_turn(vi,vj) = 'N'
          !!>
                                    ^ Will go northward
                                    |
             current_dir='E' ====> 'N' - - -
                 (Came eastward)    |
          !!<
        current_dir = 'N'
        vj += 1
      else if ( check(2) == 1 ) then
        if ( current_dir /= 'S' ) vert.border_turn(vi,vj) = 'S'
        current_dir = 'S'
        vj -= 1
      else if ( check(3) == 1 ) then
        if ( current_dir /= 'E' ) vert.border_turn(vi,vj) = 'E'
        current_dir = 'E'
        vi += 1
      else if ( check(4) == 1 ) then
        if ( current_dir /= 'W' ) vert.border_turn(vi,vj) = 'W'
        current_dir = 'W'
        vi -= 1
      else 
        call ut__fatal( "__MODULE__(__LINE__): "  // &
                        "Strange value of check(:)." )
      end if
    end subroutine iGo_one_step_set_border_turn
    
  end subroutine set_turn_direct_on_vert_on_border_turn


  subroutine slice_mesh__vert_finalize( this )
    class(slice_mesh__vert_t) <io> :: this

    deallocate(this.pos_u)
    deallocate(this.pos_v)
  end subroutine slice_mesh__vert_finalize


  subroutine slice_mesh__edge_initialize( this,         &
                                          mesh_vert,    &
                                          is_border_u,  &
                                          is_border_v )
    class(slice_mesh__edge_t) <out> :: this
    class(slice_mesh__vert_t) <io> :: mesh_vert
    logical, dimension(:,:) <optin> :: is_border_u
    logical, dimension(:,:) <optin> :: is_border_v
    !!>
                            edgev                                    
                              |
                              |
                              +---- edgeu

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
    !!<
    this.u_nu = mesh_vert.nu - 1
    this.u_nv = mesh_vert.nv
    this.v_nu = mesh_vert.nu
    this.v_nv = mesh_vert.nv - 1
    allocate(this.u_cross_coord(this.u_nu,  &
                                this.u_nv))
    allocate(this.v_cross_coord(this.v_nu,  &
                                this.v_nv))
    allocate(this.u_quarter(this.u_nu,  &
                            this.u_nv))
    allocate(this.v_quarter(this.v_nu,  &
                            this.v_nv))
    allocate(this.is_border_u(this.v_nu,  &
                              this.v_nv))
    allocate(this.is_border_v(this.v_nu,  &
                              this.v_nv))

    call iBorder_set

    call set_turn_direct_on_vert_on_border_turn( mesh_vert, &
                                                 this )
  
  contains

    subroutine iBorder_set
      integer :: u_nu_, u_nv_, v_nu_, v_nv_

      this.is_border_u(:,:) = .false.  ! default bulk edges
      this.is_border_v(:,:) = .false.

      if ( present(is_border_v) ) then
        call ut__assert( present(is_border_u),              &
                         "__MODULE__(__LINE__): "           &
                         // "Needs both border_u and _v." )
        u_nu_ = size(is_border_u,dim=1)
        u_nv_ = size(is_border_u,dim=2)
        v_nu_ = size(is_border_v,dim=1)
        v_nv_ = size(is_border_v,dim=2)
        call ut__assert( u_nu_ == this.u_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of border_u and mesh_edge." )
        call ut__assert( u_nv_ == this.u_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of border_u and mesh_edge." )
        call ut__assert( v_nu_ == this.v_nu,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nu of border_u and mesh_edge." )
        call ut__assert( v_nv_ == this.v_nv,                    &
                         "__MODULE__(__LINE__): "               &
                         // "Inconsistent nv of border_v and mesh_edge." )
        this.is_border_u(:,:) = is_border_u(:,:)
        this.is_border_v(:,:) = is_border_v(:,:)
      else 
        ! the case of usual (rectangular) border
        this.is_border_u(:,        1) = .true. ! south bourder
        this.is_border_u(:,this.u_nv) = .true. ! north bourder
        this.is_border_v(        1,:) = .true. ! west bourder
        this.is_border_v(this.v_nu,:) = .true. ! east bourder
      end if
    end subroutine iBorder_set

  end subroutine slice_mesh__edge_initialize


  subroutine slice_mesh__edge_finalize( this )
    class(slice_mesh__edge_t) <io> :: this

    deallocate(this.u_quarter)
    deallocate(this.v_quarter)
  end subroutine slice_mesh__edge_finalize  


  function edge_level_check_set_u_quarter( edge_u_nu,  &
                                           edge_u_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(u_quarter) 

    integer <in> :: edge_u_nu, edge_u_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_u_nu,edge_u_nv)  :: u_quarter
    !!>
        Here we compare the scalar field value "vert_val" 
        on each vertex at (i,j) 

                  val_vert(i,j)

        with "level" of the target contour. The comparison
        is applied through edges. 

        There are two kinds of edges, vertical edges (edgve_v)
        and horizontal edges (edge_u).

                         v ("vertical")
                         |
                         |
                         +----- u ("horizontal")

              edge_u
            o--------o
            |        |
     edge_v |        | edge_v
            |        |
            o--------o
              edge_u

        Every edge is labeled by a pair of indeces
        in u and v directions, (ei,ej), while every
        vertex is also labeled by a pair of indeces.

        The two kinds of indexes are related by the
        following figure.

                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)

        Now we denote a vertex binary label
        p (plus) or m (minus); "p" when
                  val_vert(i,j) > level,
        and "m" when 
                  val_vert(i,j) < level.

        And we assign a quarter (four) label
        for every edge as

              Edge    | quarter
          ------------+--------
             m----m   |  0
             m----p   |  1
             p----m   |  2
             p----p   |  3

        For example,
                    MM
                m--------m
                |        |
             PM |        | MM
                |        |
                p--------m
                    PM

    !!<

    integer :: ei, ej  ! edge indexes. They 
                       ! are simply converted
                       ! to  vertex indexes
    ! edge_u
    do ej = 1, edge_u_nv  
      do ei = 1, edge_u_nu
        if ( val_vert(ei,  ej) < level .and. &
             val_vert(ei+1,ej) < level ) then
          !!>
               The path does not cross this edge.
                         ei   ei+1
                          |    |      .      
                      ----M====M---.---- level
                          |    |._______ val_vert(ei+1,ej)
                          |  . |
                          .----|-------- val_vert(ei,ej)
                       .  |    |
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_MM
        else if ( val_vert(ei,  ej) > level .and. &
                  val_vert(ei+1,ej) > level ) then
          !!>
               The path does not cross this edge.

               But special care would be taken when
               this edge is on the border (ej=1 or u_nv).
                          .
                          |    . 
                      ----P====P----.------ level
                         ei   ei+1       .
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_PP
        else if ( val_vert(ei,  ej) >= level .and. &
                  val_vert(ei+1,ej) <  level ) then          
          !!> 
              The path goes through the edge.
                     .
                       .       u2
                       | .     |
                   ----p===.===m----
                       |   | . |
                      u1   |   .
                           |     .
                          u=ui
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_PM
        else if ( val_vert(ei,  ej) <  level .and. &
                  val_vert(ei+1,ej) >= level ) then
          !!> 
              The path goes through the edge, too.
                                 .
                       u1      . 
                       |     . |
                   ----m===.===p----
                       | . |   |
                       .   |   u2
                     .     |     
                          u=ui
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_MP
        else
          call ut__fatal( "__MODULE__(__LINE__): case error." )
        end if
      end do
    end do

  end function edge_level_check_set_u_quarter


  function edge_level_check_set_v_quarter( edge_v_nu,  &
                                           edge_v_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(v_quarter)

    integer <in> :: edge_v_nu, edge_v_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_v_nu,edge_v_nv) :: v_quarter

    !!>
        See comments in "edge_level_check_set_u_quarter".
    !!<

    integer :: ei, ej  ! edge indexes

    ! edge_v
    do ej = 1, edge_v_nv  
      do ei = 1, edge_v_nu
        if ( val_vert(ei,ej  ) < level .and. &
             val_vert(ei,ej+1) < level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_MM
        else if ( val_vert(ei,ej  ) > level .and. &
                  val_vert(ei,ej+1) > level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_PP
        else if ( val_vert(ei,ej  ) >= level .and. &
                  val_vert(ei,ej+1) <  level ) then          
          v_quarter(ei,ej) = SLICE_MESH__EDGE_PM
        else if ( val_vert(ei,ej  ) <  level .and. &
                  val_vert(ei,ej+1) >= level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_MP
        else
          call ut__fatal( "__MODULE__(__LINE__): case error." )
        end if
      end do
    end do

  end function edge_level_check_set_v_quarter  


  subroutine slice_mesh__edge_set_quarter( this,       &
                                           mesh_vert,  &
                                           val_vert,   &
                                           level )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    real, dimension(mesh_vert.nu,  &
                    mesh_vert.nv) <in> :: val_vert
    real <in> :: level

    this.u_quarter(:,:) = -999  ! Any negative. Used later to
    this.v_quarter(:,:) = -999  ! check if all edges are set,
                                ! using ...QUATER_MM, MP, PM, 
                                ! PP are all non-negative.

    this.u_cross_coord(:,:) = NAN ! Reset
    this.v_cross_coord(:,:) = NAN

    this.u_quarter = edge_level_check_set_u_quarter(      &
                                         this.u_nu,       &
                                         this.u_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )

    this.v_quarter = edge_level_check_set_v_quarter(      &
                                         this.v_nu,       &
                                         this.v_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )

    call iInterpol_cross_point_edge_u
    call iInterpol_cross_point_edge_v

    call ut__assert( minval(this.u_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_u." )
    call ut__assert( minval(this.v_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_v." )

  contains

    subroutine iInterpol_cross_point_edge_u
      real :: u1, u2, diff1, diff2
      integer :: ei, ej, quarter
      !!> 
              .                                 .
                .       u2            u1      . 
                | .     |             |     . |
            ----p===.===m----     ----m===.===p----
                |   | . |             | . |   |
               u1   |   .             .   |   u2
                    |     .         .     |  
                   u=ui                  u=ui
      !!<

      do ej = 1, this.u_nv
        do ei = 1, this.u_nu
          quarter = this.u_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_vert.pos_u(ei+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei+1,ej)
            this.u_cross_coord(ei,ej) = linear_interpol( u1, u2, diff1, diff2 )
              ! For both MP and PM cases.
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_u

    subroutine iInterpol_cross_point_edge_v
      real :: v1, v2, diff1, diff2
      integer :: ei, ej, quarter
      ! edge_v
      do ej = 1, this.v_nv
        do ei = 1, this.v_nu
          quarter = this.v_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            v1 = mesh_vert.pos_v(ej)
            v2 = mesh_vert.pos_v(ej+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei,ej+1)
            this.v_cross_coord(ei,ej) = linear_interpol( v1, v2, diff1, diff2 )
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_v    

  end subroutine slice_mesh__edge_set_quarter  

end module slice_mesh_m
