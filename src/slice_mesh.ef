module slice_mesh_m
  use ut_m
  implicit none
  private
  public :: SLICE_MESH__NORTH,  &
            SLICE_MESH__WEST,   &
            SLICE_MESH__SOUTH,  &
            SLICE_MESH__EAST
  public :: SLICE_MESH__EDGE_LEVEL_QUARTER_MM,  &
            SLICE_MESH__EDGE_LEVEL_QUARTER_PP,  &
            SLICE_MESH__EDGE_LEVEL_QUARTER_MP,  &
            SLICE_MESH__EDGE_LEVEL_QUARTER_PM

  integer <const> :: SLICE_MESH__PATH_NORTHWARD = 0    !       0        0 (NORTH)
  integer <const> :: SLICE_MESH__PATH_WESTWARD  = 1    !       |        1 (WEST)
  integer <const> :: SLICE_MESH__PATH_SOUTHWARD = 2    !  1 -- + -- 3   2 (SOUTH)
  integer <const> :: SLICE_MESH__PATH_EASTWARD  = 3    !       |        3 (EAST)
                                                       !       2
  integer <const> :: SLICE_MESH__BORDER_NORTHWARD = 4
  integer <const> :: SLICE_MESH__BORDER_WESTWARD  = 5
  integer <const> :: SLICE_MESH__BORDER_SOUTHWARD = 6
  integer <const> :: SLICE_MESH__BORDER_EASTWARD  = 7

  integer <const> :: SLICE_MESH__EDGE_LEVEL_QUARTER_MM = 0  ! --m===m-- 
  integer <const> :: SLICE_MESH__EDGE_LEVEL_QUARTER_PP = 1  ! --p===p-- 
  integer <const> :: SLICE_MESH__EDGE_LEVEL_QUARTER_MP = 2  ! --m===p-- 
  integer <const> :: SLICE_MESH__EDGE_LEVEL_QUARTER_PM = 3  ! --p===m-- 
    !!>
        When you change values of SLICE_MESH__EDGE_LEVEL_QUARTER_*,
        note that their positiveness is assumed in some checks.
    !!<


  type, public :: slice_mesh_direct_t
    integer :: d ! 0 (NORTH), 1 (WEST), 2 (SOUTH), 3 (EAST)
                 !        0
                 !        |
                 !   1 -- + -- 3
                 !        |
                 !        2
  contains
    procedure :: turn => slice_mesh_direct__turn
  end type slice_mesh_direct_t


  type, public :: slice_mesh_ivect_t ! integer vector
    integer :: i, j
  contains
    procedure :: shift => slice_mesh_ivect__shift
  end type slice_mesh_ivect_t


  type, public :: slice_mesh__vert_t
    !!>  
        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
    !!< 
    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
  contains
    procedure :: initialize => slice_mesh_vert__initialize
    procedure :: finalize => slice_mesh_vert__finalize
  end type slice_mesh__vert_t  

  type, public :: slice_mesh__cell_t
    !!>  
        v: vertex
        c: cell
            |       |       |       |       |
        c   |   c   |   c   |   c   |   c   |   c
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
        c   |   c   |   c   |   c   |   c   |   c
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
        c   |   c   |   c   |   c   |   c   |   c
            |       |       |       |       |
    !!< 
    integer :: nu, nv
    real, dimension(:,:), allocatable :: mean_val
    real :: mean_val_max, mean_val_min
  contains
    procedure :: initialize => slice_mesh_cell__initialize
    procedure :: finalize => slice_mesh_cell__finalize
    procedure :: set_meanval => slice_mesh_cell__set_meanval
  end type slice_mesh__cell_t  

  type, public :: slice_mesh__edge_t
    !!>                            
                                 edge_v                                    
        v: vertex                   |
        c: cell                     |
        e: edge_u or edge_v         +---- edge_u
                                    
            e       e       e       e       e
        c   e   c   e   c   e   c   e   c   e   c
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
        c   e   c   e   c   e   c   e   c   e   c
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
        c   e   c   e   c   e   c   e   c   e   c
            e       e       e       e       e
    !!< 
    integer :: u_nu, u_nv
    integer :: v_nu, v_nv
    integer, dimension(:,:), allocatable :: u_quarter ! {0,1,2,3,4}
    integer, dimension(:,:), allocatable :: v_quarter ! {0,1,2,3,4}
      !!>
          Take an edge V1-V2. 
                    V1--edge--V2  
          Denote "p" when V1 or V2 > level (of the contour),
          and "m" when V1 or V2 < level. For example, when
          V1 > level and V2 < level, 
                     p--edge--m
             There are five possibilities.

          Combination | quarter
          ------------+--------
             m----m   |  0
             p----p   |  1
             m----p   |  2
             p----m   |  3
             p----p   |  4 (Special quarter for boundary edges)
      !!<
    real, dimension(:,:), allocatable :: u_cross_coord
    real, dimension(:,:), allocatable :: v_cross_coord
                                            
  contains
    procedure :: initialize => slice_mesh_edge__initialize
    procedure :: finalize => slice_mesh_edge__finalize
    procedure :: apply_stokes => slice_mesh_edge__apply_stokes
    procedure :: level_check => slice_mesh_edge__level_check
    procedure :: erase => slice_mesh_edge__erase
    procedure :: can_turn_to => slice_mesh_edge__can_turn_to
  end type slice_mesh__edge_t    


contains


  function linear_interpol( x1, x2, diff1, diff2 ) result( xi )
    real <in> :: x1, x2, diff1, diff2
    real :: xi
    !!>   
        Diff1 and diff2 can be negative but they must have the same sign.

         \
          . . . . . . . . . . . .
          .\                    . \
          . \      x=x2         .  |  diff1 > 0.0
          .  \     |            . /
      ----o===+====o-------+----+------ 0.0
          |   .\   .       . \
       x=x1   . \  .       .  | diff2 > 0.0
              .  \ .       . /
              .   \. . . . . 
            x=xi   \ 

    !!<
    real :: weight1, weight2

    call ut__assert( x1 < x2,  &
                     "__MODFUNC__: Bad grids order." )
    call ut__assert( diff1*diff2 >= 0.0,  &
                     "__MODFUNC__: Cannot interpolate." )

    if ( diff1+diff2 == 0.0  ) then
      ! which means diff1 = 0.0 & diff2 = 0.0
      xi = (x1+x2)/2 ! Take the middle point
    else
      ! The following applies in either cases of
      !  (1) diff1 > 0 & diff2 > 0
      !  (2) diff1 < 0 & diff2 < 0
      weight1 = diff2 / (diff1 + diff2)
      weight2 = 1.0 - weight1
      xi = weight1 * x1 + weight2 * x2
      call ut__assert( xi >= x1 .and. xi <= x2,  &
                       "__MODFUNC__: Weight is out of range." )
    end if
  end function linear_interpol


  function slice_mesh_direct__turn( this, how ) result(ans)
    class(slice_mesh_direct_t) <in> :: this
    char(len=*) <in> :: how  ! 'left' 
                             ! 'right' 
                             ! 'back'
    type(slice_mesh_direct_t) :: ans
    !!>
        direct ! 0 (NORTH), 1 (WEST), 2 (SOUTH), 3 (EAST)
               !        0
               !        |
               !   1 -- + -- 3
               !        |
               !        2
    !!<
    select case (how)    
      case ('left')
        ans.d = mod(this.d+1, 4)
      case ('right')
        ans.d = mod(this.d+3, 4)
      case ('back')  ! Though this will not be used...
        ans.d = mod(this.d+2, 4)
      case ('forward')  
        ans.d = this.d
      case default
        call ut__fatal( '__MODFUNC__: case error.' )
    end select
  end function slice_mesh_direct__turn


  function slice_mesh_ivect__shift( this, direction ) result(ans)
    class(slice_mesh_ivect_t) <io> :: this
    integer <in> :: direction
    type(slice_mesh_ivect_t) :: ans

    ans = this  ! copy

    select case (direction)
      case (SLICE_MESH__NORTH)
        ans.j += 1
      case (SLICE_MESH__WEST)
        ans.i -= 1
      case (SLICE_MESH__SOUTH)
        ans.j -= 1
      case (SLICE_MESH__EAST)
        ans.i += 1
      case default
        call ut__fatal( '__MODFUNC__: case error.' )
    end select
  end function slice_mesh_ivect__shift


  subroutine slice_mesh_edge__erase2( this, which_edge, vert_pos )
    class(slice_mesh__edge_t) <io> :: this
    char(len=1) <in> :: which_edge
    type(slice_mesh_ivect_t) <in> :: vert_pos
    
    integer <const> :: MM = SLICE_MESH__EDGE_LEVEL_QUARTER_MM

    if ( which_edge == 'u' ) then
      this.u_quarter(vert_pos.i,vert_pos.j) = MM
    else if ( which_edge == 'v' ) then
      this.v_quarter(vert_pos.i,vert_pos.j) = MM
    else 
      call ut__fatal( '__MODFUNC__: argument error.' )
    end if
  end subroutine slice_mesh_edge__erase2


  subroutine slice_mesh_edge__erase( this, which_edge, ei, ej )
    class(slice_mesh__edge_t) <io> :: this
    char(len=1) <in> :: which_edge
    integer <in> :: ei, ej
    
    if ( which_edge == 'u' ) then
      this.u_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_MM
    else if ( which_edge == 'v' ) then
      this.v_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_MM
    else 
      call ut__fatal( '__MODFUNC__: argument error.' )
    end if
  end subroutine slice_mesh_edge__erase  


  subroutine slice_mesh_vert__initialize( this, nu, nv,  &
                                          u_min, u_max,  &
                                          v_min, v_max )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max

    real :: du, dv
    integer :: i, j

    call ut__assert( (nu > 1) .and.         &
                     (nv > 1) .and.         &
                     (u_max > u_min) .and.  &
                     (v_max > v_min),       &
                    '__MODFUNC__: Invalid arguments.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))

    du = ( u_max - u_min ) / (nu-1)
    dv = ( v_max - v_min ) / (nv-1)

    do i = 1, nu
      this.pos_u(i) = u_min + du*(i-1)
    end do

    do j = 1, nv
      this.pos_v(j) = v_min + dv*(j-1)
    end do
  end subroutine slice_mesh_vert__initialize


  subroutine slice_mesh_vert__finalize( this )
    class(slice_mesh__vert_t) <io> :: this

    deallocate(this.pos_u)
    deallocate(this.pos_v)
  end subroutine slice_mesh_vert__finalize


  subroutine slice_mesh_cell__initialize( this, mesh_vert )
    class(slice_mesh__cell_t) <out> :: this
    class(slice_mesh__vert_t) <in> :: mesh_vert
    !!>
            v: vertex          
            c: cell            
        - & |: edgeu or edgev  

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

               v - - - v - - - v - - - v - - - v
               |       |       |       |       |
               |   c   |   c   |   c   |   c   |
               |       |       |       |       |
               v - - - v - - - v - - - v - - - v
               |       |       |       |       |
               |   c   |   c   |   c   |   c   |
               |       |       |       |       |
               v - - - v - - - v - - - v - - - v
               |       |       |       |       |
               |   c   |   c   |   c   |   c   |
               |       |       |       |       |
               v - - - v - - - v - - - v - - - v
    !!<

    this.nu = mesh_vert.nu - 1
    this.nv = mesh_vert.nv - 1

    allocate(this.mean_val(this.nu,this.nv))

  end subroutine slice_mesh_cell__initialize


  subroutine slice_mesh_cell__finalize( this )
    class(slice_mesh__cell_t) <io> :: this

    deallocate(this.mean_val)
  end subroutine slice_mesh_cell__finalize


  subroutine slice_mesh_edge__initialize( this, mesh_vert )
    class(slice_mesh__edge_t) <out> :: this
    class(slice_mesh__vert_t) <in> :: mesh_vert
    !!>
                            edgev                                    
                              |
          +: vertex           |
                              +---- edgeu

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             |   c   |   c   |   c   |   c   |
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             |   c   |   c   |   c   |   c   |
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             |   c   |   c   |   c   |   c   |
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
    !!<
      this.u_nu = mesh_vert.nu - 1
      this.u_nv = mesh_vert.nv
      this.v_nu = mesh_vert.nu
      this.v_nv = mesh_vert.nv - 1
      allocate(this.u_quarter(this.u_nu,  &
                              this.u_nv))
      allocate(this.v_quarter(this.v_nu,  &
                              this.v_nv))
  end subroutine slice_mesh_edge__initialize


  subroutine slice_mesh_edge__finalize( this )
    class(slice_mesh__edge_t) <io> :: this

    deallocate(this.u_quarter)
    deallocate(this.v_quarter)
  end subroutine slice_mesh_edge__finalize  


  function edge_level_check_set_u_quarter( edge_u_nu,  &
                                           edge_u_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level ) result(u_quarter) 

    integer <in> :: edge_u_nu, edge_u_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_u_nu,edge_u_nv)  :: u_quarter
    !!>
        Each cell is surrounded by four edges; two vertical
        edges (edge_v) and two horizontal edges (edge_u).

                                  v ("vertical")
                                  |
                                  |
                                  +----- u ("horizontal")
              edge_u
            o--------o
            |        |
     edge_v |  cell  | edge_v
            |        |
            o--------o
              edge_u

        Here we compare the scalar field "vert_val" on the
        vertices at (ei,ej) with "level" of the contour. 
        Denoting "p" when 
                  val_vert(ei,ej) > level,
        and "m" when 
                  val_vert(ei,ej) < level.
        Define u_quarter as the sign of dF/du and v_quarter
        as the sign of dF/dv.

          Combination | quarter
          ------------+--------
             m----m   |  0
             p----p   |  1
             m----p   |  2
             p----m   |  3
             p----p   |  4 (Special quarter for boundary edges)

                                   _______ u_quarter = 0
                                  /
                             m--------m
                             |        |
           v_quarter = 3 --> |        | <------ v_quarter = 0
                             |        |
                             p--------m
                                  \______ u_quarter = 3

        Here we calculate crossing point of the contour for
        edges with [uv]_quarter = 2 or 3, by the linear interpolation.

    !!<
    integer :: ei, ej  ! edge indexes
    ! edge_u
    do ej = 1, edge_u_nv  
      ! Some edges on ej=1 (bottom) and ej=u_nv (top) 
      ! will be overwritten later.
      do ei = 1, edge_u_nu
        if ( val_vert(ei,  ej) < level .and. &
             val_vert(ei+1,ej) < level ) then
          !!>
               The path does not cross this edge.
                         ei   ei+1
                          |    |      .      
                      ----m====m---.---- level
                          |    |._______ val_vert(ei+1,ej)
                          |  . |
                          .----|-------- val_vert(ei,ej)
                       .  |    |
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_MM
        else if ( val_vert(ei,  ej) > level .and. &
                  val_vert(ei+1,ej) > level ) then
          !!>
                          .
                          |    . 
                      ----p====p----.------ level
                         ei   ei+1       .
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_PP
        else if ( val_vert(ei,  ej) >= level .and. &
                  val_vert(ei+1,ej) <  level ) then          
          !!> 
              The path goes through the edge.
                     .
                       .       u2
                       | .     |
                   ----p===.===m----
                       |   | . |
                      u1   |   .
                           |     .
                          u=ui
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_PM
        else if ( val_vert(ei,  ej) <  level .and. &
                  val_vert(ei+1,ej) >= level ) then
          !!> 
              The path goes through the edge, too.
                                 .
                       u1      . 
                       |     . |
                   ----m===.===p----
                       | . |   |
                       .   |   u2
                     .     |     
                          u=ui
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_MP
        else
          call ut__assert( "__MODFUNC__: What? Case error?!" )
        end if
      end do
    end do

  end function edge_level_check_set_u_quarter


  function edge_level_check_set_v_quarter( edge_v_nu,  &
                                           edge_v_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level ) result(v_quarter)

    integer <in> :: edge_v_nu, edge_v_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_v_nu,edge_v_nv) :: v_quarter

    !!>
        See comments in "edge_level_check_set_u_quarter".
    !!<

    integer :: ei, ej  ! edge indexes

    ! edge_v
    do ej = 1, edge_v_nv  
      do ei = 1, edge_v_nu
        ! Some edges on ei=1 (left) and ei=u_nv (right) 
        ! will be overwritten later.
        if ( val_vert(ei,ej  ) < level .and. &
             val_vert(ei,ej+1) < level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_MM
        else if ( val_vert(ei,ej  ) > level .and. &
                  val_vert(ei,ej+1) > level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_PP
        else if ( val_vert(ei,ej  ) >= level .and. &
                  val_vert(ei,ej+1) <  level ) then          
          v_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_PM
        else if ( val_vert(ei,ej  ) <  level .and. &
                  val_vert(ei,ej+1) >= level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_LEVEL_QUARTER_MP
        else
          call ut__assert( "__MODFUNC__: What? Case error?!" )
        end if
      end do
    end do

  end function edge_level_check_set_v_quarter  


  subroutine slice_mesh_edge__level_check( this,       &
                                           mesh_vert,  &
                                           val_vert,   &
                                           level )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    real, dimension(mesh_vert.nu,  &
                    mesh_vert.nv) <in> :: val_vert
    real <in> :: level

    this.u_quarter(:,:) = -999  ! Any negative. Used later to
    this.v_quarter(:,:) = -999  ! check if all edges are set.

    this.u_quarter = edge_level_check_set_u_quarter(      &
                                         this.u_nu,       &
                                         this.u_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )

    this.v_quarter = edge_level_check_set_v_quarter(      &
                                         this.v_nu,       &
                                         this.v_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )

    call iInterpol_cross_point_edge_u
    call iInterpol_cross_point_edge_v

    call ut__assert( minval(this.u_quarter) ) >= 0,  &
                     "__MODFUNC__: You missed some edge_u?" )
    call ut__assert( minval(this.v_quarter) ) >= 0,  &
                     "__MODFUNC__: You missed some edge_v?" )

  contains

    subroutine iInterpol_cross_point_edge_u
      real :: u1, u2, diff1, diff2
      integer :: quarter
      !!> 
              .                                 .
                .       u2            u1      . 
                | .     |             |     . |
            ----p===.===m----     ----m===.===p----
                |   | . |             | . |   |
               u1   |   .             .   |   u2
                    |     .         .     |  
                   u=ui                  u=ui
      !!<

      do ej = 1, this.u_nv
        do ei = 1, this.u_nu
          quarter = this.u_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_LEVEL_QUARTER_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_LEVEL_QUARTER_PM ) then
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_vert.pos_u(ei+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei+1,ej)
            this.u_cross_coord(ei,ej) = linear_interpol( u1, u2, diff1, diff2 )
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_u

    subroutine iInterpol_cross_point_edge_v
      real :: v1, v2, diff1, diff2
      integer :: quarter
      ! edge_v
      do ej = 1, this.v_nv
        do ei = 1, this.v_nu
          quarter = this.v_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_LEVEL_QUARTER_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_LEVEL_QUARTER_PM ) then
            v1 = mesh_vert.pos_v(ej)
            v2 = mesh_vert.pos_v(ej+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei,ej+1)
            this.v_cross_coord(ei,ej) = linear_interpol( v1, v2, diff1, diff2 )
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_v    

  end subroutine slice_mesh_edge__level_check  


  function slice_mesh_edge__can_turn_to( this,          &
                                         vpos_now,      &
                                         direct_turned ) result(ans)
    class(slice_mesh__edge_t) <in> :: this
    type(slice_mesh_ivect_t) <in> :: vpos_now
    type(slice_mesh_direct_t) <in> :: direct_turned
    logical :: ans
  
    !!>
          + - + - + - + - + - + - + - + ...j=vert_nv
          |   |   |   |   |   |   |   |
          + - + - + - + - + - + - + - +
          |   |   |   |   |   |   |   |
          + - + - + - M==>N - + - + - +
          |   |   |   |   |   |   |   |
          + - + - + - + - + - + - + - +
          |   |   |   |   |   |   |   |
          + - + - + - + - + - + - + - + ...j=1
          .                           .
          .                           .
         i=1                         i=vert_nu

          Suppose you are now located at the vertex 
        position labeld 'M' in the above figure, you 
        move to a nearest neighbor vertex in 
        the next step. The nearest neighbor vertex to
        move is determined by the condition that the
        edge value toward the nearest neighbor has a
        proper, non-zero, value of edge quarter.
          For example, in the above case, if the value
        of edge_u.quarter on the M-N edge is +1, i.e., 
        eastward, then you jump to N.
    !!<
    integer :: i, j, vert_nu, vert_nv, dir

    i = vpos_now.i
    j = vpos_now.j
    vert_nu = this.v_nu
    vert_nv = this.u_nv
    dir = direct_turned.d

    ans = .false.  ! default

    if ( ( i==1       .and. dir==SLICE_MESH__WEST  ) .or.  &
         ( i==vert_nu .and. dir==SLICE_MESH__EAST  ) .or.  &
         ( j==1       .and. dir==SLICE_MESH__SOUTH ) .or.  &
         ( j==vert_nv .and. dir==SLICE_MESH__NORTH ) ) then
      ! You cannot go through the border.
      return
    end if

    select case (direct_turned.d )
      case (SLICE_MESH__NORTH)
        if ( this.v_quarter(i,j)   == +1 ) ans = .true.
      case (SLICE_MESH__SOUTH)
        if ( this.v_quarter(i,j-1) == -1 ) ans = .true.
      case (SLICE_MESH__EAST)
        if ( this.u_quarter(i,j)   == +1 ) ans = .true.
      case (SLICE_MESH__WEST)
        if ( this.u_quarter(i-1,j) == -1 ) ans = .true.
      case default
        call ut__fatal( '__MODFUNC__: case error.' )
    end select
  end function slice_mesh_edge__can_turn_to

end module slice_mesh_m
