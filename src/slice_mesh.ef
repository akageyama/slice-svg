module slice_mesh_m
  use ut_m
  implicit none

  type slice_mesh_vert_t
    !!>  
        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
    !!< 
    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
  contains
    procedure :: initialize => slice_grid__initialize
    procedure :: finalize => slice_grid__finalize
  end type slice_mesh_vert_t  

  type slice_mesh_cell_t
    !!>  
        v: vertex
        c: cell
            |       |       |       |       |
        c   |   c   |   c   |   c   |   c   |   c
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
        c   |   c   |   c   |   c   |   c   |   c
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
        c   |   c   |   c   |   c   |   c   |   c
            |       |       |       |       |
    !!< 
    integer :: nu, nv
    real, dimension(:,:), allocatable :: val
    real :: val_max, val_min
  contains
    procedure :: initialize => slice_mesh_cell__initialize
    procedure :: finalize => slice_mesh_cell__finalize
    procedure :: set_val_cell => slice_mesh_cell__set_val
  end type slice_mesh_cell_t  

  type slice_mesh_edges_t
    !!>                            
                                 edge_v                                    
        v: vertex                   |
        c: cell                     |
        e: edgeu or edgev           +---- edge_u
                                    
            e       e       e       e       e
        c   e   c   e   c   e   c   e   c   e   c
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
        c   e   c   e   c   e   c   e   c   e   c
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
        c   e   c   e   c   e   c   e   c   e   c
            e       e       e       e       e
    !!< 
    integer :: u_nu, u_nv
    integer :: v_nu, v_nv
    integer, dimension(:,:), allocatable :: u_ternary
    integer, dimension(:,:), allocatable :: v_ternary
                                            ! {+1, 0, -1}
  contains
    procedure :: initialize => slice_mesh_edges__initialize
    procedure :: finalize => slice_mesh_edges__finalize
  end type slice_mesh_edges_t    


contains


  subroutine slice_mesh_vert__initialize( this, nu, nv,  &
                                          u_min, u_max,  &
                                          v_min, v_max )
    class(slice_grid_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max

    real :: du, dv
    integer :: i, j

    call ut__assert( (nu > 1) .and.         &
                     (nv > 1) .and.         &
                     (u_max > u_min) .and.  &
                     (v_max > v_min),       &
                    'Invalid coord-related arguments.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))

    du = ( u_max - u_min ) / (nu-1)
    dv = ( v_max - v_min ) / (nv-1)

    do i = 1, nu
      this.pos_u(i) = u_min + du*(i-1)
!debugp i, this.vert_pos_u(i)        
    end do

    do j = 1, nv
      this.pos_v(j) = v_min + dv*(j-1)
!debugp j, this.vert_pos_v(j)        
    end do
  end subroutine slice_mesh_vert__initialize


  subroutine slice_mesh_vert__finalize( this )
    class(slice_mesh_vert_t) <io> :: this

    deallocate(this.pos_u)
    deallocate(this.pos_v)
  end subroutine slice_mesh_vert__finalize


  subroutine slice_mesh_cell__initialize( this, mesh_vert )
    class(slice_mesh_vert_t) <out> :: this
    class(slice_mesh_vert_t) <in> :: this
    !!>
                                 edgev                                    
        v: vertex                   |
        c: cell                     |
        e: edgeu or edgev           +---- edgeu

        mesh_vert.nu = 5
        mesh_vert.nv = 4
        edgex                                    
             v e e e v e e e v e e e v e e e v
             e       e       e       e       e
             e   c   e   c   e   c   e   c   e
             e       e       e       e       e
             v e e e v e e e v e e e v e e e v
             e       e       e       e       e
             e   c   e   c   e   c   e   c   e
             e       e       e       e       e
             v e e e v e e e v e e e v e e e v
             e       e       e       e       e
             e   c   e   c   e   c   e   c   e
             e       e       e       e       e
             v e e e v e e e v e e e v e e e v

    !!<

    this.nu = mesh_vert.nu - 1
    this.nv = mesh_vert.nv - 1

    allocate(this.cell(this.nu,this.nv))

  end subroutine slice_mesh_cell__initialize


  subroutine slice_mesh_cell__finalize( this )
    class(slice_grid_t) <io> :: this

    deallocate(this.cell)
  end subroutine slice_mesh_cell__finalize


  subroutine slice_mesh_edges__initialize( this, mesh_vert )
    class(slice_mesh_edges_t) <out> :: this
    class(slice_mesh_vert_t) <in> :: mesh_vert

      this.u_nu = mesh_vert.nu - 1
      this.u_nv = this.vert_nv
      this.v_nu = this.vert_nu
      this.v_nv = this.vert_nv - 1
      allocate(this.edgeu_ternary(this.edgeu_nu,  &
                                  this.edgeu_nv))
      allocate(this.edgev_ternary(this.edgev_nu,  &
                                  this.edgev_nv))

  end subroutine slice_mesh_edges__initialize


  subroutine slice_mesh_edges__finalize( this )
    class(slice_grid_t) <io> :: this

    deallocate(this.vert_pos_u)
    deallocate(this.vert_pos_v)
    deallocate(this.edgeu_ternary)
    deallocate(this.edgev_ternary)
  end subroutine slice_mesh_edges__finalize  


  subroutine slice_grid__set_val_cell( this, scal_val_vert )
    class(slice_grid_t) <io> :: this
    real, dimension(:,:) <in> :: scal_val_vert

    integer :: i, j

    call ut__assert( size(scal_val_vert,dim=1) == this.vert_nu, .and.  &
                     size(scal_val_vert,dim=2) == this.vert_nv, &
                    'Inconsistent size of input scal_val_vert.' )
    ! Take average
    do j = 1, this.cell_nv
      do i = 1, this.cell_nu
        this.val_cell(i,j) = (  scal_val_vert(i,    j)   &
                              + scal_val_vert(i+1,  j)   &
                              + scal_val_vert(i,  j+1)   &
                              + scal_val_vert(i+1,j+1) ) / 4
      end do
    end do
    this.cell_val_max = maxval(scal_val_cell)
    this.cell_val_min = minval(scal_val_cell)
  end subroutine slice_grid__set_val_cell


end module slice_mesh_m