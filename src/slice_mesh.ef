module slice_mesh_m
  use const_base_m
  use ut_m
  implicit none
  private
  public :: SLICE_MESH__EDGE_MM,  &
            SLICE_MESH__EDGE_PP,  &
            SLICE_MESH__EDGE_MP,  &
            SLICE_MESH__EDGE_PM

  integer <const> :: SLICE_MESH__EDGE_MM = 0  ! --m===m-- 
  integer <const> :: SLICE_MESH__EDGE_MP = 1  ! --m===p-- 
  integer <const> :: SLICE_MESH__EDGE_PM = 2  ! --p===m-- 
  integer <const> :: SLICE_MESH__EDGE_PP = 3  ! --p===p-- 
    !!>
        When you change values of SLICE_MESH__EDGE_*,
        note that their positiveness is assumed in some checks.
    !!<

  type, public :: slice_mesh__vert_t
    !!>  
        v: vertex
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
            |       |       |       |       |
       -----v-------v-------v-------v-------v-----
            |       |       |       |       |
            |       |       |       |       |
    !!< 
    integer :: nu, nv
    real, dimension(:), allocatable :: pos_u
    real, dimension(:), allocatable :: pos_v
    real :: u_min, u_max
    real :: v_min, v_max
  contains
    procedure :: initialize => slice_mesh__vert_initialize
    procedure :: finalize => slice_mesh__vert_finalize
  end type slice_mesh__vert_t  

  type, public :: slice_mesh__edge_t
    !!>                            
                                 edge_v                                    
                                    |
        v: vertex                   |
        e: edge_u or edge_v         +---- edge_u
                                    
            e       e       e       e       e
            e       e       e       e       e    
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
            e       e       e       e       e    
            e       e       e       e       e
      e e e v e e e v e e e v e e e v e e e v e e e
            e       e       e       e       e
            e       e       e       e       e    
            e       e       e       e       e
    !!< 
    integer :: u_nu, u_nv
    integer :: v_nu, v_nv
    integer, dimension(:,:), allocatable :: u_quarter ! {0,1,2,3}
    integer, dimension(:,:), allocatable :: v_quarter ! {0,1,2,3}
      !!>
          Take an edge V1-V2. 
                    V1--edge--V2  
          Denote "p" when V1 or V2 > level (of the contour),
          and "m" when V1 or V2 < level. For example, when
          V1 > level and V2 < level, 
                     p--edge--m
             There are four possibilities.

          Combination | quarter
          ------------+--------
             m - - m  |  0
             m - - p  |  1
             p - - m  |  2
             p - - p  |  3 (Special quarter for border edges)
      !!<
    real, dimension(:,:), allocatable :: u_cross_coord
    real, dimension(:,:), allocatable :: v_cross_coord
                                            
  contains
    procedure :: initialize => slice_mesh__edge_initialize
    procedure :: finalize => slice_mesh__edge_finalize
    procedure :: set_quarter => slice_mesh__edge_set_quarter
    procedure :: erase => slice_mesh_edge__erase
  end type slice_mesh__edge_t    


contains


  function linear_interpol( x1, x2, diff1, diff2 ) result( xi )
    real <in> :: x1, x2, diff1, diff2
    real :: xi
    !!>   
        Diff1 and diff2 can be negative but they 
        must have the same sign.

         \
          \ - - - - - - - - -  val(x1)
          .\                 |
          . \      x=x2      | diff1 > 0.0
          .  \     |         |
      ----o===+====o-------------- level 
          |   .\   .         |
       x=x1   . \  .         | diff2 > 0.0
              .  \ .         |
              .   \ - - - - -  val(x2)
            x=xi   \

    !!<
    real :: weight1, weight2

    call ut__assert( x1 < x2,  &
                     "__MODULE__(__LINE__): Bad grids order." )
    call ut__assert( diff1*diff2 >= 0.0,  &
                     "__MODULE__(__LINE__): Cannot interpolate." )

    if ( diff1+diff2 == 0.0  ) then
      ! which means diff1 = 0.0 & diff2 = 0.0
      xi = (x1+x2)/2 ! Take the middle point
                     ! I'm not very sure if this is OK.
    else
      ! The following applies in either cases of
      !  (1) diff1 > 0 & diff2 > 0
      !  (2) diff1 < 0 & diff2 < 0
      weight1 = diff2 / (diff1 + diff2)
      weight2 = 1.0 - weight1
      xi = weight1 * x1 + weight2 * x2
      call ut__assert( xi >= x1 .and. xi <= x2,  &
                       "__MODULE__(__LINE__): Weight is out of range." )
    end if
  end function linear_interpol


  subroutine slice_mesh_edge__erase( this, which_edge, ei, ej )
    class(slice_mesh__edge_t) <io> :: this
    char(len=1) <in> :: which_edge
    integer <in> :: ei, ej
    
    if ( which_edge == 'u' ) then
      this.u_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else if ( which_edge == 'v' ) then
      this.v_quarter(ei,ej) = SLICE_MESH__EDGE_MM
    else 
      call ut__fatal( '__MODULE__(__LINE__): argument error.' )
    end if
  end subroutine slice_mesh_edge__erase  


  subroutine slice_mesh__vert_initialize( this, nu, nv,  &
                                          u_min, u_max,  &
                                          v_min, v_max )
    class(slice_mesh__vert_t) <out> :: this
    integer <in> :: nu, nv
    real <in> :: u_min, u_max
    real <in> :: v_min, v_max

    real :: du, dv
    integer :: i, j

    call ut__assert( (nu > 1) .and.         &
                     (nv > 1) .and.         &
                     (u_max > u_min) .and.  &
                     (v_max > v_min),       &
                    '__MODULE__(__LINE__): Invalid arguments.' )

    this.nu = nu
    this.nv = nv
    this.u_min = u_min
    this.u_max = u_max
    this.v_min = v_min
    this.v_max = v_max

    allocate(this.pos_u(nu))
    allocate(this.pos_v(nv))

    du = ( u_max - u_min ) / (nu-1)
    dv = ( v_max - v_min ) / (nv-1)

    do i = 1, nu
      this.pos_u(i) = u_min + du*(i-1)
    end do

    do j = 1, nv
      this.pos_v(j) = v_min + dv*(j-1)
    end do
  end subroutine slice_mesh__vert_initialize


  subroutine slice_mesh__vert_finalize( this )
    class(slice_mesh__vert_t) <io> :: this

    deallocate(this.pos_u)
    deallocate(this.pos_v)
  end subroutine slice_mesh__vert_finalize


  subroutine slice_mesh__edge_initialize( this, mesh_vert )
    class(slice_mesh__edge_t) <out> :: this
    class(slice_mesh__vert_t) <in> :: mesh_vert
    !!>
                            edgev                                    
                              |
                              |
                              +---- edgeu

        When mesh_vert.nu = 5, and mesh_vert.nv = 4

             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
             e       e       e       e       e
             d       d       d       d       d
             v       v       v       v       v
             + edgeu + edgeu + edgeu + edgeu +
    !!<
      this.u_nu = mesh_vert.nu - 1
      this.u_nv = mesh_vert.nv
      this.v_nu = mesh_vert.nu
      this.v_nv = mesh_vert.nv - 1
      allocate(this.u_cross_coord(this.u_nu,  &
                                  this.u_nv))
      allocate(this.v_cross_coord(this.v_nu,  &
                                  this.v_nv))
      allocate(this.u_quarter(this.u_nu,  &
                              this.u_nv))
      allocate(this.v_quarter(this.v_nu,  &
                              this.v_nv))
  end subroutine slice_mesh__edge_initialize


  subroutine slice_mesh__edge_finalize( this )
    class(slice_mesh__edge_t) <io> :: this

    deallocate(this.u_quarter)
    deallocate(this.v_quarter)
  end subroutine slice_mesh__edge_finalize  


  function edge_level_check_set_u_quarter( edge_u_nu,  &
                                           edge_u_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(u_quarter) 

    integer <in> :: edge_u_nu, edge_u_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_u_nu,edge_u_nv)  :: u_quarter
    !!>
        Here we compare the scalar field value "vert_val" 
        on each vertex at (i,j) 

                  val_vert(i,j)

        with "level" of the target contour. The comparison
        is applied through edges. 

        There are two kinds of edges, vertical edges (edgve_v)
        and horizontal edges (edge_u).

                         v ("vertical")
                         |
                         |
                         +----- u ("horizontal")

              edge_u
            o--------o
            |        |
     edge_v |        | edge_v
            |        |
            o--------o
              edge_u

        Every edge is labeled by a pair of indeces
        in u and v directions, (ei,ej), while every
        vertex is also labeled by a pair of indeces.

        The two kinds of indexes are related by the
        following figure.

                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)

        Now we denote a vertex binary label
        p (plus) or m (minus); "p" when
                  val_vert(i,j) > level,
        and "m" when 
                  val_vert(i,j) < level.

        And we assign a quarter (four) label
        for every edge as

              Edge    | quarter
          ------------+--------
             m----m   |  0
             m----p   |  1
             p----m   |  2
             p----p   |  3

        For example,
                    MM
                m--------m
                |        |
             PM |        | MM
                |        |
                p--------m
                    PM

    !!<

    integer :: ei, ej  ! edge indexes. They 
                       ! are simply converted
                       ! to  vertex indexes
    ! edge_u
    do ej = 1, edge_u_nv  
      do ei = 1, edge_u_nu
        if ( val_vert(ei,  ej) < level .and. &
             val_vert(ei+1,ej) < level ) then
          !!>
               The path does not cross this edge.
                         ei   ei+1
                          |    |      .      
                      ----M====M---.---- level
                          |    |._______ val_vert(ei+1,ej)
                          |  . |
                          .----|-------- val_vert(ei,ej)
                       .  |    |
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_MM
        else if ( val_vert(ei,  ej) > level .and. &
                  val_vert(ei+1,ej) > level ) then
          !!>
               The path does not cross this edge.

               But special care would be taken when
               this edge is on the border (ej=1 or u_nv).
                          .
                          |    . 
                      ----P====P----.------ level
                         ei   ei+1       .
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_PP
        else if ( val_vert(ei,  ej) >= level .and. &
                  val_vert(ei+1,ej) <  level ) then          
          !!> 
              The path goes through the edge.
                     .
                       .       u2
                       | .     |
                   ----p===.===m----
                       |   | . |
                      u1   |   .
                           |     .
                          u=ui
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_PM
        else if ( val_vert(ei,  ej) <  level .and. &
                  val_vert(ei+1,ej) >= level ) then
          !!> 
              The path goes through the edge, too.
                                 .
                       u1      . 
                       |     . |
                   ----m===.===p----
                       | . |   |
                       .   |   u2
                     .     |     
                          u=ui
          !!<
          u_quarter(ei,ej) = SLICE_MESH__EDGE_MP
        else
          call ut__fatal( "__MODULE__(__LINE__): case error." )
        end if
      end do
    end do

  end function edge_level_check_set_u_quarter


  function edge_level_check_set_v_quarter( edge_v_nu,  &
                                           edge_v_nv,  &
                                           vert_nu,    &
                                           vert_nv,    &
                                           val_vert,   &
                                           level )     &
                                    result(v_quarter)

    integer <in> :: edge_v_nu, edge_v_nv
    integer <in> :: vert_nu, vert_nv
    real, dimension(vert_nu,vert_nv) <in> :: val_vert
    real <in> :: level
    integer, dimension(edge_v_nu,edge_v_nv) :: v_quarter

    !!>
        See comments in "edge_level_check_set_u_quarter".
    !!<

    integer :: ei, ej  ! edge indexes

    ! edge_v
    do ej = 1, edge_v_nv  
      do ei = 1, edge_v_nu
        if ( val_vert(ei,ej  ) < level .and. &
             val_vert(ei,ej+1) < level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_MM
        else if ( val_vert(ei,ej  ) > level .and. &
                  val_vert(ei,ej+1) > level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_PP
        else if ( val_vert(ei,ej  ) >= level .and. &
                  val_vert(ei,ej+1) <  level ) then          
          v_quarter(ei,ej) = SLICE_MESH__EDGE_PM
        else if ( val_vert(ei,ej  ) <  level .and. &
                  val_vert(ei,ej+1) >= level ) then
          v_quarter(ei,ej) = SLICE_MESH__EDGE_MP
        else
          call ut__fatal( "__MODULE__(__LINE__): case error." )
        end if
      end do
    end do

  end function edge_level_check_set_v_quarter  


  subroutine slice_mesh__edge_set_quarter( this,       &
                                           mesh_vert,  &
                                           val_vert,   &
                                           level )
    class(slice_mesh__edge_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    real, dimension(mesh_vert.nu,  &
                    mesh_vert.nv) <in> :: val_vert
    real <in> :: level

    this.u_quarter(:,:) = -999  ! Any negative. Used later to
    this.v_quarter(:,:) = -999  ! check if all edges are set,
                                ! using ...QUATER_MM, MP, PM, 
                                ! PP are all non-negative.

    this.u_cross_coord(:,:) = NAN ! Reset
    this.v_cross_coord(:,:) = NAN

    this.u_quarter = edge_level_check_set_u_quarter(      &
                                         this.u_nu,       &
                                         this.u_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )

    this.v_quarter = edge_level_check_set_v_quarter(      &
                                         this.v_nu,       &
                                         this.v_nv,       &
                                         mesh_vert.nu,    &
                                         mesh_vert.nv,    &
                                         val_vert,        &
                                         level )

    call iInterpol_cross_point_edge_u
    call iInterpol_cross_point_edge_v

    call ut__assert( minval(this.u_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_u." )
    call ut__assert( minval(this.v_quarter) >= 0,  &
                     "__MODULE__(__LINE__): You missed some edge_v." )

  contains

    subroutine iInterpol_cross_point_edge_u
      real :: u1, u2, diff1, diff2
      integer :: ei, ej, quarter
      !!> 
              .                                 .
                .       u2            u1      . 
                | .     |             |     . |
            ----p===.===m----     ----m===.===p----
                |   | . |             | . |   |
               u1   |   .             .   |   u2
                    |     .         .     |  
                   u=ui                  u=ui
      !!<

      do ej = 1, this.u_nv
        do ei = 1, this.u_nu
          quarter = this.u_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            u1 = mesh_vert.pos_u(ei)
            u2 = mesh_vert.pos_u(ei+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei+1,ej)
            this.u_cross_coord(ei,ej) = linear_interpol( u1, u2, diff1, diff2 )
              ! For both MP and PM cases.
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_u

    subroutine iInterpol_cross_point_edge_v
      real :: v1, v2, diff1, diff2
      integer :: ei, ej, quarter
      ! edge_v
      do ej = 1, this.v_nv
        do ei = 1, this.v_nu
          quarter = this.v_quarter(ei,ej)
          if ( quarter == SLICE_MESH__EDGE_MP  &
                      .or.                                   &
               quarter == SLICE_MESH__EDGE_PM ) then
            v1 = mesh_vert.pos_v(ej)
            v2 = mesh_vert.pos_v(ej+1)
            diff1 = val_vert(ei,ej) - level
            diff2 = level - val_vert(ei,ej+1)
            this.v_cross_coord(ei,ej) = linear_interpol( v1, v2, diff1, diff2 )
          end if
        end do
      end do
    end subroutine iInterpol_cross_point_edge_v    

  end subroutine slice_mesh__edge_set_quarter  

end module slice_mesh_m
