module contour_curve_m
  use ut_m
  use const_base_m
  use slice_mesh_m
  implicit none
  private

  !!> 
     To draw contour paths for a given level.
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m *-- - p - - * m - - - m -  
             |      *|       |       *       |   
             |    *  |       |       |*      |   
           - m -*- - p - - - p - - - p * - - m -  
             |   *   |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |     * |       |       |*      |   
             |     * |       |       *       |   
           - m - - * m - - - P - - * M - - - m -  
             |      *|       |  *    |       |   
             |       * * * * *       |       |   
           - m - - - m - - - m - - - m - - - m -  
             |       |       |       |       |   

     The border is usually rectangular.

          +=======+=======+=======+=======+=======+
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          +=======+=======+=======+=======+=======+


     This library also accepts general border shape such as follows.
     The letter 'W' stands for the turning direction when you go
     along the border in the anti-crlockwise.

            . . .   . . . S=======+=======+=======W
          .       .       |       .       .       |     
          .       .       |       .       .       |     
            . . . S=======W . . . + . . . E=======N
          .       |       .       .       |       .     
          .       |       .       .       |       .     
          S=======W . . . + . . . + . . . N=======W
          |       .       .       .       .       |     
          |       .       .       .       .       |     
          E=======S . . . + . . . + . . . + . . . +
          .       |       .       .       .       |     
          .       |       .       .       .       |     
            . . . E=======S . . . E=======+=======N
          .       .       |       |       .       .     
          .       .       |       |       .       .     
            . . .   . . . E=======N . . .   . . .  

      Mathematically, every contour line is closed unless it touches 
      on the border of the simulatin box (u=umin/umax or v=vmin/vmax).

      We set a virtual contour line along the border if the boudary grid
      vertices satisfy the condition 
          vert_val >= level  (denoted by "p" in the figure),
      see the upper right figure. 

      Since all contour lines are thus always closed, we first find an
      edge (starting edge) for each contour and draw the contour with
      keeping grid vertices with 
          vert_val >= level
      always in its left-hand side of the path.
      
      Starting edge of a trully closed contour (without touching the
      boundaries) is any u_edge with its quarter value "PM" (plus-in-left
      and minus-in-right of the edge).

      Cares should be taken for contour lines with virual (on-border)
      contours. 

           ei     ei+1    *      
           |       |    *       
       - - p - - - p -*-       
           |       |*         
           |      *|         
           |    *  |        
    ej - - p==*====m - -   
           | *  \  |              
           |*   PM |             
           *      \
                   \
                 start edge   
  !!< 

  type, public :: contour_curve__element_t
    char(len=1) :: which_edge ! 'u' or 'v' or 'b'
    char(len=2) :: cruising_lane ! 'in' (bulk) or 'on' (border)
    integer :: i, j  ! edge id (for in-lane), or 
                     ! vertex id (for on-lane).
    character :: path_go_toward
  end type contour_curve__element_t

  type, public :: contour_curve_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    type(contour_curve__element_t) :: start
    type(contour_curve__element_t) :: head
    real, dimension(:), allocatable :: list_u, list_v
  contains
    procedure :: initialize => contour_curve__initialize
    procedure :: reset => contour_curve__reset
    procedure :: trace_and_erase  &
                       => contour_curve__trace_and_erase
    procedure :: set_start_edge &
                       => contour_curve__set_start_edge
    procedure :: is_closed => contour_curve__is_closed
    procedure :: register_new_vert => contour_curve__register_new_vert
    procedure :: replace_head_edge => contour_curve__replace_head_edge
  end type contour_curve_t


contains


  subroutine contour_curve__replace_head_edge( this,         &
                                               vi, vj,       &
                                               octa_direct,  &
                                               cruising_lane )
    class(contour_curve_t) <io> :: this
    integer <in> :: vi, vj
    integer <in> :: octa_direct
    char(len=2) <in> :: cruising_lane

    if ( cruising_lane == 'on' ) then
      select case ( octa_direct )
        case (0)
          path.head = contour_curve__element_t( 'v', 'on',   vi,   vj, 'N' )
        case (1)    
          path.head = contour_curve__element_t( 'a', 'on',   vi,   vj, 'N' )
        case (2)    
          path.head = contour_curve__element_t( 'u', 'on',   vi,   vj, 'E' )
        case (3)  
          path.head = contour_curve__element_t( 'd', 'on',   vi, vj-1, 'S' )
        case (4)  
          path.head = contour_curve__element_t( 'v', 'on',   vi, vj-1, 'S' )
        case (5)
          path.head = contour_curve__element_t( 'a', 'on', vi-1, vj-1, 'S' )
        case (6)
          path.head = contour_curve__element_t( 'u', 'on', vi-1,   vj, 'W' )
        case (7)  
          path.head = contour_curve__element_t( 'd', 'on', vi-1,   vj, 'N' )
        case default
          call ut__fatal( '__MODULE__(__LINE__): case error.' )
      end select
    else if ( cruising_lane == 'in' ) then
      select case ( odirect )
        case (0)
          path.head = contour_curve__element_t( 'v', 'in',   vi,   vj, 'W' )
        case (1)    
          path.head = contour_curve__element_t( 'a', 'in',   vi,   vj, 'N' )
        case (2)    
          path.head = contour_curve__element_t( 'u', 'in',   vi,   vj, 'N' )
        case (3)  
          path.head = contour_curve__element_t( 'd', 'in',   vi, vj-1, 'N' )
        case (4)  
          path.head = contour_curve__element_t( 'v', 'in',   vi, vj-1, 'E' )
        case (5)
          path.head = contour_curve__element_t( 'a', 'in', vi-1, vj-1, 'S' )
        case (6)
          path.head = contour_curve__element_t( 'u', 'in', vi-1,   vj, 'S' )
        case (7)  
          path.head = contour_curve__element_t( 'd', 'in', vi-1,   vj, 'S' )
        case default
          call ut__fatal( '__MODULE__(__LINE__): case error.' )
      end select
    else
      call ut__fatal( '__MODULE__(__LINE__): cruising_lane error.' )
    end if

  end subroutine contour_curve__replace_head_edge


  subroutine contour_curve__register_new_vert( this, u, v )
    class(contour_curve_t) <io> :: this
    real <in> :: u, v

    integer :: n

    n = this.num + 1
    call ut__assert( n <= size(this.list_u,dim=1),  &
                    '__MODULE__(__LINE__): Increase array size of path_vert.' )

    this.list_u(n) = u
    this.list_v(n) = v
    this.num = n
  end subroutine contour_curve__register_new_vert


  subroutine jump_to_u_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    integer :: vi0, vj0
    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.u_quarter(ei0,ej0) == SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = edge.u_cross_coord(ei0,ej0)
      v = vert.pos_v(ej0)
      call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      path.register_new_vert( u, v )  !       __ new head      
      if ( ej0 == edge.u_nv ) then    !      /
        vi0 = ei0                     ! - - p * * - m - -
        vj0 = ej0                     !     .     * .
        path.head = contour_curve__element_t( 'u', 'on', vi0, vj0, 'W' )
      else
        path.head = contour_curve__element_t( 'u', 'in', ei0, ej0, 'N' )
      end if   
      call edge.erase( 'u', ei0, ej0 ) 
    end if
  end subroutine jump_to_u_edge_pm_if_possible


  subroutine jump_to_u_edge_mp_if_possible( path, vert, edge, jumped,  &
                                            ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    real :: u, v
    integer :: vi0, vj0

    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.u_quarter(ei0,ej0) == SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = edge.u_cross_coord(ei0,ej0)
      v = vert.pos_v(ej0)
      path.register_new_vert( u, v )
      if ( ej0 == 1 ) then !         *       .  __ new head.
        vi0 = ei0 + 1      !           *     . /
        vj0 = ej0          !     - - m - * * p - - 
        path.head = contour_curve__element_t( 'u', 'on', vi0, vj0, 'E' )
      else
        path.head = contour_curve__element_t( 'u', 'in', ei0, ej0, 'S' )
      end if    
      call edge.erase( 'u', ei0, ej0 ) 
    end if
  end subroutine jump_to_u_edge_mp_if_possible  


  subroutine jump_to_v_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    integer :: vi0, vj0
    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.v_quarter(ei0,ej0) == SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = vert.pos_u(ei0)
      v = edge.v_cross_coord(ei0,ej0)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      path.register_new_vert( u, v ) !              .     * .
                                     !              m - * - p - 
      if ( ei0 == 1 ) then           !              . *     .
        vi0 = ei0                    !              *       .
        vj0 = ej0                    ! new head --> p - - - p - 
        path.head = contour_curve__element_t( 'v', 'on', vi0, vj0, 'S' )
      else
        path.head = contour_curve__element_t( 'v', 'in', ei0, ej0, 'W' )
      end if
      call edge.erase( 'v', ei0, ej0 ) 
    end if
  end subroutine jump_to_v_edge_pm_if_possible   


  subroutine jump_to_v_edge_mp_if_possible( path, vert, edge, jumped, ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    integer :: vi0, vj0
    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.v_quarter(ei0,ej0) == SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = vert.pos_u(ei0)
      v = edge.v_cross_coord(ei0,ej0)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      path.register_new_vert( u, v )  !       .       .
                                      !       p - - - p <== new head
      if ( ei0 == edge.v_nu ) then    !       .       * 
        vi0 = ei0                     !       .     * .
        vj0 = ej0 + 1                 !       p - * - m
        path.head = contour_curve__element_t( 'v', 'on', vi0, vj0, 'N' )
      else
        path.head = contour_curve__element_t( 'v', 'in', ei0, ej0, 'E' )
      end if
      call edge.erase( 'v', ei0, ej0 ) 
    end if
  end subroutine jump_to_v_edge_mp_if_possible 





  subroutine go_along_border( path, vert, edge, nth )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    integer <io> :: nth ! this is nth-vert of the border

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j
    integer :: vi_new, vj_new, nth_new
    logical :: jumped
    integer :: num_bverts, quarter, odirect
    real :: u_new v_new

    call ut__assert( path.head.cruising_lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

    vi = path.head.i
    vj = path.head.j
    num_bverts = vert.border_list.num
    call ut__assert( vert.border_list.vi(nth) == vi .and.   &
                     vert.border_list.vj(nth) == vj,        &
                     "__MODULE__(__LINE__): border vert inconsistent." )

    quarter = edge.border.b_quarter(nth)
    odirect = edge.border.octa_direct(nth)

    nth_new = nth + 1
    if ( nth_new > num_bverts ) nth_new -= num_bverts ! cyclic.

    vi_new = vert.border_list.vi(nth_new)
    vj_new = vert.border_list.vj(nth_new)
    
    select case ( quarter )
      case (SLICE_MESH__EDGE_PP)
        !!>
                      |            
                - - - p            
                      .\__ We will register this vert (vi_new,vj_new)
                      .    in this function.
                      .            
                - - - p <== current head of vertex-type (vi,vj)
                      * \__ We have already egistered this vertex           
                      *     in the last step.
                      * \_______You may have come along this edge.
        !!<      
        jumped = .true.
        u_new = vert.pos_u(vi_new)
        v_new = vert.pos_v(vj_new)
        path.register_new_vert( u_new, v_new )
        call edge.border_list.erase( nth )
        select case ( odirect )
          case (0)
            path.head = contour_curve__element_t( 'v', 'on',   vi,   vj, 'N' )
          case (1)    
            path.head = contour_curve__element_t( 'a', 'on',   vi,   vj, 'N' )
          case (2)    
            path.head = contour_curve__element_t( 'u', 'on',   vi,   vj, 'E' )
          case (3)  
            path.head = contour_curve__element_t( 'd', 'on',   vi, vj-1, 'S' )
          case (4)  
            path.head = contour_curve__element_t( 'v', 'on',   vi, vj-1, 'S' )
          case (5)
            path.head = contour_curve__element_t( 'a', 'on', vi-1, vj-1, 'S' )
          case (6)
            path.head = contour_curve__element_t( 'u', 'on', vi-1,   vj, 'W' )
          case (7)  
            path.head = contour_curve__element_t( 'd', 'on', vi-1,   vj, 'N' )
          case default
            call ut__fatal( '__MODULE__(__LINE__): Strange. Could not find path.' )
        end select
      case (SLICE_MESH__EDGE_PM )
        !!>
                   .       |
                 - + - - - m
                   .       .
                   .       * <== new head of edge-type (vi,vj)
                   .       *
                 - + - - - p
                   .       *
                   .       *
        !!<
        jumped = .true.
        u_new = edge.border_list.u_cross_coord(nth)
        v_new = edge.border_list.v_cross_coord(nth)
        call ut__assert( u_new /= NAN .and. v_new /= NAN,   &
                         "__MODULE__(__LINE__): Invalid cross coord." )
        path.register_new_vert( u_new, v_new )
        call edge.border_list.erase( nth )
        select case ( odirect )
          case (0)
            path.head = contour_curve__element_t( 'v', 'in',   vi,   vj, 'W' )
          case (1)    
            path.head = contour_curve__element_t( 'a', 'in',   vi,   vj, 'N' )
          case (2)    
            path.head = contour_curve__element_t( 'u', 'in',   vi,   vj, 'N' )
          case (3)  
            path.head = contour_curve__element_t( 'd', 'in',   vi, vj-1, 'N' )
          case (4)  
            path.head = contour_curve__element_t( 'v', 'in',   vi, vj-1, 'E' )
          case (5)
            path.head = contour_curve__element_t( 'a', 'in', vi-1, vj-1, 'S' )
          case (6)
            path.head = contour_curve__element_t( 'u', 'in', vi-1,   vj, 'S' )
          case (7)  
            path.head = contour_curve__element_t( 'd', 'in', vi-1,   vj, 'S' )
          case default
            call ut__fatal( '__MODULE__(__LINE__): case error.' )
        end select
      case default
        call ut__fatal( '__MODULE__(__LINE__): Strange. Could not find path.' )
    end select

    nth = nth_new

  end subroutine go_along_border


  subroutine jump_to_other_edge_from_edge_uv( path,  &
                                              vert,  &
                                              edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: ei, ej
    logical :: jumped

    call ut__assert( mod(path.head.octa_direct,2)==0,  &
                     "__MODULE__(__LINE__): head.octa_direct must be 0/2/4/6." )
    call ut__assert( path.head.cruising_lane == 'in',  &
                     "__MODULE__(__LINE__): The path should be in the region." )

    jumped = .false.  ! Default.

    ei = path.head.i
    ej = path.head.j

    select case (path.head.octa_direct)
      !!>
                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)
      !!<
      case (0)
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )
        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej )
                         !!>
                              p - - p
                              |    *|To
                              |   * |
                              p -*- m
                                From 
                         !!<
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
                         !!>
                                To
                              p -*- m
                              |  *  |
                              |  *  |
                              p -*- m
                                From 
                         !!<
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
                         !!>
                              m - - m
                            To*     |
                              | *   |
                              p - * m
                                From 
                         !!<
      case (6)
        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej+1 )
                         !!>
                                To
                              p -*- m
                              |   * |
                              |    *|From
                              p - - p
                         !!<
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |     |
                            To|* * *|From
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |    *|
                              |   * |From
                              m -*- p
                                To
                         !!<
      case (4)
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              | *   |
                           To |*    |
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              |  *  |
                              |  *  |
                              m -*- p
                                 To
                         !!<
        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej-1 )
                         !!>
                                From
                              m -*- p
                              |   * |
                              |    *|To
                              m - - m
                         !!<
      case (2)

        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
                         !!>
                              p - - p
                         From *     |
                              |*    |
                              m * - p
                                To
                         !!<
        call jump_to_v_edge_mp_if_possible ( path, vert, edge,  &
                                            jumped, ei+1, ej )
                         !!>
                              p - - p
                         From * * * * To
                              |     |
                              m - - m
                         !!<
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
                         !!>
                                To
                              p * - m
                              |*    |
                         From *     |
                              m - - m
                         !!<
      case default
        call ut__fatal( '__MODULE__(__LINE__): case error.' )
    end select

    call ut__assert( jumped,  &
                     "__MODULE__(__LINE__): Failed to find next path." )
  end subroutine jump_to_other_edge_from_edge_uv



  subroutine jump_to_other_edge_from_edge_ad( path,  &
                                              vert,  &
                                              edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    !!>

        vertex(i,j+1)=> + - - - +
                        | \     |
                        |   \   |
                        |   . \ |
                        + - . - + <==vertex(i+1,j)
                      /    .    
                  vertex   .    
                    (i,j)   .   
                            .
                        edge.d(i,j)

                            
        vertex(i,j+1)=> + - - - +
                        |     / |
                        |   /   |
                        | / .   |
                        + - . - + <==vertex(i+1,j)
                      /    .    
                  vertex   .    
                    (i,j)   .   
                            .
                        edge.a(i,j)
    !!<
    integer :: ei, ej
    logical :: jumped

    call ut__assert( mod(path.head.octa_direct,2)==1,  &
                     "__MODULE__(__LINE__): head.octa_direct must be 1/3/5/7." )
    call ut__assert( path.head.cruising_lane == 'in',  &
                     "__MODULE__(__LINE__): The path should be in the region." )

    jumped = .false.  ! Default.

    ei = path.head.i
    ej = path.head.j

    select case (path.head.which_edge)
      case ('a')
      if ( path.head.path_go_toward == 'N' ) then
        !!>                     
             vertex(i,j+1)=> P - * - M
                             |   * / |
                             |   *   |
                             | *     |
              vertex(i,j) => P - - - + 
        !!<
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
        !!>                     Here Here
             vertex(i,j+1)=> M - - - M
                             |     / |
                             * * *   |
                             | *     |
              vertex(i,j) => P - - - + 
        !!<



        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej )
                         !!>
                              p - - p
                              |    *|To
                              |   * |
                              p -*- m
                                From 
                         !!<
                         !!>
                                To
                              p -*- m
                              |  *  |
                              |  *  |
                              p -*- m
                                From 
                         !!<
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
                         !!>
                              m - - m
                            To*     |
                              | *   |
                              p - * m
                                From 
                         !!<
      case (6)
        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej+1 )
                         !!>
                                To
                              p -*- m
                              |   * |
                              |    *|From
                              p - - p
                         !!<
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |     |
                            To|* * *|From
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |    *|
                              |   * |From
                              m -*- p
                                To
                         !!<
      case (4)
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              | *   |
                           To |*    |
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              |  *  |
                              |  *  |
                              m -*- p
                                 To
                         !!<
        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej-1 )
                         !!>
                                From
                              m -*- p
                              |   * |
                              |    *|To
                              m - - m
                         !!<
      case (2)

        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
                         !!>
                              p - - p
                         From *     |
                              |*    |
                              m * - p
                                To
                         !!<
        call jump_to_v_edge_mp_if_possible ( path, vert, edge,  &
                                            jumped, ei+1, ej )
                         !!>
                              p - - p
                         From * * * * To
                              |     |
                              m - - m
                         !!<
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
                         !!>
                                To
                              p * - m
                              |*    |
                         From *     |
                              m - - m
                         !!<
      case default
        call ut__fatal( '__MODULE__(__LINE__): case error.' )
    end select

    call ut__assert( jumped,  &
                     "__MODULE__(__LINE__): Failed to find next path." )
  end subroutine jump_to_other_edge_from_edge_ad


  function contour_curve__is_closed( this ) result(ans)
    class(contour_curve_t) <in> :: this
    logical :: ans

    logical :: con1, con2, con3

    con1 = ( this.head.which_edge == this.start.which_edge )
    con2 = ( this.head.i == this.start.i )
    con3 = ( this.head.j == this.start.j )
    ans = ( con1 .and. con2 .and. con3 )
  end function contour_curve__is_closed  


  subroutine contour_curve__reset( this )
    class(contour_curve_t) <io> :: this
    this.num = 0
    this.list_u(:) = 0.0
    this.list_v(:) = 0.0
  end subroutine contour_curve__reset


  subroutine contour_curve__initialize( this, vert_nu, vert_nv )
    class(contour_curve_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv
      ! this is clearly an over-estimate.

    allocate(this.list_u(max_path_element_num))
    allocate(this.list_v(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call contour_curve__reset( this )
  end subroutine contour_curve__initialize


  subroutine find_start_edge_on_boundaries( path,    &
                                            vert,    &
                                            edge,    &
                                            status )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'


    !!>
             |       |       |    _ Contour line     | 
           - m - - - m - - - m   /    at "level" - - m
             |       |       * */                    |
             |       |    *  |   *   |       |       |      
           - m - - - m -*- - p - - * m - - - m - - - m   ej=3
             |       *       |       *       |       |
             |     * |       |       | *     |       |
           - m - -*- p - - - p - - - p - * - m - - - m   ej=2
             |    *  |       |       |    *  |       |
             |    *  |       |       |    *  |       |
           - m - - * p * * * p * * * p * * - m - - - m   ej=1
                 \
                  \__ Will find this edge_u


        We will search for the start edge in this order,
           1. South border
           2. East border
           3. North border
           4. West border

                       <---
                   +----------+
                   |  North   |    
               |  W|          |E   ^
               |  e|          |a   |
               v  s|          |s   |
                  t|  South   |t    
                   +----------+
                       ---> 
    !!<    

    integer :: quarter
    integer :: b, i, j
    integer :: octa_direct
    integer :: vi, vj, bvnum, b, b2
    real :: u1, v1, u2, v2
    char(len=2) :: cruising_lane

    call ut__assert( path.num == 0,  &
                    '__MODULE__(__LINE__): You forgot to reset contour_curve.' )

    bvnum  = vert.border_list_num
    do b = 1, bvnum
      quarter = edge.border_list.b_quarter(b)
      if ( quarter == SLICE_MESH__EDGE_PP  .or.  &
           quarter == SLICE_MESH__EDGE_PM ) then
        status = 'have found'
        vi = vert.border_list.vi(b)
        vj = vert.border_list.vj(b)
        u1 = vert.pos_u(vi)
        v1 = vert.pos_v(vj)
        path.register_new_vert( u1, v1 )

        if ( quarter == SLICE_MESH__EDGE_PP ) then
          b2 = b + 1 ! next vert in the border path
          if ( b2 > bvnum ) b2 -= bvnum
          u2 = vert.pos_u(vert.border_list.vi(b2))
          v2 = vert.pos_v(vert.border_list.vj(b2))
          cruising_lane = 'on'
        else ! quarter == SLICE_MESH__EDGE_PM
          u2 = edge.border_list.u_cross_coord(b)
          v2 = edge.border_list.v_cross_coord(b)
          call ut__assert( u2 /= NAN .and. v2 /= NAN,  &
                           "__MODULE__(__LINE__): Invalid cross coord." )
          cruising_lane = 'in'
        end select

        call path.register_new_vert( u2, v2 )
        path.replace_head_edge( 'b' )
        octa_direct = vert.border_list.octa_direct(b)
        call path.replace_head_edge( vi, vj, octa_direct, cruising_lane )
      end if
    end do

  end subroutine find_start_edge_on_boundaries


  subroutine set_start_edge_in_bulk( path,    &
                                     vert,    &
                                     edge,    &
                                     status )  
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'

    !!>
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m -*- - p - - * m - - - m -  
             |       *       |       *       |   
             |     * |       |       |*      |   
           - m - -*- p - - - p - - - p * - - m -  
             |    *  |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |      *|       |       |*      |   
             |       *       |       *       |   
           - m - - - m * - - P=====*=M - - - m -  
             |       |    *  |  * \  |       |   
             |       |       *     \ |       |   
           - m - - - m - - - m - - -\m - - - m -  
             |       |       |       \       |   
                                      \
                                       \___ Try to find this edge of "PM".
                 
    !!< 
    integer :: ei, ej
    integer :: quarter
    real :: u, v

    call ut__assert( path.num == 0,  &
                    '__MODULE__(__LINE__): Forgot to reset contour_curve.' )

    do ej = 2, edge.u_nv-1
      do ei = 2, edge.u_nu-1
        quarter = edge.u_quarter(ei,ej)
        if ( quarter == SLICE_MESH__EDGE_PM ) then
          !!> 
              path tip you
              have just found.  *
                        |    \ *      |
                      --p=====*-------m--
                        |    *        |
             contour ---|-->*         |
                        |  *          |
                        | *           |
          !!<
          status = 'have found'
          u = edge.u_cross_coord(ei,ej)
          v = vert.pos_v(ej)
          call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
          path.register_new_vert( u, v )
          path.head = contour_curve__element_t( 'u', 'in', ei, ej, 'N' )
          path.start = path.head
          return
        end if
      end do
    end do

  end subroutine set_start_edge_in_bulk


  subroutine contour_curve__set_start_edge( this,    &
                                            vert,    &
                                            edge,    &
                                            status )
    class(contour_curve_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge
    char(len=10) <out> :: status ! 'no contour' or 'have found'

    status = 'no contour'  ! default 
    call find_start_edge_on_boundaries( this,    &
                                        vert,    &
                                        edge,    &
                                        status )
    if ( status == 'have found' ) return

    call set_start_edge_in_bulk( this,    &
                                 vert,    &
                                 edge,    &
                                 status )

  end subroutine contour_curve__set_start_edge


  subroutine contour_curve__trace_and_erase( path,  &
                                             vert,  &
                                             edge )
    class(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: nthbv ! of border verts
    char(len=2) :: cruising_lane_prev

    cruising_lane_prev = '  ' ! char len=2
    do
      select case (path.head.cruising_lane)
        case ('on')
          if ( cruising_lane_prev /= 'on' ) then
            ! newly start tracing on the border.
            nthbv = vert.border_list.get_nth_from_vert_pos( path.head.i,  &
                                                            path.head.j )
          end if
          call go_along_border( path, vert, edge, nthbv )
        case ('in')
          if ( mod(path.head.octa_direct,2)==0 ) then
            call jump_to_other_edge_from_edge_uv( path, vert, edge )
          else
            call jump_to_other_edge_from_edge_ad( path, vert, edge )
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
      cruising_lane_prev = path.head.cruising_lane
      if ( path.is_closed() ) then
        call edge.erase( path.start.which_edge,  &
                         path.start.i,           &
                         path.start.j )
        return
      end if
    end do

  end subroutine contour_curve__trace_and_erase

end module contour_curve_m
