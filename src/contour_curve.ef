module contour_curve_m
  use ut_m
  use const_base_m
  use slice_mesh_m
  implicit none
  private

  !!> 
     To draw contour paths for a given level.
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m *-- - p - - * m - - - m -  
             |      *|       |       *       |   
             |    *  |       |       |*      |   
           - m -*- - p - - - p - - - p * - - m -  
             |   *   |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |     * |       |       |*      |   
             |     * |       |       *       |   
           - m - - * m - - - P - - * M - - - m -  
             |      *|       |  *    |       |   
             |       * * * * *       |       |   
           - m - - - m - - - m - - - m - - - m -  
             |       |       |       |       |   

     The border is usually rectangular.

          +=======+=======+=======+=======+=======+
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          +=======+=======+=======+=======+=======+


     This library also accepts general border shape such as follows.
     The letter 'W' stands for the turning direction when you go
     along the border in the anti-crlockwise.

            . . .   . . . S=======+=======+=======W
          .       .       |       .       .       |     
          .       .       |       .       .       |     
            . . . S=======W . . . + . . . E=======N
          .       |       .       .       |       .     
          .       |       .       .       |       .     
          S=======W . . . + . . . + . . . N=======W
          |       .       .       .       .       |     
          |       .       .       .       .       |     
          E=======S . . . + . . . + . . . + . . . +
          .       |       .       .       .       |     
          .       |       .       .       .       |     
            . . . E=======S . . . E=======+=======N
          .       .       |       |       .       .     
          .       .       |       |       .       .     
            . . .   . . . E=======N . . .   . . .  

      Mathematically, every contour line is closed unless it touches 
      on the border of the simulatin box (u=umin/umax or v=vmin/vmax).

      We set a virtual contour line along the border if the boudary grid
      vertices satisfy the condition 
          vert_val >= level  (denoted by "p" in the figure),
      see the upper right figure. 

      Since all contour lines are thus always closed, we first find an
      edge (starting edge) for each contour and draw the contour with
      keeping grid vertices with 
          vert_val >= level
      always in its left-hand side of the path.
      
      Starting edge of a trully closed contour (without touching the
      boundaries) is any u_edge with its quarter value "PM" (plus-in-left
      and minus-in-right of the edge).

      Cares should be taken for contour lines with virual (on-border)
      contours. 

           ei     ei+1    *      
           |       |    *       
       - - p - - - p -*-       
           |       |*         
           |      *|         
           |    *  |        
    ej - - p==*====m - -   
           | *  \  |              
           |*   PM |             
           *      \
                   \
                 start edge   
  !!< 

  type, public :: contour_curve__element_t
    char(len=1) :: which_edge ! 'u' or 'v'
    char(len=2) :: lane ! 'in' (bulk) or 'on' (border)
    integer :: i, j  ! edge id (for in-lane), or 
                     ! vertex id (for on-lane).
    char(len=1) :: direct
  end type contour_curve__element_t

  type, public :: contour_curve_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    type(contour_curve__element_t) :: start
    type(contour_curve__element_t) :: head
    real, dimension(:), allocatable :: list_u, list_v
  contains
    procedure :: initialize => contour_curve__initialize
    procedure :: reset => contour_curve__reset
    procedure :: trace_and_erase  &
                       => contour_curve__trace_and_erase
    procedure :: set_start_edge &
                       => contour_curve__set_start_edge
    procedure :: is_closed => contour_curve__is_closed
  end type contour_curve_t


contains


  subroutine register( contour_curve, u, v )
    type(contour_curve_t) <io> :: contour_curve
    real <in> :: u, v

    integer :: n

    n = contour_curve.num + 1
    call ut__assert( n <= size(contour_curve.list_u,dim=1),  &
                    '__MODULE__(__LINE__): Increase array size of path_vert.' )

    contour_curve.list_u(n) = u
    contour_curve.list_v(n) = v
    contour_curve.num = n
  end subroutine register


  subroutine jump_to_u_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    integer :: vi0, vj0
    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.u_quarter(ei0,ej0) == SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = edge.u_cross_coord(ei0,ej0)
      v = vert.pos_v(ej0)
      call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call register( path, u, v )  !       __ new head      
      if ( ej0 == edge.u_nv ) then !      /
        vi0 = ei0                  ! - - p * * - m - -
        vj0 = ej0                  !     .     * .
        path.head = contour_curve__element_t( 'u', 'on', vi0, vj0, 'W' )
      else
        path.head = contour_curve__element_t( 'u', 'in', ei0, ej0, 'N' )
      end if   
      call edge.erase( 'u', ei0, ej0 ) 
    end if
  end subroutine jump_to_u_edge_pm_if_possible


  subroutine jump_to_u_edge_mp_if_possible( path, vert, edge, jumped,  &
                                            ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    real :: u, v
    integer :: vi0, vj0

    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.u_quarter(ei0,ej0) == SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = edge.u_cross_coord(ei0,ej0)
      v = vert.pos_v(ej0)
      call register( path, u, v )
      if ( ej0 == 1 ) then !         *       .  __ new head.
        vi0 = ei0 + 1      !           *     . /
        vj0 = ej0          !     - - m - * * p - - 
        path.head = contour_curve__element_t( 'u', 'on', vi0, vj0, 'E' )
      else
        path.head = contour_curve__element_t( 'u', 'in', ei0, ej0, 'S' )
      end if    
      call edge.erase( 'u', ei0, ej0 ) 
    end if
  end subroutine jump_to_u_edge_mp_if_possible  


  subroutine jump_to_v_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    integer :: vi0, vj0
    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.v_quarter(ei0,ej0) == SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = vert.pos_u(ei0)
      v = edge.v_cross_coord(ei0,ej0)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call register( path, u, v ) !              .     * .
                                  !              m - * - p - 
      if ( ei0 == 1 ) then        !              . *     .
        vi0 = ei0                 !              *       .
        vj0 = ej0                 ! new head --> p - - - p - 
        path.head = contour_curve__element_t( 'v', 'on', vi0, vj0, 'S' )
      else
        path.head = contour_curve__element_t( 'v', 'in', ei0, ej0, 'W' )
      end if
      call edge.erase( 'v', ei0, ej0 ) 
    end if
  end subroutine jump_to_v_edge_pm_if_possible   


  subroutine jump_to_v_edge_mp_if_possible( path, vert, edge, jumped, ei0, ej0 )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei0, ej0

    integer :: vi0, vj0
    real :: u, v
    if ( jumped ) return  ! you have already jumped for this cell.

    if ( edge.v_quarter(ei0,ej0) == SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = vert.pos_u(ei0)
      v = edge.v_cross_coord(ei0,ej0)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call register( path, u, v )  !       .       .
                                   !       p - - - p <== new head
      if ( ei0 == edge.v_nu ) then !       .       * 
        vi0 = ei0                  !       .     * .
        vj0 = ej0 + 1              !       p - * - m
        path.head = contour_curve__element_t( 'v', 'on', vi0, vj0, 'N' )
      else
        path.head = contour_curve__element_t( 'v', 'in', ei0, ej0, 'E' )
      end if
      call edge.erase( 'v', ei0, ej0 ) 
    end if
  end subroutine jump_to_v_edge_mp_if_possible 


  subroutine go_along_border_on_v_edge_northward( path,   &
                                                  vert,   &
                                                  edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j
    logical :: jumped
    char(len=1) :: dir

    call ut__assert( path.head.lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

    call ut__assert( path.head.direct == 'N',  &
                     "__MODULE__(__LINE__): The path is supposed to go north." )

    vi = path.head.i
    vj = path.head.j
    vj += 1

    select case ( edge.v_quarter(vi,vj-1) )
      case (SLICE_MESH__EDGE_PP) 
        !!>
              .       |            
            - + - - - p            
              .       .\__ Will register this vertex             
              .       .         in the present step.
              .       .            
            - + - - - p <== current head of vertex-type (vi,vj)
              .       * \__ Already egistered this vertex           
              .       *                 in the last step.
              .       * <== You have come along this edge.
        !!<
        jumped = .true.
        u = vert.pos_u(vi)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call edge.erase( 'v', vi, vj-1 )
        dir = vert.border_list_dir(vi,vj)
        select case (dir)
          case ('N')
            !!>
                     .       * <== you will continue going this way.
                     .       *
                   - + - - - p <= new head of vertex type (vi,vj+1)
                     .       *
                     .       *
                     .       *
                   - + - - - p
                     .       *
                     .       *
            !!<
            path.head = contour_curve__element_t( 'v', 'on', vi, vj, dir )
          case ('W','E')
            !!>
                          __ you will go this way.
                         /    
                  - + - <=**p <== new head 
                    .       *
                    .       *
                    .       *
                  - + - - - p
                    .       *

            !!<
            path.head = contour_curve__element_t( 'u', 'on', vi, vj, dir )
          case default 
            call ut__fatal( "__MODULE__(__LINE__): case error." )
        end select
      case (SLICE_MESH__EDGE_PM )
        !!>
                   .       |
                 - + - - - m
                   .       .
                   .       * <== new head of edge-type (vi,vj)
                   .       *
                 - + - - - p
                   .       *
                   .       *
        !!<
        jumped = .true.
        u = vert.pos_u(vi)
        v = edge.v_cross_coord(vi,vj-1)
        call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        call register( path, u, v )
        call edge.erase( 'v', vi, vj-1 )
        path.head = contour_curve__element_t( 'v', 'in', vi, vj-1, 'W' )
      case default
        call ut__fatal( '__MODULE__(__LINE__): Strange. Could not find path.' )
    end select

  end subroutine go_along_border_on_v_edge_northward


  subroutine go_along_border_on_v_edge_southward( path,  &
                                                  vert,  &
                                                  edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j
    logical :: jumped
    char(len=1) :: dir

    call ut__assert( path.head.lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

    call ut__assert( path.head.direct == 'S',  &
                     "__MODULE__(__LINE__): The path is supposed to go north." )

    vi = path.head.i
    vj = path.head.j
    vj -= 1

    select case ( edge.v_quarter(vi,vj) )
      case (SLICE_MESH__EDGE_PP) 
        jumped = .true.
        u = vert.pos_u(vi)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call edge.erase( 'v', vi, vj )
        dir = vert.border_list_dir(vi,vj)
        select case (dir)
          case ('S')
            path.head = contour_curve__element_t( 'v', 'on', vi, vj, dir )
          case ('E','W')
            path.head = contour_curve__element_t( 'u', 'on', vi, vj, dir )
          case default 
            call ut__fatal( "__MODULE__(__LINE__): case error." )
        end select
      case (SLICE_MESH__EDGE_MP )
        !!>
                   *       |
                   *       |
                   p - - - + -
                   *       .
                   *       .
                   .       .
                   m - - - + -
                   |       .
                   |       .
        !!<
        jumped = .true.
        u = vert.pos_u(vi)
        v = edge.v_cross_coord(vi,vj)
        call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        call register( path, u, v )
        call edge.erase( 'v', vi, vj )
        path.head = contour_curve__element_t( 'v', 'in', vi, vj, 'E' )
      case default
        call ut__fatal( '__MODULE__(__LINE__): Strange. Could not find path.' )
    end select

  end subroutine go_along_border_on_v_edge_southward


  subroutine go_along_border_on_u_edge_westward( path,  &
                                                 vert,  &
                                                 edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j

    logical :: jumped
    char(len=1) :: dir

    call ut__assert( path.head.lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

    call ut__assert( path.head.direct == 'W',  &
                     "__MODULE__(__LINE__): The path is supposed to go west." )

    vi = path.head.i
    vj = path.head.j
    vi -= 1

!debugp vi, vj
    select case ( edge.u_quarter(vi,vj) )
      case (SLICE_MESH__EDGE_PP) 
        !!>
                        __ You will go this way.
                       /
                      /      You have come along this edge.
                     /       /        
            - - p - - - p * * *             
                .\      .\
                . \     . \__ Current head of vertex-type (vi,vj)
                .  \    .
                + - - - +
                .    \  . 
                .     New head of vertex-type
        !!<
        jumped = .true.
        u = vert.pos_u(vi)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call edge.erase( 'u', vi, vj )

        dir = vert.border_list_dir(vi,vj)
!debugp dir
!debugp vi, vj        
        select case (dir)
          case ('W')
            !!>
                Continue going westward.
                           __ new head 
                          /
                         /  ___ you will continue going this way.
                        /  /
                       /  /      
                    - p * * * p * * You came along this border.
                      .       .     
                      .       .     
                      .       .     
                    - + - - - + - - 
                      .       .     
            !!<            
            path.head = contour_curve__element_t( 'u', 'on', vi, vj, dir )
          case ('N','S')
            !!>                
                Turn left (right) to south (north).
                                __ new head 
                               / 
                              p * * * p * * 
              you will        *       .
               go this way => *       .
                              .       .
                              + - - - + - -
                              .       .
            !!<            
            path.head = contour_curve__element_t( 'v', 'on', vi, vj, dir )
          case default
            call ut__fatal( "__MODULE__(__LINE__): case error." )          
        end select
      case (SLICE_MESH__EDGE_MP )
        !!>
                           __ new head of edge type (vi-1,vj)
                          /
                         /      
                  - m - * * p * * You came along this border.
                    .  *    .     
                    . *<== You will go this way.
                    .       .     
                  - + - - - + - - 
                    .       .     
        !!<
        jumped = .true.
        u = edge.u_cross_coord(vi,vj)
        v = vert.pos_v(vj)
        call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        call register( path, u, v )
        call edge.erase( 'u', vi, vj )
        path.head = contour_curve__element_t( 'u', 'in', vi, vj, 'S' )
      case default
        call ut__fatal( '__MODULE__(__LINE__): Strange. Could not find path.' )
    end select

  end subroutine go_along_border_on_u_edge_westward


  subroutine go_along_border_on_u_edge_eastward( path,  &
                                                 vert,  &
                                                 edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j
    char(len=1) :: dir
    logical :: jumped

    call ut__assert( path.head.lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

    call ut__assert( path.head.direct == 'E',  &
                     "__MODULE__(__LINE__): The path is supposed to go north." )

    vi = path.head.i
    vj = path.head.j
    vi += 1

    select case ( edge.u_quarter(vi-1,vj) )
      case (SLICE_MESH__EDGE_PP) 
        jumped = .true.
        u = vert.pos_u(vi)
        v = vert.pos_v(vj)
        call register( path, u, v )
        call edge.erase( 'u', vi-1, vj )
        dir = vert.border_list_dir(vi,vj)
        select case ( dir )
          case ('E')
            path.head = contour_curve__element_t( 'u', 'on', vi, vj, dir )
          case ('N','S')
            path.head = contour_curve__element_t( 'v', 'on', vi, vj, dir )
          case default  
            call ut__fatal( "__MODULE__(__LINE__): case error." )
        end select
      case (SLICE_MESH__EDGE_PM )
        jumped = .true.
        u = edge.u_cross_coord(vi-1,vj)
        v = vert.pos_v(vj)
        call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        call register( path, u, v )
        call edge.erase( 'u', vi-1, vj )
        path.head = contour_curve__element_t( 'u', 'in', vi, vj, 'N' )
      case default
        call ut__fatal( '__MODULE__(__LINE__): Strange. Could not find path.' )
    end select

  end subroutine go_along_border_on_u_edge_eastward


  subroutine go_along_border( path, vert, edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    call ut__assert( path.head.lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

!debugp path.head.i
!debugp path.head.j
    select case (path.head.direct)
      case ('N')
        call go_along_border_on_v_edge_northward( path, vert, edge )
      case ('S')
        call go_along_border_on_v_edge_southward( path, vert, edge )
      case ('W')
        call go_along_border_on_u_edge_westward( path, vert, edge )
      case ('E')
        call go_along_border_on_u_edge_eastward( path, vert, edge )
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select
  end subroutine go_along_border


  subroutine jump_to_other_edge( path,  &
                                 vert,  &
                                 edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: ei, ej
    logical :: jumped

    call ut__assert( path.head.lane == 'in',  &
                     "__MODULE__(__LINE__): The path should be in the region." )

    jumped = .false.  ! Default.

!debugp "I am in jump_to_other_edge."
    ei = path.head.i
    ej = path.head.j

!debugp "    ", ei, ej
!debugp "    ", path.head.direct
!debugp "    ", path.head.which_edge
    select case (path.head.direct)
      !!>
                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)
      !!<
      case ('N')
!debugp "            case N"
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )
        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej )
                         !!>
                              p - - p
                              |    *|To
                              |   * |
                              p -*- m
                                From 
                         !!<
!debugp " called jump_to_v_edge_mp_if_possible.", jumped
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
                         !!>
                                To
                              p -*- m
                              |  *  |
                              |  *  |
                              p -*- m
                                From 
                         !!<
!debugp " called jump_to_u_edge_pm_if_possible.", jumped
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
                         !!>
                              m - - m
                            To*     |
                              | *   |
                              p - * m
                                From 
                         !!<
!debugp " called jump_to_v_edge_pm_if_possible.", jumped
      case ('W')
!debugp "            case W"
        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej+1 )
                         !!>
                                To
                              p -*- m
                              |   * |
                              |    *|From
                              p - - p
                         !!<
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |     |
                            To|* * *|From
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |    *|
                              |   * |From
                              m -*- p
                                To
                         !!<
      case ('S')
!debugp "            case S"

        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              | *   |
                           To |*    |
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              |  *  |
                              |  *  |
                              m -*- p
                                 To
                         !!<
        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej-1 )
                         !!>
                                From
                              m -*- p
                              |   * |
                              |    *|To
                              m - - m
                         !!<
      case ('E')
!debugp "            case E"

        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
                         !!>
                              p - - p
                         From *     |
                              |*    |
                              m * - p
                                To
                         !!<
        call jump_to_v_edge_mp_if_possible ( path, vert, edge,  &
                                            jumped, ei+1, ej )
                         !!>
                              p - - p
                         From * * * * To
                              |     |
                              m - - m
                         !!<
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
                         !!>
                                To
                              p * - m
                              |*    |
                         From *     |
                              m - - m
                         !!<
      case default
        call ut__fatal( '__MODULE__(__LINE__): case error.' )
    end select

    call ut__assert( jumped,  &
                     "__MODULE__(__LINE__): Failed to find next path." )
  end subroutine jump_to_other_edge


  function contour_curve__is_closed( this ) result(ans)
    class(contour_curve_t) <in> :: this
    logical :: ans

    logical :: con1, con2, con3

    con1 = ( this.head.which_edge == this.start.which_edge )
    con2 = ( this.head.i == this.start.i )
    con3 = ( this.head.j == this.start.j )
    ans = ( con1 .and. con2 .and. con3 )
  end function contour_curve__is_closed  


  subroutine contour_curve__reset( this )
    class(contour_curve_t) <io> :: this
    this.num = 0
    this.list_u(:) = 0.0
    this.list_v(:) = 0.0
  end subroutine contour_curve__reset


  subroutine contour_curve__initialize( this, vert_nu, vert_nv )
    class(contour_curve_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv

    allocate(this.list_u(max_path_element_num))
    allocate(this.list_v(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call contour_curve__reset( this )
  end subroutine contour_curve__initialize


  subroutine find_start_edge_on_boundaries( path,         &
                                            mesh_vert,    &
                                            mesh_edge,    &
                                            status )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'


    !!>
             |       |       |    _ Contour line     | 
           - m - - - m - - - m   /    at "level" - - m
             |       |       * */                    |
             |       |    *  |   *   |       |       |      
           - m - - - m -*- - p - - * m - - - m - - - m   ej=3
             |       *       |       *       |       |
             |     * |       |       | *     |       |
           - m - -*- p - - - p - - - p - * - m - - - m   ej=2
             |    *  |       |       |    *  |       |
             |    *  |       |       |    *  |       |
           - m - - * p * * * p * * * p * * - m - - - m   ej=1
                 \
                  \__ Will find this edge_u


        We will search for the start edge in this order,
           1. South border
           2. East border
           3. North border
           4. West border

                       <---
                   +----------+
                   |  North   |    
               |  W|          |E   ^
               |  e|          |a   |
               v  s|          |s   |
                  t|  South   |t    
                   +----------+
                       ---> 
    !!<    

    integer :: quarter
    integer :: b, i, j
    char(len=1) :: direct

    ! To shorten.
    integer <const> :: MM = SLICE_MESH__EDGE_MM
    integer <const> :: PP = SLICE_MESH__EDGE_PP
    integer <const> :: MP = SLICE_MESH__EDGE_MP
    integer <const> :: PM = SLICE_MESH__EDGE_PM

    call ut__assert( path.num == 0,  &
                    '__MODULE__(__LINE__): You forgot to reset contour_curve.' )

    do b = 1, mesh_vert.border_list_num
      i = mesh_vert.border_list_vi(b)
      j = mesh_vert.border_list_vj(b)
      direct = mesh_vert.border_list_dir(i,j)
!debugp "I am find_start_edge_on_boundaries", i, j, direct      
      call ut__assert( direct == 'N' .or.          &
                       direct == 'S' .or.          &
                       direct == 'E' .or.          &
                       direct == 'W' ,             &
                       "__MODULE__(__LINE__): " // &
                       "direct error." )
      select case (direct)
        case ('N')        
          quarter = mesh_edge.v_quarter(i,j)
        case ('S')        
          quarter = mesh_edge.v_quarter(i,j-1)
        case ('E') 
          quarter = mesh_edge.u_quarter(i,j)
        case ('W') 
          quarter = mesh_edge.u_quarter(i-1,j)
      end select
      if ( quarter == PM  .or.  &
           quarter == MP  .or.  &
           quarter == PP ) then
        status = 'have found'
        select case (direct)
          case ('N')
            call iRegister_northern_border_edge( i, j, quarter )
          case ('S')
            call iRegister_southern_border_edge( i, j, quarter )
          case ('E')
            call iRegister_eastern_border_edge ( i, j, quarter )
          case ('W')
            call iRegister_western_border_edge ( i, j, quarter )
        end select
!debugp "I am find_start_edge_on_boundaries", status         
        return
      end if
    end do

  contains

    subroutine iRegister_western_border_edge( i, j, quarter )
      integer <in> :: i, j 
      integer <in> :: quarter  

      real :: u1, u2, v1
      integer :: ei, ej, vi, vj
      char(len=1) :: dir
      
      select case (quarter)
        case (PM)
          !   2nd register     1st register
          !             \     /
          !          * * p * * - - m - -
          u1 = mesh_edge.u_cross_coord(i-1,j)
          u2 = mesh_vert.pos_u(i-1)
          call ut__assert( u1 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (MP)
          !       2nd register       1st register
          !                 \       /
          !          - - m - * * * p * *
          u1 = mesh_vert.pos_u(i)
          u2 = mesh_edge.u_cross_coord(i-1,j)
          call ut__assert( u2 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (PP)
          !   2nd register           1st register
          !             \           /
          !          * * p * * * * p * *
          u1 = mesh_vert.pos_u(i)
          u2 = mesh_vert.pos_u(i-1)
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select

      v1 = mesh_vert.pos_v(j)
      call register( path, u1, v1 )
      call register( path, u2, v1 )

      ! Add path head.
      select case (quarter)
        case (MP)
          ei = i-1
          ej = j
          path.head = contour_curve__element_t( 'u', 'in', ei, ej, 'S' )
        case (PM,PP)
          vi = i - 1
          vj = j
          dir = mesh_vert.border_list_dir(vi,vj)
          path.head = contour_curve__element_t( 'u', 'on', vi, vj, dir )
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
      path.start = path.head
    end subroutine iRegister_western_border_edge

    subroutine iRegister_eastern_border_edge( i, j, quarter )
      integer <in> :: i, j 
      integer <in> :: quarter
      
      !!>           
          [case MP] (This is the most plausible case.)

                      |*      |     
                  - - m * - - p - - 
                      |  *    |     
                      |   *   |     
                      |    *  |     
                  ====m==== * p * *   ej=1 (bottom)
                            /   \
                1st register    \
                                  2nd register
          [case PM]


              ei=1 (left border)
              | *
              |*
              *       |     
              p - - - p -   
              *       *     
              *      *|     
              *     * |     
              p=== * =m===  ej=1 (bottom)
                \    \
                \    2nd register
                  1st register     

                    Incidentally, there will be no chance
                    to find the following start edge unless
                    we survey the south edge from the
                    right (i=u_nu) to the left (i=1).

                    |       |      *|       |
                - - p - - - p - - * m - - - m - -
                    |       |    *  |       |
                    |       |   *   |       |
                    |       |  *    |       |   ej=1
                ***p*******p** - - m - - - m - (bottom
                                \                border)
                                  start edge

          [case PP]

              ei=1 (left border)
              | *
              |*      |       |             
              *       |       |             
              p - - - p - - - p -           
              *       |       |             
              *       |       |             
              *       |       |             
              p * * * p * * * p * * ej=1 (bottom)   
                \       \
                \       2nd register
                  1st register     
      !!<

      real :: u1, u2, v1
      integer :: ei, ej, vi, vj
      char(len=1) :: dir

      select case (quarter)
        case (MP)
          u1 = mesh_edge.u_cross_coord(i,j)
          u2 = mesh_vert.pos_u(i+1)
          call ut__assert( u1 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (PM)
          u1 = mesh_vert.pos_u(i)
          u2 = mesh_edge.u_cross_coord(i,j)
          call ut__assert( u2 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (PP)
          u1 = mesh_vert.pos_u(i)
          u2 = mesh_vert.pos_u(i+1)
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select

      v1 = mesh_vert.pos_v(j)
      call register( path, u1, v1 )
      call register( path, u2, v1 )

      ! Add path head.
      select case (quarter)
        case (PM)
          ! You will laeave the south border and go north.
          ei = i
          ej = j
          path.head = contour_curve__element_t( 'u', 'in', ei, ej, 'N' )
        case (MP,PP)
          ! Continue going along the border.
          vi = i + 1
          vj = j
          dir = mesh_vert.border_list_dir(vi,vj)
          path.head = contour_curve__element_t( 'u', 'on', vi, vj, dir )
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
      path.start = path.head
    end subroutine iRegister_eastern_border_edge

    subroutine iRegister_northern_border_edge( i, j, quarter )
      integer <in> :: i, j 
      integer <in> :: quarter 
      !!>  
        [case MP]         
                 .         *     
               - p - - - - p <-- 2nd register
                 .         *
                 .         * <-- 1st register
                 .        *|     
                 .       * |     
                 .      *  |     
             * * p - - * - m
                 .     *   |
                   
        [case PM]         
                 .         |
               . p . . .*. m 
                 .       * |     
                 .        *|     
                 .         *  <== 2nd register   
                 .         *
               . p . . . . p  <== 1st register
                 .         *
        
        [case PP]         
                 .         *            
               - p - - - - p  <== 2nd register          
                 .         *             
                 .         *             
                 .         *             
               - p - - - - p  <== 1st register
                 .         *
      !!<
      real :: u1, v1, v2
      integer :: ei, ej, vi, vj
      char(len=1) :: dir

      select case (quarter)
        case (PM)
          v1 = mesh_vert.pos_u(j)
          v2 = mesh_edge.v_cross_coord(i,j)
          call ut__assert( v2 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (MP)
          v1 = mesh_edge.v_cross_coord(i,j)
          v2 = mesh_vert.pos_v(j+1)
          call ut__assert( v1 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (PP)
          v1 = mesh_vert.pos_v(j)
          v2 = mesh_vert.pos_v(j+1)
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select

      u1 = mesh_vert.pos_u(i)
      call register( path, u1, v1 )
      call register( path, u1, v2 )

      ! Add path head.
      select case (quarter)
        case (PM)
          ei = i
          ej = j
          path.head = contour_curve__element_t( 'v', 'in', ei, ej, 'W' )
        case (MP,PP)
          vi = i
          vj = j + 1
          dir = mesh_vert.border_list_dir(vi,vj)            
          path.head = contour_curve__element_t( 'v', 'on', vi, vj, dir )
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
      path.start = path.head
    end subroutine iRegister_northern_border_edge

    subroutine iRegister_southern_border_edge( i, j, quarter )
      integer <in> :: i, j 
      integer <in> :: quarter  

      real :: u1, v1, v2
      integer :: ei, ej, vi, vj
      char(len=1) :: dir

      select case (quarter)
        case (MP)
          v1 = mesh_vert.pos_u(j)
          v2 = mesh_edge.v_cross_coord(i,j-1)
          call ut__assert( v2 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (PM)
          v1 = mesh_edge.v_cross_coord(i,j-1)
          v2 = mesh_vert.pos_v(j-1)
          call ut__assert( v1 /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
        case (PP)
          v1 = mesh_vert.pos_v(j)
          v2 = mesh_vert.pos_v(j-1)
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select

      u1 = mesh_vert.pos_u(i)
      call register( path, u1, v1 )
      call register( path, u1, v2 )

      ! Add path head.
      select case (quarter)
        case (MP)
          ei = i
          ej = j-1
          path.head = contour_curve__element_t( 'v', 'in', ei, ej, 'E' )
        case (PM,PP)
          vi = i
          vj = j-1
          dir = mesh_vert.border_list_dir(vi,vj)
          path.head = contour_curve__element_t( 'v', 'on', vi, vj, dir )
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
      path.start = path.head
    end subroutine iRegister_southern_border_edge

  end subroutine find_start_edge_on_boundaries


  subroutine set_start_edge_in_bulk( path,         &
                                     mesh_vert,    &
                                     mesh_edge,    &
                                     status )  
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'

    ! To shorten.
    integer <const> :: MM = SLICE_MESH__EDGE_MM
    integer <const> :: PP = SLICE_MESH__EDGE_PP
    integer <const> :: MP = SLICE_MESH__EDGE_MP
    integer <const> :: PM = SLICE_MESH__EDGE_PM

    !!>
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m -*- - p - - * m - - - m -  
             |       *       |       *       |   
             |     * |       |       |*      |   
           - m - -*- p - - - p - - - p * - - m -  
             |    *  |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |      *|       |       |*      |   
             |       *       |       *       |   
           - m - - - m * - - P=====*=M - - - m -  
             |       |    *  |  * \  |       |   
             |       |       *     \ |       |   
           - m - - - m - - - m - - -\m - - - m -  
             |       |       |       \       |   
                                      \
                                       \___ Try to find this edge of "PM".
                 
    !!< 
    integer :: ei, ej
    integer :: quarter
    real :: u, v

    call ut__assert( path.num == 0,  &
                    '__MODULE__(__LINE__): You forgot to reset contour_curve.' )

!debugp "I am set_start_edge_in_bulk."
    do ej = 2, mesh_edge.u_nv-1
      do ei = 2, mesh_edge.u_nu-1
        quarter = mesh_edge.u_quarter(ei,ej)
!debugp "     set_start_edge_in_bulk:", ei, ej
!debugp "     set_start_edge_in_bulk:", quarter
        if ( quarter == PM ) then
          !!> 
              path tip you
              have just found.  *
                        |    \ *      |
                      --p=====*-------m--
                        |    *        |
             contour ---|-->*         |
                        |  *          |
                        | *           |
          !!<
          status = 'have found'
          u = mesh_edge.u_cross_coord(ei,ej)
          v = mesh_vert.pos_v(ej)
          call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
          call register( path, u, v )
          path.head = contour_curve__element_t( 'u', 'in', ei, ej, 'N' )
          path.start = path.head
          return
        end if
      end do
    end do

  end subroutine set_start_edge_in_bulk


  subroutine contour_curve__set_start_edge( this,         &
                                           mesh_vert,    &
                                           mesh_edge,    &
                                           status )
    class(contour_curve_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: mesh_vert
    type(slice_mesh__edge_t) <io> :: mesh_edge
    char(len=10) <out> :: status ! 'no contour' or 'have found'

    status = 'no contour'  ! default 
!debugp "I am  contour_curve__set_start_edge."
!debugp "     calling find_start_edge_on_boundaries." 
    call find_start_edge_on_boundaries( this,         &
                                        mesh_vert,    &
                                        mesh_edge,    &
                                        status )
    if ( status == 'have found' ) return

!debugp "     calling set_start_edge_in_bulk." 
    call set_start_edge_in_bulk( this,         &
                                 mesh_vert,    &
                                 mesh_edge,    &
                                 status )

  end subroutine contour_curve__set_start_edge


  subroutine contour_curve__trace_and_erase( path,  &
                                             vert,  &
                                             edge )
    class(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    do
!debugp "I am contour_curve__trace_and_erase."   
!debugp "    ", path.head.lane
!debugp "    ", path.head.i, path.head.j
      select case (path.head.lane)
        case ('on')
!debugp "      Im calling go_along_border."
          call go_along_border( path, vert, edge )
        case ('in')
!debugp "      Im calling jump_to_other_edge."
          call jump_to_other_edge( path, vert, edge )
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
      if ( path.is_closed() ) then
        call edge.erase( path.start.which_edge,  &
                         path.start.i,           &
                         path.start.j )
        return
      end if
    end do

  end subroutine contour_curve__trace_and_erase

end module contour_curve_m
