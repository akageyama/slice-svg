module contour_curve_m
  use ut_m
  use const_base_m
  use slice_mesh_m
  implicit none
  private

  !!> 
     To draw contour paths for a given level.
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m *-- - p - - * m - - - m -  
             |      *|       |       *       |   
             |    *  |       |       |*      |   
           - m -*- - p - - - p - - - p * - - m -  
             |   *   |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |     * |       |       |*      |   
             |     * |       |       *       |   
           - m - - * m - - - P - - * M - - - m -  
             |      *|       |  *    |       |   
             |       * * * * *       |       |   
           - m - - - m - - - m - - - m - - - m -  
             |       |       |       |       |   

     The border is usually rectangular,

          +=======+=======+=======+=======+=======+
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          + - - - + - - - + - - - + - - - + - - - +
          |       .       .       .       .       |
          |       .       .       .       .       |
          +=======+=======+=======+=======+=======+


     but it can be more complex shape like,

          . . . . . . . . S=======+=======+=======W
          .       .       |       .       .       |     
          .       .       |       .       .       |     
          . . . . S=======W . . . + . . . E=======N
          .       |       .       .       |       .     
          .       |       .       .       |       .     
          S=======W . . . + . . . + . . . N=======W
          |       .       .       .       .       |     
          |       .       .       .       .       |     
          E=======S . . . + . . . + . . . + . . . +
          .       |       .       .       .       |     
          .       |       .       .       .       |     
          . . . . E=======S . . . E=======+=======N
          .       .       |       |       .       .     
          .       .       |       |       .       .     
          . . . . . . . . E=======N . . . . . . . .
     
     Here the letter 'W' stands for the turning direction 
     when you go along the border in the anti-crlockwise.

     Another possible complex border is diagonal edge like

                         SW=======W=======W 
                        / .       .       . \    going
                      /   .       .       .   \    north-west
                    /     .       .       .     \    from this
                 SW . . . + . . . + . . . + . . . NW   <== vert 
                / .       .       .       .       |     
              /   .       .       .       .       |     
            /     .       .       .       .       |     
          S . . . + . . . + . . . + . . . + . . . N
          |       .       .       .       .       |     
          |       .       .       .       .       |     
          |       .       .       .       .       |     
         SE . . . + . . . + . . . + . . . + . . . N
            \     .       .       .       .     /
              \   .       .       .       .   /
                \ .       .       .       . /
                  E=======E=======E=======NE

      Mathematically, every contour line is closed unless it touches 
      on the border of the simulatin box (u=umin/umax or v=vmin/vmax).

      We set a virtual contour line along the border if the boudary grid
      vertices satisfy the condition 
          vert_val >= level  (denoted by "p" in the figure),
      see the upper right figure. 

      Since all contour lines are thus always closed, we first find an
      edge (starting edge) for each contour and draw the contour with
      keeping grid vertices with 
          vert_val >= level
      always in its left-hand side of the path.
      
      Starting edge of a trully closed contour (without touching the
      boundaries) is any u_edge with its quarter value "PM" (plus-in-left
      and minus-in-right of the edge).

      Cares should be taken for contour lines with virual (on-border)
      contours. 

           ei     ei+1    *      
           |       |    *       
       - - p - - - p -*-       
           |       |*         
           |      *|         
           |    *  |        
    ej - - p==*====m - -   
           | *  \  |              
           |*   PM |             
           *      \
                   \
                 start edge   
  !!< 

  type, public :: contour_curve__element_t
    character :: which_edge    ! 'u' or 'v' or 'a' or 'd'
    char(len=2) :: cruising_lane ! 'in' (bulk) or 'on' (border)
    integer :: i, j  ! id of edge (for in bulk lane), or 
                     ! id of vert (for on border lane).
    character :: path_go_toward  ! along the edge (for on border lane)
                                 ! perp to the edge (for bulk lane)
  end type contour_curve__element_t

  type, public :: contour_curve_t
    integer :: vert_nu, vert_nv
    integer :: num ! total number of vertex points of the path
    type(contour_curve__element_t) :: start
    type(contour_curve__element_t) :: head
    real, dimension(:), allocatable :: list_u, list_v
  contains
    procedure :: initialize => contour_curve__initialize
    procedure :: trace_and_erase => contour_curve__trace_and_erase
    procedure :: set_start_edge  &
                 => contour_curve__set_start_edge
    procedure :: reset => contour_curve__reset
    procedure :: is_closed => contour_curve__is_closed
    procedure :: register_new_vert  &
                          => contour_curve__register_new_vert
    procedure, private :: contour_curve__replace_head_by_octa
    procedure, private :: contour_curve__replace_head_direct
    generic :: replace_head_edge => contour_curve__replace_head_by_octa, &
                                    contour_curve__replace_head_direct
  end type contour_curve_t


contains


  subroutine contour_curve__replace_head_by_octa( this,         &
                                                  vi, vj,       &
                                                  octa_direct,  &
                                                  cruising_lane )
    class(contour_curve_t) <io> :: this
    integer <in> :: vi, vj
    integer <in> :: octa_direct
    char(len=2) <in> :: cruising_lane

    if ( cruising_lane == 'on' ) then
      select case ( octa_direct )
        case (0)
          this.head = contour_curve__element_t( 'v', 'on',   vi,   vj, 'N' )
        case (1)    
          this.head = contour_curve__element_t( 'a', 'on',   vi,   vj, 'N' )
        case (2)    
          this.head = contour_curve__element_t( 'u', 'on',   vi,   vj, 'E' )
        case (3)  
          this.head = contour_curve__element_t( 'd', 'on',   vi, vj-1, 'S' )
        case (4)  
          this.head = contour_curve__element_t( 'v', 'on',   vi, vj-1, 'S' )
        case (5)
          this.head = contour_curve__element_t( 'a', 'on', vi-1, vj-1, 'S' )
        case (6)
          this.head = contour_curve__element_t( 'u', 'on', vi-1,   vj, 'W' )
        case (7)  
          this.head = contour_curve__element_t( 'd', 'on', vi-1,   vj, 'N' )
        case default
          call ut__fatal( '__MODULE__(__LINE__): case error.' )
      end select
    else if ( cruising_lane == 'in' ) then
      select case ( octa_direct )
        case (0)
          this.head = contour_curve__element_t( 'v', 'in',   vi,   vj, 'W' )
        case (1)    
          this.head = contour_curve__element_t( 'a', 'in',   vi,   vj, 'N' )
        case (2)    
          this.head = contour_curve__element_t( 'u', 'in',   vi,   vj, 'N' )
        case (3)  
          this.head = contour_curve__element_t( 'd', 'in',   vi, vj-1, 'N' )
        case (4)  
          this.head = contour_curve__element_t( 'v', 'in',   vi, vj-1, 'E' )
        case (5)
          this.head = contour_curve__element_t( 'a', 'in', vi-1, vj-1, 'S' )
        case (6)
          this.head = contour_curve__element_t( 'u', 'in', vi-1,   vj, 'S' )
        case (7)  
          this.head = contour_curve__element_t( 'd', 'in', vi-1,   vj, 'S' )
        case default
          call ut__fatal( '__MODULE__(__LINE__): case error.' )
      end select
    else
      call ut__fatal( '__MODULE__(__LINE__): cruising_lane error.' )
    end if

  end subroutine contour_curve__replace_head_by_octa


  subroutine contour_curve__replace_head_direct( this,                  &
                                                 which_edge,            &
                                                 cruising_lane,         &
                                                 i, j,                  &
                                                 cross_this_edge_toward )
    class(contour_curve_t) <io> :: this
    character <in> :: which_edge
    char(len=2) <in> :: cruising_lane
    integer <in> :: i, j
    character <in> :: cross_this_edge_toward

    this.head = contour_curve__element_t( which_edge,              &
                                          cruising_lane,           &
                                          i,                       &
                                          j,                       &
                                          cross_this_edge_toward )
  end subroutine contour_curve__replace_head_direct


  subroutine contour_curve__register_new_vert( this, u, v )
    class(contour_curve_t) <io> :: this
    real <in> :: u, v

    integer :: n

    n = this.num + 1
    call ut__assert( n <= size(this.list_u,dim=1),  &
                    '__MODULE__(__LINE__): Increase array size of path_vert.' )

    this.list_u(n) = u
    this.list_v(n) = v
    this.num = n
  end subroutine contour_curve__register_new_vert


  subroutine jump_to_u_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    !!>  
             __ left
            /       ___ right
           /       /
          o - - - o
              |
            edge_u
    !!<
    integer :: vi_left, vj
    real :: u, v
    character :: flag_left
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi_left  = ei
    vj = ej

!debugp ei, ej
!debugp edge.u_quarter(ei,ej)
    if ( edge.u_quarter(ei,ej) == SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = edge.u_cross_coord(ei,ej)
      v = vert.pos_v(vj)
      call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v )
      flag_left = vert.flag(vi_left,vj)
      if ( flag_left == 'o' ) then
        call ut__fatal( "__MODULE__(__LINE__): " //  &
                        "Go out of the border?" )
      else if ( flag_left == 'i' ) then
        !     . n     .     
        !     .  n    .       n: next path
        ! - - P - * - M - -
        !     .    *  .
        !     .     * .
        call path.replace_head_edge( 'u', 'in', ei, ej, 'N' ) 
        call edge.erase( 'u', ei, ej )
      else ! vert_left on the border.
        octa_direct_along_border = vert.flag_to_octa_direct( flag_left )
        !            
        !    n  n  P * - - M - - 
        !          .   *   .
        !          .     * .
        call path.replace_head_edge( vi_left,                  &
                                     vj,                       &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'u', ei, ej ) 
      end if   
    end if
  end subroutine jump_to_u_edge_pm_if_possible


  subroutine jump_to_u_edge_mp_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi_right, vj
    real :: u, v
    character :: flag_right
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi_right = ei + 1
    vj = ej

    if ( edge.u_quarter(ei,ej) == SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = edge.u_cross_coord(ei,ej)
      v = vert.pos_v(vj)
      call ut__assert( u /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v )
      flag_right = vert.flag(vi_right,vj)
      if ( flag_right == 'o' ) then
        call ut__fatal( "__MODULE__(__LINE__): " //  &
                        "Go out of the border?" )
      else if ( flag_right == 'i' ) then
        !     . *     .
        !     .  *    .
        ! - - M - * - P - -
        !     .     n .   n: next path
        !     .       n
        call path.replace_head_edge( 'u', 'in', ei, ej, 'S' ) 
        call edge.erase( 'u', ei, ej )
      else ! vert_right on the border.
        octa_direct_along_border = vert.flag_to_octa_direct( flag_right )
        !
        !        . *     .
        !        .  *    .
        !    - - M - * * P n n n
        !
        call path.replace_head_edge( vi_right,                 &
                                     vj,                       &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'u', ei, ej ) 
      end if   
    end if
  end subroutine jump_to_u_edge_mp_if_possible  


  subroutine jump_to_v_edge_pm_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi, vj_lower
    real :: u, v
    character :: flag_lower
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi = ei
    vj_lower = ej

!debugp ei, ej
!debugp edge.v_quarter(ei,ej)
    if ( edge.v_quarter(ei,ej) == SLICE_MESH__EDGE_PM ) then
      jumped = .true.
      u = vert.pos_u(vi)
      v = edge.v_cross_coord(ei,ej)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v )
      flag_lower = vert.flag(vi,vj_lower)

      if ( flag_lower == 'o' ) then
        call ut__fatal( "__MODULE__(__LINE__): " //  &
                        "Go out of the border?" )
      else if ( flag_lower == 'i' ) then
        !             
        !      .   *   .
        !  - - M - * - + - -
        !      . *     .
        !      *       .
        !    n .       .
        !  n - P - - - + - -
        !      .       .
        call path.replace_head_edge( 'v', 'in', ei, ej, 'W' ) 
        call edge.erase( 'v', ei, ej )
      else ! vert_lower on the border.
        octa_direct_along_border = vert.flag_to_octa_direct( flag_lower )
        !             
        !      .   *   .
        !      M - * - + - -
        !      . *     .
        !      *       .
        !      n       .
        !      P - - - + - -
        !      n       .
        !      n       .
        !
        call path.replace_head_edge( vi,                       &
                                     vj_lower,                 &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'v', ei, ej ) 
      end if   
    end if
  end subroutine jump_to_v_edge_pm_if_possible   


  subroutine jump_to_v_edge_mp_if_possible( path, vert, edge, jumped,  &
                                            ei, ej )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge
    logical <io> :: jumped
    integer <in> :: ei, ej

    integer :: vi, vj_upper
    real :: u, v
    character :: flag_upper
    integer :: octa_direct_along_border

    if ( jumped ) return  ! you have already jumped for this cell.

    vi = ei
    vj_upper = ej + 1
!debugp vi, vj_upper
!debugp ei, ej
!debugp edge.v_quarter(ei,ej)
    if ( edge.v_quarter(ei,ej) == SLICE_MESH__EDGE_MP ) then
      jumped = .true.
      u = vert.pos_u(vi)
      v = edge.v_cross_coord(ei,ej)
      call ut__assert( v /= NAN, "__MODULE__(__LINE__): Invalid cross coord." )
      call path.register_new_vert( u, v ) 
      flag_upper = vert.flag(vi,vj_upper)

      if ( flag_upper == 'o' ) then
        call ut__fatal( "__MODULE__(__LINE__): " //  &
                        "Go out of the border?" )
      else if ( flag_upper == 'i' ) then
        !             
        !   .       .     n 
        !   + - - - P - n -
        !   .       . n     
        !   .       *       
        !   .     * .       
        !   + - * - M - - -
        !   .  *    .       
        call path.replace_head_edge( 'v', 'in', ei, ej, 'E' ) 
        call edge.erase( 'v', ei, ej )
      else ! vert_upper on the border.
        octa_direct_along_border = vert.flag_to_octa_direct( flag_upper )
        !             
        !   .       n 
        !   .       n 
        !   + - - - P 
        !   .       n
        !   .       *       
        !   .     * .       
        !   + - * - M
        !   .  *    .       
        !
        call path.replace_head_edge( vi,                       &
                                     vj_upper,                 &
                                     octa_direct_along_border, &
                                     'on' )
        call edge.erase( 'v', ei, ej ) 
      end if   
    end if
      
  end subroutine jump_to_v_edge_mp_if_possible 
 

  subroutine leave_from_boundary( vi, vj,        &
                                  octa_direct,   &
                                  ei, ej,        &
                                  which_edge,    &
                                  path_go_toward )
    integer <in> :: vi, vj
    integer <in> :: octa_direct
    integer <out> :: ei, ej
    character <out> :: which_edge
    character <out> :: path_go_toward

    select case (octa_direct)
      case (0)
        which_edge = 'v'
        path_go_toward = 'W'
        ei = vi
        ej = vj
      case (1) 
        which_edge = 'a'
        path_go_toward = 'N'
        ei = vi
        ej = vj
      case (2)
        which_edge = 'u'
        path_go_toward = 'N'
        ei = vi
        ej = vj
      case (3) 
        which_edge = 'd'
        path_go_toward = 'N'
        ei = vi
        ej = vj - 1
      case (4)
        which_edge = 'v'
        path_go_toward = 'E'
        ei = vi
        ej = vj - 1
      case (5) 
        which_edge = 'a'
        path_go_toward = 'S'
        ei = vi - 1
        ej = vj - 1
      case (6)
        which_edge = 'u'
        path_go_toward = 'S'
        ei = vi - 1
        ej = vj
      case (7) 
        which_edge = 'd'
        path_go_toward = 'S'
        ei = vi - 1
        ej = vj
      case default
        call ut__fatal( "__MODULE__(__LINE__) " //  &
                        "case error." )
    end select
    
  end subroutine leave_from_boundary


  subroutine one_step_along_boundary( path, vert, boundary, nth )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__boundary_t) <io> :: boundary
    integer <io> :: nth ! this is nth-vert of the border

    real :: u, v       ! coordinates of path tip that is to be registered.
    integer :: vi, vj  ! vertex indeces i and j
    integer :: vi2, vj2, nth_next
    integer :: ei, ej  ! edge indeces i and j
    integer :: numbv, quarter, octa_direct2
    real :: u2, v2
    integer :: octa_direct
    character :: path_go_toward
    character :: which_edge
    char(len=2) :: cruising_lane

    call ut__assert( path.head.cruising_lane == 'on',  &
                     "__MODULE__(__LINE__): The path should be on border." )

    !!>
               v1--[e1]--v2--[e2]--v3
              /                    /
            [e6]                 [e3]
            /                    /
           v6--[e5]--v5--[e4]--v4
    !!<

    vi = path.head.i
    vj = path.head.j
    numbv = boundary.vert.num
    call ut__assert( boundary.vert.vi(nth) == vi .and.   &
                     boundary.vert.vj(nth) == vj,        &
                     "__MODULE__(__LINE__): border vert inconsistent." )

    quarter = boundary.edge.quarter(nth)
    
    if ( quarter == SLICE_MESH__EDGE_PP ) then
      !!>
                 .            
                 .            
                 .            
             - - p <== You are going to register this vert (vi2,vj2)
                 *
                 * <== You are going to replace by this edge.
                 *            
             - - p <== present num, present (vi,vj)
                 . \_____ previous (vi2,vj2), lastly registered vert
                 . <== previous head edge
                 . 
             - - p <== previous (vi,vj)
                 .            
      !!<      
      nth_next = nth + 1
      if ( nth_next > numbv ) nth_next -= numbv ! cyclic.
      u2 = vert.pos_u(boundary.vert.vi(nth_next))
      v2 = vert.pos_v(boundary.vert.vj(nth_next))

      call path.register_new_vert( u2, v2 )
      call boundary.edge.erase( nth )
      octa_direct = boundary.vert.octa_direct(nth_next)
      cruising_lane = 'on'
      call path.replace_head_edge( vi, vj, octa_direct, cruising_lane )
      nth = nth_next
    else if ( quarter == SLICE_MESH__EDGE_PM ) then
      !!>
                 .
                 .            
             - - p  _____ you are going to register this point
                 . /
             * * * <== present head edge
                 *            
             - - p <== present num, present (vi,vj)
                 . \_____ previous (vi2,vj2), lastly registered vert
                 . <== previous head edge
                 . 
             - - p <== previous (vi,vj)
                 .            
      !!<
      u2 = boundary.edge.u_cross_coord(nth)
      v2 = boundary.edge.v_cross_coord(nth)
      call ut__assert( u2 /= NAN .and. v2 /= NAN,   &
                       "__MODULE__(__LINE__): Invalid cross coord." )

      call path.register_new_vert( u2, v2 )
      call boundary.edge.erase( nth )
      octa_direct = boundary.vert.octa_direct(nth)
      call leave_from_boundary( vi, vj,         &
                                octa_direct,    &
                                ei, ej,         &
                                which_edge,     &
                                path_go_toward )
      cruising_lane = 'in'
      call path.replace_head_edge( which_edge,     &
                                   cruising_lane,  &
                                   ei,             &
                                   ej,             &
                                   path_go_toward )
    else
      call ut__fatal( '__MODULE__(__LINE__): Strange. Path terminated?' )
    end if

  end subroutine one_step_along_boundary


  subroutine jump_to_other_edge_from_edge_uv( path,  &
                                              vert,  &
                                              edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: ei, ej
    logical :: jumped
!debugp "test"
    call ut__assert( path.head.which_edge == 'u' .or.   &
                     path.head.which_edge == 'v',       &
                     "__MODULE__(__LINE__): " //        &
                     "head is to be u_ or v_edge." )
    call ut__assert( path.head.cruising_lane == 'in',  &
                     "__MODULE__(__LINE__): The path should be in the region." )

    jumped = .false.  ! Default.

    ei = path.head.i
    ej = path.head.j

!debugp "test2"
!debugp ei, ej
!debugp path.head.path_go_toward

    select case (path.head.path_go_toward)
      !!>
                        edge.u(i,j+1)
                            .
                   vertex   .     vertex
                   (i,j+1)  .     (i+1,j+1)
                       \    .    /
                        + - - - +
                        |       |
          edge.v(i,j) --|       |-- edge.v(i+1,j)
                        |       |
                        + - - - +
                       /    .    \
                   vertex   .   vertex
                    (i,j)   .   (i+1,j)
                            .
                        edge.u(i,j)
      !!<
      case ('N')
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )
!debugp "calling jump_to_v_edge_mp_if_possible"
        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej )
!debugp "called ", jumped
                         !!>
                              p - - p
                              |    *|To
                              |   * |
                              p -*- m
                                From 
                         !!<
!debugp "calling jump_to_u_edge_pm_if_possible"
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
!debugp "called ", jumped
                         !!>
                                To
                              p -*- m
                              |  *  |
                              |  *  |
                              p -*- m
                                From 
                         !!<
!debugp "calling jump_to_v_edge_pm_if_possible"
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
!debugp "called ", jumped
                         !!>
                              m - - m
                            To*     |
                              | *   |
                              p - * m
                                From 
                         !!<
      case ('W')
        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej+1 )
                         !!>
                                To
                              p -*- m
                              |   * |
                              |    *|From
                              p - - p
                         !!<
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |     |
                            To|* * *|From
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei-1, ej )
                         !!>
                              m - - m
                              |    *|
                              |   * |From
                              m -*- p
                                To
                         !!<
      case ('S')
        call ut__assert( path.head.which_edge == 'u',  &
                         "__MODULE__(__LINE__): Must be edge-u here." )
        call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              | *   |
                           To |*    |
                              p - - p
                         !!<
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej-1 )
                         !!>
                                From
                              m -*- p
                              |  *  |
                              |  *  |
                              m -*- p
                                 To
                         !!<
        call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei+1, ej-1 )
                         !!>
                                From
                              m -*- p
                              |   * |
                              |    *|To
                              m - - m
                         !!<
      case ('E')

        call ut__assert( path.head.which_edge == 'v',  &
                         "__MODULE__(__LINE__): Must be edge-v here." )
        call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                            jumped, ei, ej )
                         !!>
                              p - - p
                         From *     |
                              |*    |
                              m * - p
                                To
                         !!<
        call jump_to_v_edge_mp_if_possible ( path, vert, edge,  &
                                            jumped, ei+1, ej )
                         !!>
                              p - - p
                         From * * * * To
                              |     |
                              m - - m
                         !!<
        call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                            jumped, ei, ej+1 )
                         !!>
                                To
                              p * - m
                              |*    |
                         From *     |
                              m - - m
                         !!<
      case default
        call ut__fatal( '__MODULE__(__LINE__): case error.' )
    end select

    call ut__assert( jumped,  &
                     "__MODULE__(__LINE__): Failed to find next path." )
  end subroutine jump_to_other_edge_from_edge_uv



  subroutine jump_to_other_edge_from_edge_ad( path,  &
                                              vert,  &
                                              edge )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <io> :: edge

    integer :: ei, ej
    logical :: jumped

    call ut__assert( path.head.cruising_lane == 'in',  &
                     "__MODULE__(__LINE__): The path should be in the region." )

    jumped = .false.  ! Default.

    ei = path.head.i
    ej = path.head.j

    select case (path.head.which_edge)
      case ('a')
        if ( path.head.path_go_toward == 'N' ) then
          !!>                     
               vertex(i,j+1)=> P - * - M
                               |   * . |
                               |   *   |
                               | *     |
                vertex(i,j) => P - - - + 
          !!<
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej+1 )
          !!>
               vertex(i,j+1)=> M - - - M
                               |     . |
                               * * *   |
                               | *     |
                vertex(i,j) => P - - - + 
          !!<
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
        else if ( path.head.path_go_toward == 'S' ) then
          !!>                     
               vertex(i,j+1)=> + - - - P
                               |     * |
                               |   *   |
                               | . *   |
                vertex(i,j) => M - * - P 
          !!<
          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
          !!> 
               vertex(i,j+1)=> M - - - P
                               |     * |
                               |   * * *
                               | .     |
                vertex(i,j) => M - - - M 
          !!<
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej )
        else 
          call ut__fatal( "__MODULE__(__LINE__): arg error." )
        end if
      case ('d')
        if ( path.head.path_go_toward == 'N' ) then
          !!>
               vertex(i,j+1)=> P - - - P
                               | *     |
                               |   * * *
                               |     . |
                vertex(i,j) => + - - - M 
          !!<
          call jump_to_v_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei+1, ej )
          !!>                     
               vertex(i,j+1)=> P - - * M
                               | *  *  |
                               |   *   |
                               |     . |
                vertex(i,j) => + - - - M 
          !!<
          call jump_to_u_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej+1 )
        else if ( path.head.path_go_toward == 'S' ) then
          !!> 
               vertex(i,j+1)=> M - - - +
                               | .     |
                               * * *   |
                               |     * |
                vertex(i,j) => P - - - P 
          !!<
          call jump_to_v_edge_pm_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
          !!>                     
               vertex(i,j+1)=> M - - - +
                               | .     |
                               |   *   |
                               |  *  * |
                vertex(i,j) => M * - - P 
          !!<
          call jump_to_u_edge_mp_if_possible( path, vert, edge,  &
                                              jumped, ei, ej )
        else 
          call ut__fatal( "__MODULE__(__LINE__): arg error." )
        end if
      case default
        call ut__fatal( "__MODULE__(__LINE__): case error." )
    end select

    call ut__assert( jumped,  &
                     "__MODULE__(__LINE__): Failed to find next path." )
  end subroutine jump_to_other_edge_from_edge_ad


  function contour_curve__is_closed( this ) result(ans)
    class(contour_curve_t) <in> :: this
    logical :: ans

    logical :: con1, con2, con3

    con1 = ( this.head.which_edge == this.start.which_edge )
    con2 = ( this.head.i == this.start.i )
    con3 = ( this.head.j == this.start.j )
    ans = ( con1 .and. con2 .and. con3 )
  end function contour_curve__is_closed  


  subroutine contour_curve__reset( this )
    class(contour_curve_t) <io> :: this
    this.num = 0
    this.list_u(:) = 0.0
    this.list_v(:) = 0.0
  end subroutine contour_curve__reset


  subroutine contour_curve__initialize( this, vert_nu, vert_nv )
    class(contour_curve_t) <out> :: this
    integer <in> :: vert_nu, vert_nv

    integer :: max_path_element_num

    max_path_element_num = vert_nu * vert_nv
      ! extreme case like a Peano curve

    allocate(this.list_u(max_path_element_num))
    allocate(this.list_v(max_path_element_num))

    this.vert_nu = vert_nu
    this.vert_nv = vert_nv
    call this.reset
  end subroutine contour_curve__initialize


  subroutine find_start_edge_on_boundaries( path,     &
                                            vert,     &
                                            boundary, &
                                            status )
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__boundary_t) <in> :: boundary
    char(len=10) <io> :: status ! 'no contour' or 'have found'


    !!>
             |       |       |    _ Contour line     | 
           - m - - - m - - - m   /    at "level" - - m
             |       |       * */                    |
             |       |    *  |   *   |       |       |      
           - m - - - m -*- - p - - * m - - - m - - - m   ej=3
             |       *       |       *       |       |
             |     * |       |       | *     |       |
           - m - -*- p - - - p - - - p - * - m - - - m   ej=2
             |    *  |       |       |    *  |       |
             |    *  |       |       |    *  |       |
           - m - - * p * * * p * * * p * * - m - - - m   ej=1
                 \
                  \__ Will find this edge_u


        We will search for the start edge in this order,
           1. South border
           2. East border
           3. North border
           4. West border

                       <---
                   +----------+
                   |  North   |    
               |  W|          |E   ^
               |  e|          |a   |
               v  s|          |s   |
                  t|  South   |t    
                   +----------+
                       ---> 
    !!<    

    integer :: quarter
    integer :: vert_index1, vert_index2
    integer :: edge_index, ei, ej
    integer :: i, j
    integer :: octa_direct
    real :: u1, v1, u2, v2
    char(len=2) :: cruising_lane
    character :: path_go_toward
    character :: which_edge

    call ut__assert( path.num == 0,  &
                    '__MODULE__(__LINE__): You forgot to reset contour_curve.' )

!debugp "calling do edge_index"
    do edge_index = 1, boundary.edge.num
!debugp edge_index
      quarter = boundary.edge.quarter(edge_index)
!debugp quarter
      if ( quarter == SLICE_MESH__EDGE_PP  .or.  &
           quarter == SLICE_MESH__EDGE_PM ) then
        status = 'have found'
        vert_index1 = edge_index
        u1 = vert.pos_u(boundary.vert.vi(vert_index1))
        v1 = vert.pos_v(boundary.vert.vj(vert_index1))
        call path.register_new_vert( u1, v1 )

        if ( quarter == SLICE_MESH__EDGE_PP ) then
          vert_index2 = vert_index1 + 1 ! next vert in the border path
          if ( vert_index2 > boundary.vert.num )  &
               vert_index2 -= boundary.vert.num
          u2 = vert.pos_u(boundary.vert.vi(vert_index2))
          v2 = vert.pos_v(boundary.vert.vj(vert_index2))
          cruising_lane = 'on'
        else ! quarter == SLICE_MESH__EDGE_PM
          u2 = boundary.edge.u_cross_coord(edge_index)
          v2 = boundary.edge.v_cross_coord(edge_index)
          call ut__assert( u2 /= NAN .and. v2 /= NAN,  &
                           "__MODULE__(__LINE__): Invalid cross coord." )
          cruising_lane = 'in'
        end if

        call path.register_new_vert( u2, v2 )
        octa_direct = boundary.vert.octa_direct(vert_index1)
        call leave_from_boundary( boundary.vert.vi(vert_index1),  &
                                  boundary.vert.vj(vert_index1),  &
                                  octa_direct,                    &
                                  ei, ej,                         &
                                  which_edge,                     &
                                  path_go_toward )
        cruising_lane = 'in'
        call path.replace_head_edge( which_edge,     &
                                     cruising_lane,  &
                                     ei,             &
                                     ej,             &
                                     path_go_toward )
        path.start = path.head
        return
      end if
    end do

  end subroutine find_start_edge_on_boundaries


  subroutine set_start_edge_in_bulk( path,    &
                                     vert,    &
                                     edge,    &
                                     status )  
    type(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge
    char(len=10) <io> :: status ! 'no contour' or 'have found'

    !!>
             |       |       |       |       |    
           - m - - - m - - - m - - - m - - - m - 
             |       |       *       |       |   
             |       |    *  |  *    |       |         
           - m - - - m -*- - p - - * m - - - m -  
             |       *       |       *       |   
             |     * |       |       |*      |   
           - m - -*- p - - - p - - - p * - - m -  
             |    *  |       |       | *     |   
             |    *  |       |       | *     |   
           - m - - * p - - - p - - - p * - - m -  
             |      *|       |       |*      |   
             |       *       |       *       |   
           - m - - - m * - - P=====*=M - - - m -  
             |       |    *  |  * \  |       |   
             |       |       *     \ |       |   
           - m - - - m - - - m - - -\m - - - m -  
             |       |       |       \       |   
                                      \
                                       \___ Try to find this edge with "PM".
                 
    !!< 
    integer :: ei, ej      ! index of edge position
    integer :: vj ! index of vert position
    integer :: quarter
    real :: u, v

    call ut__assert( path.num == 0,                     &
                    '__MODULE__(__LINE__): ' //         &
                    'Forgot to reset contour_curve.' )

    !!>
        The rectangular edges of v_edge(1,:), u_edge(:,1), etc. 
        cannot be 'i' grid, i.e., inside the border.
    !!<
    do ej = 2, edge.u_nv-1
      vj = ej
      do ei = 2, edge.u_nu-1
        quarter = edge.u_quarter(ei,ej)
        if ( quarter == SLICE_MESH__EDGE_PM ) then
          !!> 
               path tip you
               have just found.  *
                         |    \ *      |
                       --p=====*-------m--
                         |    *        |
              contour ---|-->*         |
                         |  *          |
                         | *           |
          !!<
          status = 'have found'
          u = edge.u_cross_coord(ei,ej)
          v = vert.pos_v(vj)
          call ut__assert( u /= NAN,                    &
                           "__MODULE__(__LINE__): " //  &
                           "Invalid cross coord." )
          call path.register_new_vert( u, v )
          call path.replace_head_edge( 'u', 'in', ei, ej, 'N' )
          path.start = path.head
          return
        end if
      end do
    end do

  end subroutine set_start_edge_in_bulk


  subroutine contour_curve__set_start_edge( this,     &
                                            vert,     &
                                            edge,     &
                                            boundary, &
                                            status )
    class(contour_curve_t) <io> :: this
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__edge_t) <in> :: edge
    type(slice_mesh__boundary_t) <in> :: boundary
    char(len=10) <out> :: status ! 'no contour' or 'have found'

    status = 'no contour'  ! default 
!debugp "calling find_start_edge_on_boundaries"
    call find_start_edge_on_boundaries( this,     &
                                        vert,     &
                                        boundary, &
                                        status )
    if ( status == 'have found' ) return

!debugp "calling set_start_edge_in_bulk"
    call set_start_edge_in_bulk( this,    &
                                 vert,    &
                                 edge,    &
                                 status )

  end subroutine contour_curve__set_start_edge


  subroutine contour_curve__trace_and_erase( path,      &
                                             vert,      &
                                             edge,      &
                                             boundary )
    class(contour_curve_t) <io> :: path
    type(slice_mesh__vert_t) <in> :: vert
    type(slice_mesh__boundary_t) <io> :: boundary
    type(slice_mesh__edge_t) <io> :: edge

    integer :: nthbv ! of border verts
    char(len=2) :: cruising_lane_prev

    cruising_lane_prev = '  ' ! char len=2 other than 'on'
!debugp "entering do-loop"
    do
      select case (path.head.cruising_lane)
        case ('on')
!debugp "case on"
          if ( cruising_lane_prev /= 'on' ) then
            ! newly start tracing on the border.
!debugp "calling boundary.vert.get_nth"
            nthbv = boundary.vert.get_nth( path.head.i,  &
                                           path.head.j )
          end if
!debugp "calling one_step_along_boundary"
          call one_step_along_boundary( path, vert, boundary, nthbv )
        case ('in')
!debugp "case in"
          if ( path.head.which_edge == 'u' .or.  &
               path.head.which_edge == 'v'  ) then
!debugp "calling jump_to_other_edge_from_edge_uv"
            call jump_to_other_edge_from_edge_uv( path, vert, edge )
          else
!debugp "calling jump_to_other_edge_from_edge_ad"
            call jump_to_other_edge_from_edge_ad( path, vert, edge )
          end if
        case default
          call ut__fatal( "__MODULE__(__LINE__): case error." )
      end select
      cruising_lane_prev = path.head.cruising_lane
      if ( path.is_closed() ) return
    end do

  end subroutine contour_curve__trace_and_erase

end module contour_curve_m
